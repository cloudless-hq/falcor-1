{"version":3,"sources":["../../src/components/container.js"],"names":["container","defaultMapFragmentToProps","data","defaultMapDispatchToProps","dispatch","props","falcor","defaultMergeProps","stateProps","dispatchProps","parentProps","fragmentDesc","fragment","renderErrors","renderLoading","mapFragment","mapDispatch","mapFragmentAndProps","dispatchers","actionCreators","reduce","key","actionCreator","state","BaseComponent","FalcorContainer","fragments","Component","displayName","items","hasOwnProperty","map","xs","i","x","derefEachPropUpdate","update","_seed","json","deref","fetchEachPropUpdate","let","source","takeLast","mergeEachPropUpdate","error","version","loading","hash","$__hash","contextTypes","object","func","context","constructor","getVersion","propsStream","propsAction","switchMap","nextProps","nextState","nextContext","currProps","currState","currData","style","currStyle","restCurrProps","nextData","nextStyle","restNextProps","next","propsSubscription","subscribe","setState","unsubscribe","undefined","mergeFragmentAndProps","outerData","mappedFragment","allMergedProps","childContextTypes"],"mappings":"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","file":"container.js","sourcesContent":["import invariant from 'invariant';\nimport React, { PropTypes, Children } from 'react';\nimport hoistStatics from 'recompose/hoistStatics';\nimport shallowEqual from 'recompose/shallowEqual';\nimport mapToFalcorJSON from '../utils/mapToFalcorJSON';\nimport wrapDisplayName from 'recompose/wrapDisplayName';\nimport fetchDataUntilSettled from '../utils/fetchDataUntilSettled';\n\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/switchMap';\n\nconst defaultMapFragmentToProps = (data) => data;\nconst defaultMapDispatchToProps = (dispatch, props, falcor) => ({});\nconst defaultMergeProps = (stateProps, dispatchProps, parentProps) => ({\n    ...parentProps, ...stateProps, ...dispatchProps\n});\n\nexport default function container(fragmentDesc, ...rest) {\n\n    invariant(fragmentDesc && (\n        typeof fragmentDesc === 'function' || (\n        typeof fragmentDesc === 'object' &&\n        typeof fragmentDesc.fragment === 'function')),\n`Attempted to create a Falcor container component without a fragment.\nFalcor containers must be created with either a fragment function or an Object with a fragment function.`);\n\n    let renderErrors = false,\n        renderLoading = false,\n        fragment, mapFragment,\n        mapDispatch, mapFragmentAndProps;\n\n    if (typeof fragmentDesc === 'object') {\n        fragment = fragmentDesc.fragment;\n        mapFragment = fragmentDesc.mapFragment;\n        renderErrors = fragmentDesc.renderErrors;\n        renderLoading = fragmentDesc.renderLoading;\n        mapFragmentAndProps = fragmentDesc.mapFragmentAndProps;\n        mapDispatch = fragmentDesc.mapDispatch || fragmentDesc.dispatchers;\n    } else {\n        fragment = fragmentDesc;\n        mapFragment = rest[0];\n        mapDispatch = rest[1];\n        mapFragmentAndProps = rest[2];\n    }\n\n    mapFragment = mapFragment || defaultMapFragmentToProps;\n    mapDispatch = mapDispatch || defaultMapDispatchToProps;\n    mapFragmentAndProps = mapFragmentAndProps || defaultMergeProps;\n\n    if (typeof mapDispatch !== 'function') {\n        if (mapDispatch && typeof mapDispatch !== 'object') {\n            mapDispatch = defaultMapDispatchToProps;\n        } else {\n            mapDispatch = function(actionCreators) {\n                return function(container) {\n                    return Object.keys(actionCreators).reduce((dispatchers, key) => {\n                        const actionCreator = actionCreators[key];\n                        dispatchers[key] = (...args) => {\n                            const { falcor, dispatch } = container.state;\n                            return dispatch({ falcor, ...actionCreator(...args) });\n                        };\n                        return dispatchers;\n                    }, {});\n                }\n            }(mapDispatch);\n        }\n    }\n\n    return hoistStatics((BaseComponent) => class Container extends FalcorContainer {\n        static fragment = fragment;\n        static fragments = fragments;\n        static Component = BaseComponent;\n        static mapFragment = mapFragment;\n        static mapDispatch = mapDispatch;\n        static renderErrors = renderErrors;\n        static renderLoading = renderLoading;\n        static mapFragmentAndProps = mapFragmentAndProps;\n        static displayName = wrapDisplayName(BaseComponent, 'Container');\n    });\n}\n\nconst fragments = function(items = []) {\n    if (!items || typeof items !== 'object') {\n        return `{ length }`;\n    } else if (!items.hasOwnProperty('length')) {\n        items = Object.keys(items).map((key) => items[key]);\n    }\n    return `{ length ${Array\n        .from(items, (xs, i) => xs)\n        .reduce((xs, x, i) => `${xs}, ${i}: ${this.fragment(x)}`, '')\n    }}`;\n}\n\nfunction derefEachPropUpdate(update) {\n    let { data, falcor } = update;\n    update.data = data = mapToFalcorJSON(data);\n    if (!falcor._seed || !falcor._seed.json || falcor._seed.json !== data) {\n        update.falcor = falcor.deref(data);\n    }\n    return update;\n}\n\nfunction fetchEachPropUpdate({ container, data, props, falcor }) {\n    const { fragment, renderLoading } = container;\n    return fetchDataUntilSettled({\n        data, props, falcor, fragment, renderLoading\n    }).let((source) => renderLoading === true ?\n        source : source.takeLast(1)\n    );\n}\n\nfunction mergeEachPropUpdate(\n    { props, falcor, dispatch },\n    { data, error, version, loading }\n) {\n    return {\n        data, error, loading,\n        falcor, dispatch, version,\n        hash: data && data.$__hash\n    };\n}\n\nconst contextTypes = {\n    falcor: PropTypes.object,\n    dispatch: PropTypes.func\n};\n\nclass FalcorContainer extends React.Component {\n\n    static contextTypes = contextTypes;\n    static childContextTypes = contextTypes;\n\n    constructor(props, context) {\n        super(props, context);\n\n        let { data } = props;\n        let { falcor, dispatch } = context;\n        const { fragment,\n                Component,\n                mapFragment,\n                mapDispatch,\n                renderErrors,\n                renderLoading,\n                mapFragmentAndProps\n        } = this.constructor;\n\n        this.fragment = fragment;\n        this.Component = Component;\n        this.mapFragment = mapFragment;\n        this.renderErrors = renderErrors;\n        this.renderLoading = renderLoading;\n        this.dispatchers = mapDispatch(this);\n        this.mapFragmentAndProps = mapFragmentAndProps;\n\n        falcor = falcor.deref(data = mapToFalcorJSON(data));\n\n        this.state = {\n            hash: data.$__hash,\n            data, falcor, dispatch,\n            version: falcor.getVersion()\n        };\n\n        this.propsStream = new Subject();\n        this.propsAction = this.propsStream\n            .map(derefEachPropUpdate)\n            .switchMap(\n                fetchEachPropUpdate,\n                mergeEachPropUpdate\n            );\n    }\n    getChildContext() {\n        const { falcor, dispatch } = this.state;\n        return { falcor, dispatch };\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n\n        const { props: currProps = {},\n                state: currState = {} } = this;\n\n        if (this.renderLoading === true && currState.loading !== nextState.loading) {\n            return true;\n        } else if (currState.version !== nextState.version) {\n            return true;\n        } else if (currState.error !== nextState.error) {\n            return true;\n        } else if (currState.hash !== nextState.hash) {\n            return true;\n        }\n\n        const { data: currData,\n                style: currStyle = {},\n                ...restCurrProps } = currProps;\n\n        const { data: nextData,\n                style: nextStyle = currStyle,\n                ...restNextProps } = nextProps;\n\n        if (!shallowEqual(currData, nextData)) {\n            return true;\n        } else if (!shallowEqual(currStyle, nextStyle)) {\n            return true;\n        } else if (!shallowEqual(restCurrProps, restNextProps)) {\n            return true;\n        }\n\n        return false;\n    }\n    componentWillReceiveProps(nextProps, nextContext) {\n        // Receive new props from the owner\n        this.propsStream.next({\n            container: this,\n            props: nextProps,\n            data: nextProps.data,\n            falcor: nextContext.falcor,\n            dispatch: nextContext.dispatch\n        });\n    }\n    componentWillMount() {\n        // Subscribe to child prop changes so we know when to re-render\n        this.propsSubscription = this.propsAction.subscribe((nextState) => {\n            this.setState(nextState);\n        });\n        this.propsStream.next({\n            container: this,\n            props: this.props,\n            data: this.props.data,\n            falcor: this.context.falcor,\n            dispatch: this.context.dispatch\n        });\n    }\n    // componentWillUpdate() {\n    //     const { state = {} } = this;\n    //     const { falcor } = state;\n    //     if (falcor) {\n    //         const pathString = falcor.getPath().reduce((xs, key, idx) => {\n    //             if (idx === 0) {\n    //                 return key;\n    //             } else if (typeof key === 'number') {\n    //                 return `${xs}[${key}]`;\n    //             }\n    //             return `${xs}['${key}']`;\n    //         }, '');\n    //         console.log(`cwu:`, pathString);\n    //     }\n    // }\n    componentWillUnmount() {\n        // Clean-up subscription before un-mounting\n        this.propsSubscription.unsubscribe();\n        this.propsSubscription = undefined;\n        this.fragment = null;\n        this.Component = null;\n        this.dispatchers = null;\n        this.mapDispatch = null;\n        this.mapFragment = null;\n        this.renderLoading = null;\n        this.mergeFragmentAndProps = null;\n    }\n    render() {\n\n        const { Component,\n                dispatchers,\n                mapFragment,\n                renderErrors,\n                renderLoading,\n                mapFragmentAndProps } = this;\n\n        if (!Component) {\n            return null;\n        }\n\n        const { data: outerData, ...props } = this.props;\n        const { data, error, loading, falcor, dispatch } = this.state;\n\n        const mappedFragment = mapFragment(data, props);\n\n        const allMergedProps = mapFragmentAndProps(mappedFragment, dispatchers, props);\n\n        if (error && renderErrors === true) {\n            allMergedProps.error = error;\n        }\n\n        if (loading && renderLoading === true) {\n            allMergedProps.loading = loading;\n        }\n\n        return <Component { ...allMergedProps }/>;\n    }\n}\n"]}