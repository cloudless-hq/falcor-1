{"version":3,"sources":["../../src/utils/fetchDataUntilSettled.js"],"names":["fetchDataUntilSettled","memoizedQuerySyntax","data","falcor","fragment","props","of","prev","settled","expand","_fetchDataUntilSettled","takeLast","state","empty","query","from","get","map","json","catch","error"],"mappings":";;;;;;;;;;;;;kBAKwBA,qB;;AALxB;;AACA;;;;AACA;;;;;;;;;;AACA,IAAMC,sBAAsB,+BAAgB,GAAhB,CAA5B;;AAEe,SAASD,qBAAT,OAEZ;AAAA,QADCE,IACD,QADCA,IACD;AAAA,QADOC,MACP,QADOA,MACP;AAAA,QADeC,QACf,QADeA,QACf;;AAAA,QAD4BC,KAC5B;;AACC,WAAO,iBAAWC,EAAX,CAAc;AACjBC,cAAM,IADW,EACLC,SAAS,KADJ;AAEjBN,kBAFiB,EAEXC,cAFW,EAEHC,kBAFG,EAEOC;AAFP,KAAd,EAINI,MAJM,CAICC,sBAJD,EAKNC,QALM,CAKG,CALH,CAAP;AAMH;;AAED,SAASD,sBAAT,CAAgCE,KAAhC,EAAuC;AACnC,QAAIA,MAAMJ,OAAN,KAAkB,IAAtB,EAA4B;AACxB,eAAO,iBAAWK,KAAX,EAAP;AACH;AAHkC,QAI3BX,IAJ2B,GAIaU,KAJb,CAI3BV,IAJ2B;AAAA,QAIrBG,KAJqB,GAIaO,KAJb,CAIrBP,KAJqB;AAAA,QAIdE,IAJc,GAIaK,KAJb,CAIdL,IAJc;AAAA,QAIRJ,MAJQ,GAIaS,KAJb,CAIRT,MAJQ;AAAA,QAIAC,QAJA,GAIaQ,KAJb,CAIAR,QAJA;;AAKnC,QAAMU,QAAQV,SAASF,IAAT,EAAeG,KAAf,CAAd;AACA,QAAIS,UAAUP,IAAd,EAAoB;AAChB,eAAO,iBACFQ,IADE,CACGZ,OAAOa,GAAP,kCAAcf,oBAAoBa,KAApB,CAAd,EADH,EAEFG,GAFE,CAEE;AAAA,gBAAGC,IAAH,SAAGA,IAAH;AAAA,mBAAc,sBAAcN,KAAd,EAAqB;AACpCL,sBAAMO,KAD8B,EACvBZ,MAAM,mCAAoBA,IAApB,EAA0BgB,IAA1B;AADiB,aAArB,CAAd;AAAA,SAFF,EAKFC,KALE,CAKI,UAACC,KAAD;AAAA,mBAAW,iBAAWd,EAAX,CAAc,sBAAcM,KAAd,EAAqB;AACjDQ,4BADiD,EAC1CZ,SAAS;AADiC,aAArB,CAAd,CAAX;AAAA,SALJ,CAAP;AAQH;AACD,WAAO,iBAAWK,KAAX,EAAP;AACH","file":"fetchDataUntilSettled.js","sourcesContent":["import { Observable } from 'rxjs';\nimport memoizeQueryies from './memoizeQueryies';\nimport mergeIntoFalcorJSON from './mergeIntoFalcorJSON';\nconst memoizedQuerySyntax = memoizeQueryies(100);\n\nexport default function fetchDataUntilSettled({\n    data, falcor, fragment, ...props\n}) {\n    return Observable.of({\n        prev: null, settled: false,\n        data, falcor, fragment, props\n    })\n    .expand(_fetchDataUntilSettled)\n    .takeLast(1);\n}\n\nfunction _fetchDataUntilSettled(state) {\n    if (state.settled === true) {\n        return Observable.empty();\n    }\n    const { data, props, prev, falcor, fragment } = state;\n    const query = fragment(data, props);\n    if (query !== prev) {\n        return Observable\n            .from(falcor.get(...memoizedQuerySyntax(query)))\n            .map(({ json }) => Object.assign(state, {\n                prev: query, data: mergeIntoFalcorJSON(data, json)\n            }))\n            .catch((error) => Observable.of(Object.assign(state, {\n                error, settled: true\n            })));\n    }\n    return Observable.empty();\n}\n"]}