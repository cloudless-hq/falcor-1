{"version":3,"sources":["../../src/utils/fetchDataUntilSettled.js"],"names":["fetchDataUntilSettled","memoizedQuerySyntax","data","falcor","fragment","props","of","prev","settled","version","getVersion","expand","_fetchDataUntilSettled","takeLast","state","empty","query","parsed","error","process","env","NODE_ENV","from","get","ast","map","json","catch"],"mappings":";;;;;;;;;kBAMwBA,qB;;AANxB;;;;AACA;;AACA;;AACA;;;;;;;;AACA,IAAMC,sBAAsB,+BAAgB,GAAhB,CAA5B;;AAEe,SAASD,qBAAT,OAEZ;AAAA,QADCE,IACD,QADCA,IACD;AAAA,QADOC,MACP,QADOA,MACP;AAAA,QADeC,QACf,QADeA,QACf;;AAAA,QAD4BC,KAC5B;;AACC,WAAO,iBAAWC,EAAX,CAAc;AACjBC,cAAM,IADW,EACLC,SAAS,KADJ;AAEjBC,iBAASN,OAAOO,UAAP,EAFQ;AAGjBR,kBAHiB,EAGXG,YAHW,EAGJF,cAHI,EAGIC;AAHJ,KAAd,EAKNO,MALM,CAKCC,sBALD,EAMNC,QANM,CAMG,CANH,CAAP;AAOH;;AAED,SAASD,sBAAT,CAAgCE,KAAhC,EAAuC;AACnC,QAAIA,MAAMN,OAAN,KAAkB,IAAtB,EAA4B;AACxB,eAAO,iBAAWO,KAAX,EAAP;AACH;AAHkC,QAI3BZ,MAJ2B,GAINW,KAJM,CAI3BX,MAJ2B;AAAA,QAInBC,QAJmB,GAINU,KAJM,CAInBV,QAJmB;;AAKnC,QAAMY,QAAQZ,SAASU,MAAMZ,IAAf,EAAqBY,MAAMT,KAA3B,CAAd;AACA,QAAIW,UAAUF,MAAMP,IAAhB,IAAwBO,MAAML,OAAN,KAAkBN,OAAOO,UAAP,EAA9C,EAAmE;AAC/D,YAAMO,SAAShB,oBAAoBe,KAApB,CAAf;AACA,YAAIC,OAAOC,KAAX,EAAkB;AACd,mCAAQC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,aAAjC,EAAgD,6BAAaJ,OAAOC,KAApB,CAAhD;AACA,mCAAQC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,aAAjC,4BAAwEL,KAAxE;AACA,mBAAO,iBAAWV,EAAX,CAAc,sBAAcQ,KAAd,EAAqB;AACtCI,uBAAOD,OAAOC,KADwB,EACjBV,SAAS,IADQ,EACFC,SAASN,OAAOO,UAAP;AADP,aAArB,CAAd,CAAP;AAGH;AACD,eAAO,iBACFY,IADE,CACGnB,OAAOoB,GAAP,CAAWN,OAAOO,GAAlB,CADH,EAEFC,GAFE,CAEE;AAAA,gBAAGC,IAAH,SAAGA,IAAH;AAAA,mBAAc,sBAAcZ,KAAd,EAAqB;AACpCP,sBAAMS,KAD8B,EACvBd,MAAMwB,IADiB,EACXjB,SAASN,OAAOO,UAAP;AADE,aAArB,CAAd;AAAA,SAFF,EAKFiB,KALE,CAKI,UAACT,KAAD;AAAA,mBAAW,iBAAWZ,EAAX,CAAc,sBAAcQ,KAAd,EAAqB;AACjDI,4BADiD,EAC1CV,SAAS,IADiC,EAC3BC,SAASN,OAAOO,UAAP;AADkB,aAArB,CAAd,CAAX;AAAA,SALJ,CAAP;AAQH;AACD,WAAO,iBAAWK,KAAX,EAAP;AACH","file":"fetchDataUntilSettled.js","sourcesContent":["import warning from 'warning';\nimport { Observable } from 'rxjs';\nimport { errorMessage } from 'pegjs-util';\nimport memoizeQueryies from './memoizeQueryies';\nconst memoizedQuerySyntax = memoizeQueryies(100);\n\nexport default function fetchDataUntilSettled({\n    data, falcor, fragment, ...props\n}) {\n    return Observable.of({\n        prev: null, settled: false,\n        version: falcor.getVersion(),\n        data, props, falcor, fragment,\n    })\n    .expand(_fetchDataUntilSettled)\n    .takeLast(1);\n}\n\nfunction _fetchDataUntilSettled(state) {\n    if (state.settled === true) {\n        return Observable.empty();\n    }\n    const { falcor, fragment } = state;\n    const query = fragment(state.data, state.props);\n    if (query !== state.prev || state.version !== falcor.getVersion()) {\n        const parsed = memoizedQuerySyntax(query);\n        if (parsed.error) {\n            warning(process.env.NODE_ENV !== 'development', errorMessage(parsed.error));\n            warning(process.env.NODE_ENV !== 'development', `Error parsing query: ${query}`)\n            return Observable.of(Object.assign(state, {\n                error: parsed.error, settled: true, version: falcor.getVersion()\n            }));\n        }\n        return Observable\n            .from(falcor.get(parsed.ast))\n            .map(({ json }) => Object.assign(state, {\n                prev: query, data: json, version: falcor.getVersion()\n            }))\n            .catch((error) => Observable.of(Object.assign(state, {\n                error, settled: true, version: falcor.getVersion()\n            })));\n    }\n    return Observable.empty();\n}\n"]}