{"version":3,"sources":["../../src/utils/fetchDataUntilSettled.js"],"names":["fetchDataUntilSettled","memoizedQuerySyntax","data","falcor","fragment","props","of","prev","settled","version","getVersion","expand","_fetchDataUntilSettled","takeLast","state","empty","query","from","get","map","json","catch","error"],"mappings":";;;;;;;;;kBAIwBA,qB;;AAJxB;;AACA;;;;;;;;AACA,IAAMC,sBAAsB,+BAAgB,GAAhB,CAA5B;;AAEe,SAASD,qBAAT,OAEZ;AAAA,QADCE,IACD,QADCA,IACD;AAAA,QADOC,MACP,QADOA,MACP;AAAA,QADeC,QACf,QADeA,QACf;;AAAA,QAD4BC,KAC5B;;AACC,WAAO,iBAAWC,EAAX,CAAc;AACjBC,cAAM,IADW,EACLC,SAAS,KADJ;AAEjBC,iBAASN,OAAOO,UAAP,EAFQ;AAGjBR,kBAHiB,EAGXG,YAHW,EAGJF,cAHI,EAGIC;AAHJ,KAAd,EAKNO,MALM,CAKCC,sBALD,EAMNC,QANM,CAMG,CANH,CAAP;AAOH;;AAED,SAASD,sBAAT,CAAgCE,KAAhC,EAAuC;AACnC,QAAIA,MAAMN,OAAN,KAAkB,IAAtB,EAA4B;AACxB,eAAO,iBAAWO,KAAX,EAAP;AACH;AAHkC,QAI3BZ,MAJ2B,GAINW,KAJM,CAI3BX,MAJ2B;AAAA,QAInBC,QAJmB,GAINU,KAJM,CAInBV,QAJmB;;AAKnC,QAAMY,QAAQZ,SAASU,MAAMZ,IAAf,EAAqBY,MAAMT,KAA3B,CAAd;AACA,QAAIW,UAAUF,MAAMP,IAAhB,IAAwBO,MAAML,OAAN,KAAkBN,OAAOO,UAAP,EAA9C,EAAmE;AAC/D,eAAO,iBACFO,IADE,CACGd,OAAOe,GAAP,CAAWjB,oBAAoBe,KAApB,CAAX,CADH,EAEFG,GAFE,CAEE;AAAA,gBAAGC,IAAH,SAAGA,IAAH;AAAA,mBAAc,sBAAcN,KAAd,EAAqB;AACpCP,sBAAMS,KAD8B,EACvBd,MAAMkB,IADiB,EACXX,SAASN,OAAOO,UAAP;AADE,aAArB,CAAd;AAAA,SAFF,EAKFW,KALE,CAKI,UAACC,KAAD;AAAA,mBAAW,iBAAWhB,EAAX,CAAc,sBAAcQ,KAAd,EAAqB;AACjDQ,4BADiD,EAC1Cd,SAAS,IADiC,EAC3BC,SAASN,OAAOO,UAAP;AADkB,aAArB,CAAd,CAAX;AAAA,SALJ,CAAP;AAQH;AACD,WAAO,iBAAWK,KAAX,EAAP;AACH","file":"fetchDataUntilSettled.js","sourcesContent":["import { Observable } from 'rxjs';\nimport memoizeQueryies from './memoizeQueryies';\nconst memoizedQuerySyntax = memoizeQueryies(100);\n\nexport default function fetchDataUntilSettled({\n    data, falcor, fragment, ...props\n}) {\n    return Observable.of({\n        prev: null, settled: false,\n        version: falcor.getVersion(),\n        data, props, falcor, fragment,\n    })\n    .expand(_fetchDataUntilSettled)\n    .takeLast(1);\n}\n\nfunction _fetchDataUntilSettled(state) {\n    if (state.settled === true) {\n        return Observable.empty();\n    }\n    const { falcor, fragment } = state;\n    const query = fragment(state.data, state.props);\n    if (query !== state.prev || state.version !== falcor.getVersion()) {\n        return Observable\n            .from(falcor.get(memoizedQuerySyntax(query)))\n            .map(({ json }) => Object.assign(state, {\n                prev: query, data: json, version: falcor.getVersion()\n            }))\n            .catch((error) => Observable.of(Object.assign(state, {\n                error, settled: true, version: falcor.getVersion()\n            })));\n    }\n    return Observable.empty();\n}\n"]}