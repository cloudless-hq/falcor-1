{"version":3,"sources":["../../src/components/withFragment.js"],"names":["withFragment","contextTypes","object","bool","defaultMapFragment","remoteProps","defaultMergeProps","localProps","fragmentDesc","fragment","mergeProps","mapFragment","Component","props","context","config","FragmentContainer","fragments","load","fetchEachPropUpdate","childContextTypes","displayName","items","start","end","length","index","query","value","Math","min","max","tryDeref","data","model","_hasValidParentReference","deref","update","of","renderLoading","takeLast","mergeEachPropUpdate","error","version","hash","$__hash","status","$__status","loading","state","propsStream","propsAction","switchMap","shouldRenderLoading","propsSubscription","subscribe","nextState","setState","checkCacheAndUpdate","nextProps","nextContext","undefined","unsubscribe","hasOwnProperty","next","currProps","currState","currData","nextData","style","currStyle","restCurrProps","nextStyle","restNextProps","mappedFragment","mergedProps"],"mappings":"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","file":"withFragment.js","sourcesContent":["import invariant from 'invariant';\nimport React, { PropTypes, Children } from 'react';\nimport hoistStatics from 'recompose/hoistStatics';\nimport shallowEqual from 'recompose/shallowEqual';\nimport wrapDisplayName from 'recompose/wrapDisplayName';\nimport fetchDataUntilSettled from '../fetchDataUntilSettled';\n\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/takeLast';\nimport 'rxjs/add/operator/switchMap';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\n\nconst contextTypes = {\n    'falcorData': PropTypes.object,\n    'falcorModel': PropTypes.object,\n    'renderFalcorLoading': PropTypes.bool\n};\n\nfunction defaultMapFragment(remoteProps) { return remoteProps; }\nfunction defaultMergeProps(remoteProps, localProps) {\n    return { ...localProps, ...remoteProps };\n}\n\nexport default function withFragment(fragmentDesc, ...rest) {\n\n    invariant(fragmentDesc && (\n              'function' === typeof fragmentDesc || (\n              'object'   === typeof fragmentDesc &&\n              'function' === typeof fragmentDesc.fragment)),\n`Attempted to create a Fragment container component without a fragment definition.\nFragment containers must be created with a fragment function, or an Object with a \"fragment\" function.`);\n\n    if ('object' !== typeof fragmentDesc) {\n        fragmentDesc = {\n            fragment: fragmentDesc,\n            mergeProps: rest[1] || defaultMergeProps,\n            mapFragment: rest[0] || defaultMapFragment\n        };\n    } else {\n        if (!fragmentDesc.mergeProps) {\n            fragmentDesc.mergeProps = defaultMergeProps;\n        }\n        if (!fragmentDesc.mapFragment) {\n            fragmentDesc.mapFragment = defaultMapFragment;\n        }\n    }\n\n    return hoistStatics((Component) => {\n        return class Container extends FragmentContainer {\n            static fragments = fragments;\n            static load = fetchEachPropUpdate;\n            static contextTypes = contextTypes;\n            static childContextTypes = contextTypes;\n            static fragment = fragmentDesc.fragment;\n            static displayName = wrapDisplayName(Component, 'Container');\n            constructor(props, context) {\n                super(props, context);\n                this.config = fragmentDesc;\n                this.Component = Component;\n                this.fragment = fragmentDesc.fragment;\n            }\n        };\n    });\n}\n\nfunction fragments(items = [], start = 0, end = items && items.length) {\n    let index = -1, query = 'length';\n    if (items && 'object' === typeof items) {\n        let length = items.length;\n        if (length && typeof length === 'object' && typeof length.value === 'number') {\n            length = length.value;\n        }\n        length = Math.min(Math.max(0, end - start), length) | 0;\n        while (++index < length) {\n            query = `${\n            query},\n     ${     index}: ${this.fragment(items[index])}`;\n        }\n    }\n    return `{ ${query} }`;\n}\n\nfunction tryDeref({ data, model }) {\n    return !data || !model ?\n        model :\n        model._hasValidParentReference() ?\n        model.deref(data) : null;\n}\n\nfunction fetchEachPropUpdate(update) {\n\n    invariant(\n        update.fragment || (update.fragment = this.fragment),\n        `Attempted to fetch without a fragment definition`\n    );\n\n    if (!(update.model = tryDeref(update))) {\n        return Observable.of(update);\n    } else if (update.renderLoading === true) {\n        return fetchDataUntilSettled(update);\n    }\n    return fetchDataUntilSettled(update).takeLast(1);\n}\n\nfunction mergeEachPropUpdate(\n    { props, model },\n    { data, query, error, version }\n) {\n    const hash = data && data.$__hash;\n    const status = data && data.$__status;\n    const loading = status === 'pending';\n    return {\n        hash, data, query, props,\n        model, error, loading, version\n    };\n}\n\nclass FragmentContainer extends React.Component {\n    constructor(props, context) {\n        super(props, context);\n        this.state = {};\n        this.propsStream = new Subject();\n        this.propsAction = this.propsStream.switchMap(\n            fetchEachPropUpdate, mergeEachPropUpdate\n        );\n    }\n    getChildContext() {\n        const { data, model } = this.state;\n        return {\n            'falcorData': data, 'falcorModel': model,\n            'renderFalcorLoading': this.shouldRenderLoading()\n        };\n    }\n    componentWillMount() {\n        // Subscribe to child prop changes so we know when to re-render\n        this.propsSubscription = this.propsAction.subscribe((nextState) => {\n            this.setState(nextState);\n        });\n        this.checkCacheAndUpdate(this.props, this.context);\n    }\n    componentWillReceiveProps(nextProps, nextContext) {\n        this.checkCacheAndUpdate(nextProps, nextContext);\n    }\n    componentWillUnmount() {\n        this.config = undefined;\n        this.fragment = undefined;\n        this.Component = undefined;\n        this.propsAction = undefined;\n        this.propsStream = undefined;\n        // Clean-up subscription before un-mounting\n        this.propsSubscription.unsubscribe();\n        this.propsSubscription = undefined;\n    }\n    shouldRenderLoading(props = this.props, context = this.context) {\n        if (props.hasOwnProperty('renderLoading')) {\n            return props.renderLoading;\n        } else if (this.config.hasOwnProperty('renderLoading')) {\n            return this.config.renderLoading;\n        }\n        return context['renderFalcorLoading'] || false;\n    }\n    checkCacheAndUpdate(props, context) {\n\n        const { state, fragment } = this;\n        const { query } = state;\n\n        // if (props.hasOwnProperty('falcorData') || props.hasOwnProperty('falcorModel')) {\n        this.propsStream.next({\n            query, props, fragment, loading: true,\n            renderLoading: this.shouldRenderLoading(props, context),\n            data: props['falcorData'] || context['falcorData'] || state.data,\n            model: props['falcorModel'] || context['falcorModel'] || state.model,\n        });\n        // }\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n\n        const { props: currProps = {}, state: currState = {} } = this;\n\n        if (currState.loading !== nextState.loading && (\n            this.shouldRenderLoading(this.props, this.context) ||\n            this.shouldRenderLoading(nextProps, nextContext))) {\n            return true;\n        } else if (currState.version !== nextState.version) {\n            return true;\n        } else if (currState.error !== nextState.error) {\n            return true;\n        } else if (currState.hash !== nextState.hash) {\n            return true;\n        }\n\n        const currData = currProps['falcorData'];\n        const nextData = nextProps['falcorData'];\n        const { style: currStyle = {}, ...restCurrProps } = currProps;\n        const { style: nextStyle = currStyle, ...restNextProps } = nextProps;\n\n        if (!shallowEqual(currData, nextData)) {\n            return true;\n        } else if (!shallowEqual(currStyle, nextStyle)) {\n            return true;\n        } else if (!shallowEqual(restCurrProps, restNextProps)) {\n            return true;\n        }\n\n        return false;\n    }\n    render() {\n\n        const { props, state, config, Component } = this;\n\n        if (!Component) {\n            return null;\n        }\n\n        const { data, error, loading } = state;\n        const { mergeProps, mapFragment } = config;\n        const mappedFragment = data && mapFragment(data, props);\n        const mergedProps = mergeProps(mappedFragment || {}, props);\n\n        if (error) {\n            mergedProps.error = error;\n        }\n\n        if (loading && this.shouldRenderLoading(props) === true) {\n            mergedProps.loading = loading;\n        }\n\n        return <Component { ...mergedProps }/>;\n    }\n}\n"]}