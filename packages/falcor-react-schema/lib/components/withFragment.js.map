{"version":3,"sources":["../../src/components/withFragment.js"],"names":["withFragment","contextTypes","object","bool","fragmentDesc","fragment","mergeProps","defaultMergeProps","mapFragment","defaultMapFragment","Component","props","context","config","FragmentContainer","fragments","load","fetchEachPropUpdate","childContextTypes","displayName","state","propsStream","propsAction","switchMap","mergeEachPropUpdate","data","model","shouldRenderLoading","propsSubscription","subscribe","nextState","setState","checkCacheAndUpdate","nextProps","nextContext","undefined","unsubscribe","hasOwnProperty","renderLoading","query","next","loading","currProps","currState","version","error","hash","currData","nextData","style","currStyle","restCurrProps","nextStyle","restNextProps","mappedFragment","mergedProps","items","start","end","length","index","value","Math","min","max","tryDeref","_hasValidParentReference","deref","update","of","takeLast","$__hash","$__status","remoteProps","localProps"],"mappings":"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","file":"withFragment.js","sourcesContent":["import invariant from 'invariant';\nimport React, { PropTypes, Children } from 'react';\nimport hoistStatics from 'recompose/hoistStatics';\nimport shallowEqual from 'recompose/shallowEqual';\nimport wrapDisplayName from 'recompose/wrapDisplayName';\nimport fetchDataUntilSettled from '../fetchDataUntilSettled';\n\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/takeLast';\nimport 'rxjs/add/operator/switchMap';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\n\nconst contextTypes = {\n    'falcorData': PropTypes.object,\n    'falcorModel': PropTypes.object,\n    'renderFalcorLoading': PropTypes.bool\n};\n\nexport default function withFragment(fragmentDesc, ...rest) {\n\n    invariant(fragmentDesc && (\n              'function' === typeof fragmentDesc || (\n              'object'   === typeof fragmentDesc &&\n              'function' === typeof fragmentDesc.fragment)),\n`Attempted to create a Fragment container component without a fragment definition.\nFragment containers must be created with a fragment function, or an Object with a \"fragment\" function.`);\n\n    if ('object' !== typeof fragmentDesc) {\n        fragmentDesc = {\n            fragment: fragmentDesc,\n            mergeProps: rest[1] || defaultMergeProps,\n            mapFragment: rest[0] || defaultMapFragment\n        };\n    } else {\n        if (!fragmentDesc.mergeProps) {\n            fragmentDesc.mergeProps = defaultMergeProps;\n        }\n        if (!fragmentDesc.mapFragment) {\n            fragmentDesc.mapFragment = defaultMapFragment;\n        }\n    }\n\n    return hoistStatics((Component) => {\n        return class Container extends FragmentContainer {\n            static fragments = fragments;\n            static load = fetchEachPropUpdate;\n            static contextTypes = contextTypes;\n            static childContextTypes = contextTypes;\n            static fragment = fragmentDesc.fragment;\n            static displayName = wrapDisplayName(Component, 'Container');\n            constructor(props, context) {\n                super(props, context);\n                this.config = fragmentDesc;\n                this.Component = Component;\n                this.fragment = fragmentDesc.fragment;\n            }\n        };\n    });\n}\n\nclass FragmentContainer extends React.Component {\n    constructor(props, context) {\n        super(props, context);\n        this.state = {};\n        this.propsStream = new Subject();\n        this.propsAction = this.propsStream.switchMap(\n            fetchEachPropUpdate, mergeEachPropUpdate\n        );\n    }\n    getChildContext() {\n        const { data, model } = this.state;\n        return {\n            'falcorData': data, 'falcorModel': model,\n            'renderFalcorLoading': this.shouldRenderLoading()\n        };\n    }\n    componentWillMount() {\n        // Subscribe to child prop changes so we know when to re-render\n        this.propsSubscription = this.propsAction.subscribe((nextState) => {\n            this.setState(nextState);\n        });\n        this.checkCacheAndUpdate(this.props, this.context);\n    }\n    componentWillReceiveProps(nextProps, nextContext) {\n        this.checkCacheAndUpdate(nextProps, nextContext);\n    }\n    componentWillUnmount() {\n        this.config = undefined;\n        this.fragment = undefined;\n        this.Component = undefined;\n        this.propsAction = undefined;\n        this.propsStream = undefined;\n        // Clean-up subscription before un-mounting\n        this.propsSubscription.unsubscribe();\n        this.propsSubscription = undefined;\n    }\n    shouldRenderLoading(props = this.props, context = this.context) {\n        if (props.hasOwnProperty('renderLoading')) {\n            return props.renderLoading;\n        } else if (this.config.hasOwnProperty('renderLoading')) {\n            return this.config.renderLoading;\n        }\n        return context['renderFalcorLoading'] || false;\n    }\n    checkCacheAndUpdate(props, context) {\n\n        const { state, fragment } = this;\n        const { query } = state;\n\n        // if (props.hasOwnProperty('falcorData') || props.hasOwnProperty('falcorModel')) {\n        this.propsStream.next({\n            query, props, fragment, loading: true,\n            renderLoading: this.shouldRenderLoading(props, context),\n            data: props['falcorData'] || context['falcorData'] || state.data,\n            model: props['falcorModel'] || context['falcorModel'] || state.model,\n        });\n        // }\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n\n        const { props: currProps = {}, state: currState = {} } = this;\n\n        if (currState.loading !== nextState.loading && (\n            this.shouldRenderLoading(this.props, this.context) ||\n            this.shouldRenderLoading(nextProps, nextContext))) {\n            return true;\n        } else if (currState.version !== nextState.version) {\n            return true;\n        } else if (currState.error !== nextState.error) {\n            return true;\n        } else if (currState.hash !== nextState.hash) {\n            return true;\n        }\n\n        const currData = currProps['falcorData'];\n        const nextData = nextProps['falcorData'];\n        const { style: currStyle = {}, ...restCurrProps } = currProps;\n        const { style: nextStyle = currStyle, ...restNextProps } = nextProps;\n\n        if (!shallowEqual(currData, nextData)) {\n            return true;\n        } else if (!shallowEqual(currStyle, nextStyle)) {\n            return true;\n        } else if (!shallowEqual(restCurrProps, restNextProps)) {\n            return true;\n        }\n\n        return false;\n    }\n    render() {\n\n        const { props, state, config, Component } = this;\n\n        if (!Component) {\n            return null;\n        }\n\n        const { data, error, loading } = state;\n        const { mergeProps, mapFragment } = config;\n        const mappedFragment = data && mapFragment(data, props);\n        const mergedProps = mergeProps(mappedFragment || {}, props);\n\n        if (error) {\n            mergedProps.error = error;\n        }\n\n        if (loading && this.shouldRenderLoading(props) === true) {\n            mergedProps.loading = loading;\n        }\n\n        return <Component { ...mergedProps }/>;\n    }\n}\n\nfunction fragments(items = [], start = 0, end = items && items.length) {\n    if (!items || 'object' !== typeof items) {\n        return `{ length }`;\n    }\n    let index = -1, query = 'length', length = items.length;\n    if (length && typeof length === 'object' && typeof length.value === 'number') {\n        length = length.value;\n    }\n    length = Math.min(Math.max(0, end - start), length) | 0;\n    while (++index < length) {\n        query = `${\n        query},\n ${     index}: ${this.fragment(items[index])}`;\n    }\n    return `{ ${query} }`;\n}\n\nfunction tryDeref({ data, model }) {\n    return !data || !model ?\n        model :\n        model._hasValidParentReference() ?\n        model.deref(data) : null;\n}\n\nfunction fetchEachPropUpdate(update) {\n\n    invariant(\n        update.fragment || (update.fragment = this.fragment),\n        `Attempted to fetch without a fragment definition`\n    );\n\n    if (!(update.model = tryDeref(update))) {\n        return Observable.of(update);\n    } else if (update.renderLoading === true) {\n        return fetchDataUntilSettled(update);\n    }\n    return fetchDataUntilSettled(update).takeLast(1);\n}\n\nfunction mergeEachPropUpdate(\n    { props, model },\n    { data, query, error, version }\n) {\n    const hash = data && data.$__hash || '';\n    const loading = error === undefined && data &&\n                    data.$__status === 'pending' || false;\n    return {\n        hash, data, query, props,\n        model, error, loading, version\n    };\n}\n\nfunction defaultMapFragment(remoteProps) {\n    return remoteProps;\n}\n\nfunction defaultMergeProps(remoteProps, localProps) {\n    return { ...localProps, ...remoteProps };\n}\n"]}