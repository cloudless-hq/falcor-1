{"version":3,"sources":["../src/fetchDataUntilSettled.js"],"names":["fetchDataUntilSettled","memoizedQuerySyntax","data","query","props","model","version","fragment","renderLoading","memo","mapNext","handleNext","catchError","handleError","$__status","Observable","of","fetchData","expand","nextQuery","error","undefined","empty","e","ast","console","getVersion","from","get","progressively","map","catch","json"],"mappings":"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","file":"fetchDataUntilSettled.js","sourcesContent":["import { errorMessage } from 'pegjs-util';\nimport memoizeQueryies from './memoizeQueryies';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/expand';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/empty';\nimport 'rxjs/add/observable/empty';\n\nconst memoizedQuerySyntax = memoizeQueryies(100);\n\nexport default function fetchDataUntilSettled({\n    data, query, props, model, version, fragment, renderLoading\n}) {\n\n    const memo = {\n        data, query, props, model,\n        version, fragment, renderLoading\n    };\n\n    memo.mapNext = handleNext(memo, model);\n    memo.catchError = handleError(memo, model);\n\n    return (data && data.$__status !== 'pending' ?\n        Observable.of(memo) : fetchData(memo)).expand(fetchData);\n}\n\nfunction fetchData(memo) {\n\n    let nextQuery;\n    let { data, props, query, model, fragment } = memo;\n\n    if (memo.error !== undefined) {\n        return Observable.empty();\n    }\n    if (data && data.$__status === 'pending') {\n        return Observable.empty();\n    }\n\n    try {\n        nextQuery = fragment(data, props);\n    } catch (e) {\n        return memo.catchError(e);\n    }\n\n    if (query === (memo.query = nextQuery)) {\n        return Observable.empty();\n    }\n\n    const { ast, error } = memoizedQuerySyntax(memo.query);\n\n    if (error) {\n        if (typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error(errorMessage(error));\n            console.error(`Error parsing query: ${memo.query}`);\n        }\n        memo.error = error;\n        memo.version = model.getVersion();\n        return Observable.of(memo);\n    }\n\n    return Observable\n        .from(!memo.renderLoading ?\n            model.get(ast) :\n            model.get(ast).progressively()\n        ).map(memo.mapNext).catch(memo.catchError);\n}\n\nfunction handleNext(memo, model) {\n    return function mapNext({ json: data }) {\n        memo.data = data;\n        memo.version = model.getVersion();\n        return memo;\n    }\n}\n\nfunction handleError(memo, model) {\n    return function catchError(error) {\n        memo.error = error;\n        memo.version = model.getVersion();\n        return Observable.of(memo);\n    };\n}\n"]}