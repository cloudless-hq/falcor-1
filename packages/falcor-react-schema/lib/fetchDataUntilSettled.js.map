{"version":3,"sources":["../src/fetchDataUntilSettled.js"],"names":["fetchDataUntilSettled","memoizedQuerySyntax","data","query","props","model","version","fragment","renderLoading","memo","mapNext","handleNext","catchError","handleError","$__status","of","fetchData","expand","error","undefined","empty","ast","console","getVersion","from","get","progressively","map","catch","json"],"mappings":"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","file":"fetchDataUntilSettled.js","sourcesContent":["import { errorMessage } from 'pegjs-util';\nimport memoizeQueryies from './memoizeQueryies';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/expand';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/empty';\nimport 'rxjs/add/observable/empty';\n\nconst memoizedQuerySyntax = memoizeQueryies(100);\n\nexport default function fetchDataUntilSettled({\n    data, query, props, model, version, fragment, renderLoading\n}) {\n\n    const memo = {\n        data, query, props, model,\n        version, fragment, renderLoading\n    };\n\n    memo.mapNext = handleNext(memo, model);\n    memo.catchError = handleError(memo, model);\n\n    return (data && data.$__status !== 'pending' ?\n        Observable.of(memo) : fetchData(memo)).expand(fetchData);\n}\n\nfunction fetchData(memo) {\n\n    let { data, props, query, model, fragment } = memo;\n\n    if (memo.error !== undefined || (\n        data && data.$__status === 'pending') || (\n        query === (memo.query = fragment(data, props)))) {\n        return Observable.empty();\n    }\n\n    const { ast, error } = memoizedQuerySyntax(memo.query);\n\n    if (error) {\n        if (typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error(errorMessage(error));\n            console.error(`Error parsing query: ${memo.query}`);\n        }\n        memo.error = error;\n        memo.version = model.getVersion();\n        return Observable.of(memo);\n    }\n\n    return Observable\n        .from(!memo.renderLoading ?\n            model.get(ast) :\n            model.get(ast).progressively()\n        ).map(memo.mapNext).catch(memo.catchError);\n}\n\nfunction handleNext(memo, model) {\n    return function mapNext({ json: data }) {\n        memo.data = data;\n        memo.version = model.getVersion();\n        return memo;\n    }\n}\n\nfunction handleError(memo, model) {\n    return function catchError(error) {\n        memo.error = error;\n        memo.version = model.getVersion();\n        return Observable.of(memo);\n    };\n}\n\n/*\nfunction _fetchDataUntilSettled(memo) {\n    if (memo.loading === false) {\n        return Observable.empty();\n    }\n    const { query, model, fragment } = memo;\n    if (query !== (memo.query = fragment(memo.data || {}, memo.props))) {\n        const { ast, error } = memoizedQuerySyntax(memo.query);\n        if (error) {\n            if (typeof console !== 'undefined' && typeof console.error === 'function') {\n                console.error(errorMessage(error));\n                console.error(`Error parsing query: ${memo.query}`);\n            }\n            memo.error = error;\n            memo.version = model.getVersion();\n        } else {\n            return Observable\n                .from(model.get(ast).progressively())\n                .map(memo.mapNext).catch(memo.catchError);\n        }\n    }\n    memo.loading = false;\n    return Observable.of(memo);\n}\n\nfunction handleNext(memo, model) {\n    return function mapNext({ json: data }) {\n        memo.data = data;\n        memo.loading = true;\n        memo.version = model.getVersion();\n        return memo;\n    }\n}\n\nfunction handleError(memo, model) {\n    return function catchError(error) {\n        memo.error = error;\n        memo.loading = false;\n        memo.version = model.getVersion();\n        return Observable.of(memo);\n    };\n}\n*/\n\n/*\nimport { errorMessage } from 'pegjs-util';\nimport memoizeQueryies from './memoizeQueryies';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/concat';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/defer';\nimport 'rxjs/add/observable/empty';\n\nconst memoizedQuerySyntax = memoizeQueryies(100);\n\nexport default function fetchDataUntilSettled(state) {\n    return Observable\n        .of(state)\n        .lift(new ExpandFetchOperator(state));\n}\n\nclass ExpandFetchOperator {\n    constructor({ data, query, props, model, version, fragment, renderLoading }) {\n        this.data = data;\n        this.query = query;\n        this.props = props;\n        this.model = model;\n        this.version = version;\n        this.fragment = fragment;\n        this.renderLoading = renderLoading;\n    }\n    call(destination, source) {\n        return source._subscribe(new ExpandFetchSubscriber(\n            destination,\n            this.data, this.query, this.props, this.model,\n            this.version, this.fragment, this.renderLoading\n        ));\n    }\n}\n\nclass ExpandFetchSubscriber extends Subscriber {\n    constructor(destination, data, query, props, model, version, fragment, renderLoading) {\n        super(destination);\n        this.data = data;\n        this.query = query;\n        this.props = props;\n        this.model = model;\n        this.version = version;\n        this.fragment = fragment;\n        this.renderLoading = renderLoading;\n    }\n    _next() {\n\n    }\n}\n\n\nclass ExpansionState {\n\n    constructor({ data, query, props, model, version, fragment, renderLoading }) {\n        this.data = data;\n        this.query = query;\n        this.props = props;\n        this.model = model;\n        this.loading = false;\n        this.error = undefined;\n        this.version = version;\n        this.fragment = fragment;\n        this.renderLoading = renderLoading;\n        this.mapNext = this.mapNext.bind(this);\n        this.catchError = this.catchError.bind(this);\n        this.fetchExpansive = this.fetchExpansive.bind(this);\n    }\n\n    mapNext({ json: data }) {\n        this.data = data;\n        this.version = this.model.getVersion();\n        return this;\n    }\n\n    catchError(error) {\n        this.error = error;\n        this.loading = false;\n        this.version = this.model.getVersion();\n        return Observable.of(this);\n    }\n\n    isLoading() {\n        let loading = false;\n        let { data, props, query, model, fragment } = this;\n        loading = (!data || data.$__status === 'pending') || loading;\n        loading = (query !== (this.query = fragment(data, props))) || loading;\n        if (this.error !== undefined) {\n            loading = false;\n        }\n        return this.loading = loading;\n    }\n\n    fetchExpansive() {\n\n        if (!this.isLoading()) {\n            return Observable.empty();\n        }\n\n        const { query, model, renderLoading } = this;\n        const { ast, error } = memoizedQuerySyntax(query);\n\n        if (error) {\n            if (typeof console !== 'undefined' && typeof console.error === 'function') {\n                console.error(errorMessage(error));\n                console.error(`Error parsing query: ${query}`);\n            }\n            this.error = error;\n            this.version = model.getVersion();\n            return Observable.of(this);\n        }\n\n        return Observable\n            .from(!renderLoading ?\n                model.get(ast) :\n                model.get(ast).progressively()\n            )\n            .map(this.mapNext)\n            .catch(this.catchError)\n            .concat(Observable.defer(this.fetchExpansive));\n    }\n}\n*/\n"]}