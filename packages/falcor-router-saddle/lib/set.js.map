{"version":3,"sources":["../src/set.js"],"names":["set","typeofNumber","typeofObject","typeofFunction","isArray","Array","slice","prototype","defaultPropsResolver","routerInstance","request","query","defaultValueMapper","node","key","value","path","context","of","defaultLoader","requestedIds","empty","options","lists","loader","getInitialProps","setHandler","incomingJSON","getListIds","values","defer","mergeMap","expandAndMapValues","depth","json","$type","length","list","byId","keyIdx","keys","valueKeys","innerExpandValues","type","index","count","pathLen","listId","valsId","id","from","expandValues","mapEachValue","expansionState","mergeMapArray","nextExpansionState","hasOwnProperty","mapValue","unboxRefs","unboxAtoms","unboxErrors","unboxTypes","ref","atom","error","innerMapJSONValues","call","subscribe","xs","fn","ix","push","apply"],"mappings":"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","file":"set.js","sourcesContent":["const typeofNumber = 'number';\nconst typeofObject = 'object';\nconst typeofFunction = 'function';\nconst isArray = Array.isArray;\nconst slice = Array.prototype.slice;\n\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/defer';\nimport 'rxjs/add/observable/empty';\n\nfunction defaultPropsResolver(routerInstance) {\n    const { request  = {} } = routerInstance;\n    const { query = {} } = request;\n    return query;\n}\n\nfunction defaultValueMapper(node, key, value, path, context) {\n    return Observable.of({ path, value: node[key] = value });\n}\n\nfunction defaultLoader(requestedIds) {\n    return Observable.empty();\n}\n\nexport function set(options = {}) {\n\n    const lists = options.lists || [];\n    const loader = options.loader || defaultLoader;\n    const getInitialProps = options.getInitialProps || defaultPropsResolver;\n\n    return function setHandler(incomingJSON) {\n\n        const context = getListIds(\n            { ...getInitialProps(this) }, lists, 0, incomingJSON);\n\n        const values = Observable\n            .defer(() => loader(context))\n            .mergeMap(expandAndMapValues(incomingJSON, options));\n\n        return values;\n    }\n}\n\nfunction getListIds(context, lists, depth, json) {\n\n    if (!json || json.$type ||\n        depth === lists.length ||\n        typeofObject !== typeof json) {\n        return context;\n    } else {\n\n        const list = `${lists[depth]}Ids`;\n        const byId = `${lists[depth]}sById`;\n        const node = json[byId];\n\n        let keyIdx = -1;\n        const keys = context[list] || (context[list] = []);\n\n        for (const key in node) {\n            getListIds(context, lists, depth + 1, node[keys[++keyIdx] = key]);\n        }\n    }\n\n    return context;\n}\n\nfunction expandAndMapValues(incomingJSON, options = {}) {\n\n    const lists = options.lists || [];\n    const { valueKeys = {} } = options;\n\n    return function innerExpandValues(context) {\n\n        const path = [];\n\n        let json = incomingJSON, key, type,\n            index = -1, count = lists.length,\n            pathLen = 0, listId = -1, valsId = -1,\n            node = context[lists[count - 1]] || context;\n\n        while (++index < count) {\n            key = lists[index];\n            listId = path[pathLen++] = `${key}sById`;\n            valsId = path[pathLen++] = context[key].id;\n            json = json[listId][valsId];\n        }\n\n        return Observable\n            .from(expandValues(json, pathLen, { path }, valueKeys))\n            .mergeMap(mapEachValue(context, options));\n    }\n}\n\nfunction expandValues(json, index, expansionState, valueKeys = {}) {\n\n    if (!json || typeofObject !== typeof json || json.$type) {\n        return [expansionState];\n    }\n\n    const length = index + 1;\n    const { path } = expansionState;\n\n    return mergeMapArray(Object.keys(json), (key) => {\n        const nextExpansionState = {\n            value: json[key],\n            path: { ...path, [index]: key, length }\n        };\n        if (valueKeys.hasOwnProperty(key)) {\n            return [nextExpansionState];\n        }\n        return expandValues(json[key], length,\n                            nextExpansionState, valueKeys);\n    });\n}\n\nfunction mapEachValue(context, options) {\n\n    const lists = options.lists || [];\n    const mapValue = options.mapValue || defaultValueMapper;\n    const { unboxRefs = false, unboxAtoms = true, unboxErrors = true } = options;\n    const unboxTypes = { ref: unboxRefs, atom: unboxAtoms, error: unboxErrors };\n\n    return function innerMapJSONValues({ path, value }) {\n\n        path = slice.call(path);\n\n        const count = path.length;\n        let index = lists.length * 2;\n\n        while (++index < count) {\n\n            const key = path[index];\n\n            if (index < count - 1) {\n                node = node[key] || (node[key] = {});\n                continue;\n            }\n\n            if (!(!value || typeofObject !== typeof value)) {\n                value = unboxTypes[value.$type] ? value.value : value;\n            }\n\n            value = mapValue(node, key, value, path, context);\n        }\n\n        if (!value || typeof value !== typeofObject) {\n            value = [{ path, value }];\n        } else if (!isArray(value) && typeofFunction !== typeof value.subscribe) {\n            if (!value.path) {\n                value = { path, value };\n            }\n            value = [value];\n        }\n        return value;\n    }\n}\n\nfunction mergeMapArray(xs, fn) {\n    let ix = -1;\n    const list = [];\n    const { length } = xs;\n    while (++ix < length) {\n        list.push.apply(list, fn(xs[ix]));\n    }\n    return list;\n}\n"]}