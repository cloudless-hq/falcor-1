{"version":3,"sources":["../src/set.js"],"names":["set","typeofNumber","typeofObject","typeofFunction","isArray","Array","slice","prototype","defaultPropsResolver","routerInstance","request","query","defaultValueMapper","node","key","value","path","context","Observable","of","defaultLoader","requestedIds","empty","options","lists","loader","getInitialProps","setHandler","incomingJSON","getListIds","values","defer","mergeMap","expandAndMapValues","depth","json","$type","length","list","byId","keyIdx","keys","valueKeys","innerExpandValues","type","index","count","pathLen","listId","valsId","id","from","expandValues","mapEachValue","expansionState","mergeMapArray","nextExpansionState","hasOwnProperty","mapValue","unboxRefs","unboxAtoms","unboxErrors","unboxTypes","ref","atom","error","innerMapJSONValues","call","subscribe","xs","fn","ix","push","apply"],"mappings":"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","file":"set.js","sourcesContent":["const typeofNumber = 'number';\nconst typeofObject = 'object';\nconst typeofFunction = 'function';\nconst isArray = Array.isArray;\nconst slice = Array.prototype.slice;\n\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/defer';\nimport 'rxjs/add/observable/empty';\n\nfunction defaultPropsResolver(routerInstance) {\n    const { request  = {} } = routerInstance;\n    const { query = {} } = request;\n    return query;\n}\n\nfunction defaultValueMapper(node, key, value, path, context) {\n    return Observable.of({ path, value: node[key] = value });\n}\n\nfunction defaultLoader(requestedIds) {\n    return Observable.empty();\n}\n\nexport function set(options = {}) {\n\n    const lists = options.lists || [];\n    const loader = options.loader || defaultLoader;\n    const getInitialProps = options.getInitialProps || defaultPropsResolver;\n\n    return function setHandler(incomingJSON) {\n\n        const context = getListIds(\n            { ...getInitialProps(this) }, lists, 0, incomingJSON);\n\n        const values = Observable\n            .defer(() => loader(context))\n            .mergeMap(expandAndMapValues(incomingJSON, options));\n\n        return values;\n    }\n}\n\nfunction getListIds(context, lists, depth, json) {\n\n    if (!json || json.$type ||\n        depth === lists.length ||\n        typeofObject !== typeof json) {\n        return context;\n    } else {\n\n        const list = `${lists[depth]}Ids`;\n        const byId = `${lists[depth]}sById`;\n        const node = json[byId];\n\n        let keyIdx = -1;\n        const keys = context[list] || (context[list] = []);\n\n        for (const key in node) {\n            getListIds(context, lists, depth + 1, node[keys[++keyIdx] = key]);\n        }\n    }\n\n    return context;\n}\n\nfunction expandAndMapValues(incomingJSON, options = {}) {\n\n    const lists = options.lists || [];\n    const { valueKeys = {} } = options;\n\n    return function innerExpandValues(context) {\n\n        const path = [];\n\n        let json = incomingJSON, key, type,\n            index = -1, count = lists.length,\n            pathLen = 0, listId = -1, valsId = -1;\n\n        while (++index < count) {\n            key = lists[index];\n            listId = path[pathLen++] = `${key}sById`;\n            valsId = path[pathLen++] = context[key].id;\n            json = json[listId][valsId];\n        }\n\n        return Observable\n            .from(expandValues(json, pathLen, { path }, valueKeys))\n            .mergeMap(mapEachValue(context, options));\n    }\n}\n\nfunction expandValues(json, index, expansionState, valueKeys = {}) {\n\n    if (!json || typeofObject !== typeof json || json.$type) {\n        return [expansionState];\n    }\n\n    const length = index + 1;\n    const { path } = expansionState;\n\n    return mergeMapArray(Object.keys(json), (key) => {\n        const nextExpansionState = {\n            value: json[key],\n            path: { ...path, [index]: key, length }\n        };\n        if (valueKeys.hasOwnProperty(key)) {\n            return [nextExpansionState];\n        }\n        return expandValues(json[key], length,\n                            nextExpansionState, valueKeys);\n    });\n}\n\nfunction mapEachValue(context, options) {\n\n    const lists = options.lists || [];\n    const mapValue = options.mapValue || defaultValueMapper;\n    const { unboxRefs = false, unboxAtoms = true, unboxErrors = true } = options;\n    const unboxTypes = { ref: unboxRefs, atom: unboxAtoms, error: unboxErrors };\n\n    return function innerMapJSONValues({ path, value }) {\n\n        path = slice.call(path);\n\n        const count = path.length;\n        let key, index = lists.length * 2;\n        let node = context[lists[lists.length - 1]] || context;\n\n        do {\n\n            key = path[index];\n\n            if (index < count - 1) {\n                node = node[key] || (node[key] = {});\n                continue;\n            }\n\n            if (!(!value || typeofObject !== typeof value)) {\n                value = unboxTypes[value.$type] ? value.value : value;\n            }\n\n            value = mapValue(node, key, value, path, context);\n        } while (++index < count);\n\n        if (!value || typeof value !== typeofObject) {\n            value = [{ path, value }];\n        } else if (!isArray(value) && typeofFunction !== typeof value.subscribe) {\n            if (!value.path) {\n                value = { path, value };\n            }\n            value = [value];\n        }\n        return value;\n    }\n}\n\nfunction mergeMapArray(xs, fn) {\n    let ix = -1;\n    const list = [];\n    const { length } = xs;\n    while (++ix < length) {\n        list.push.apply(list, fn(xs[ix]));\n    }\n    return list;\n}\n"]}