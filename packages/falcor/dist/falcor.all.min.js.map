{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///falcor.all.min.js","webpack:///webpack/bootstrap af7425e96c02772a101c","webpack:///./lib/cache/isExpired.js","webpack:///./lib/cache/expireNode.js","webpack:///./lib/cache/get/json/FalcorJSON.js","webpack:///./lib/errors/NullInPathError.js","webpack:///./lib/errors/createErrorClass.js","webpack:///./lib/support/isObject.js","webpack:///.-path-utils/lib/support/materializedAtom.js","webpack:///./lib/cache/clone.js","webpack:///./lib/cache/createHardlink.js","webpack:///./lib/support/getSize.js","webpack:///./lib/cache/getCachePosition.js","webpack:///./lib/cache/updateNodeAncestors.js","webpack:///./lib/errors/InvalidKeySetError.js","webpack:///./lib/lru/promote.js","webpack:///./lib/request/Subscriber.js","webpack:///./lib/request/Subscription.js","webpack:///./lib/cache/get/onValueType.js","webpack:///./lib/cache/getBoundCacheNode.js","webpack:///./lib/cache/removeNodeAndDescendants.js","webpack:///./lib/cache/set/setJSONGraphs.js","webpack:///./lib/cache/set/setPathMaps.js","webpack:///./lib/support/isInternalKey.js","webpack:///.-path-utils/lib/flatBufferToPaths.js","webpack:///.-path-utils/lib/getHashCode.js","webpack:///.-path-utils/lib/iterateKeySet.js","webpack:///./lib/cache/get/json/index.js","webpack:///./lib/cache/get/jsonGraph/index.js","webpack:///./lib/cache/get/jsonGraph/inlineValue.js","webpack:///./lib/cache/get/onMissing.js","webpack:///./lib/cache/invalidate/invalidatePathSets.js","webpack:///./lib/cache/removeNode.js","webpack:///./lib/cache/set/setPathValues.js","webpack:///./lib/internal/isInternal.js","webpack:///./lib/values/expires-now.js","webpack:///(webpack)/buildin/global.js","webpack:///.-path-utils/lib/collapse.js","webpack:///.-path-utils/lib/toCollapseMap.js","webpack:///.-path-utils/lib/toCollapseTrees.js","webpack:///.-path-utils/lib/toPaths.js","webpack:///./lib/cache/get/json/getJSON.js","webpack:///./lib/cache/get/json/getReferenceTarget.js","webpack:///./lib/cache/get/json/onValue.js","webpack:///./lib/cache/get/jsonGraph/getJSONGraph.js","webpack:///./lib/cache/get/onMaterialize.js","webpack:///./lib/cache/groupCacheArguments.js","webpack:///./lib/cache/insertNode.js","webpack:///./lib/cache/invalidate/invalidatePathMaps.js","webpack:///./lib/cache/mergeValueOrInsertBranch.js","webpack:///./lib/cache/reconstructPath.js","webpack:///./lib/cache/replaceNode.js","webpack:///./lib/cache/updateBackReferenceVersions.js","webpack:///./lib/cache/wrapNode.js","webpack:///./lib/errors/CircularReferenceError.js","webpack:///./lib/errors/InvalidSourceError.js","webpack:///./lib/lru/collect.js","webpack:///./lib/lru/splice.js","webpack:///./lib/request/Source.js","webpack:///./lib/schedulers/ImmediateScheduler.js","webpack:///./lib/support/getTimestamp.js","webpack:///./lib/support/isJSONEnvelope.js","webpack:///./lib/support/isJSONGraphEnvelope.js","webpack:///./lib/support/now.js","webpack:///./lib/values/expires-never.js","webpack:///./lib/index.js","webpack:///.-path-utils/lib/computeFlatBufferHash.js","webpack:///.-path-utils/lib/hasIntersection.js","webpack:///.-path-utils/lib/toFlatBuffer.js","webpack:///.-path-utils/lib/toTree.js","webpack:///./lib/Model.js","webpack:///./lib/ModelDataSourceAdapter.js","webpack:///./lib/ModelRoot.js","webpack:///./lib/cache/call/index.js","webpack:///./lib/cache/get/index.js","webpack:///./lib/cache/get/json/onError.js","webpack:///./lib/cache/get/json/walkFlatBuffer.js","webpack:///./lib/cache/get/json/walkPath.js","webpack:///./lib/cache/get/jsonGraph/getReferenceTarget.js","webpack:///./lib/cache/get/jsonGraph/onValue.js","webpack:///./lib/cache/get/jsonGraph/walkPath.js","webpack:///./lib/cache/get/onMaterializeFlatBuffer.js","webpack:///./lib/cache/getCache.js","webpack:///./lib/cache/getVersion.js","webpack:///./lib/cache/invalidate/index.js","webpack:///./lib/cache/mergeJSONGraphNode.js","webpack:///./lib/cache/set/index.js","webpack:///./lib/cache/transferBackReferences.js","webpack:///./lib/cache/unlinkBackReferences.js","webpack:///./lib/cache/unlinkForwardReference.js","webpack:///./lib/deref/hasValidParentReference.js","webpack:///./lib/deref/index.js","webpack:///./lib/errors/BoundJSONGraphModelError.js","webpack:///./lib/errors/InvalidDerefInputError.js","webpack:///./lib/errors/InvalidModelError.js","webpack:///./lib/errors/MaxRetryExceededError.js","webpack:///./lib/internal/f_.js","webpack:///./lib/request/Call.js","webpack:///./lib/request/Queue.js","webpack:///./lib/request/Request.js","webpack:///./lib/request/Subject.js","webpack:///./lib/schedulers/TimeoutScheduler.js","webpack:///./lib/support/array-flat-map.js","webpack:///./lib/support/clone.js","webpack:///./lib/support/getExpires.js","webpack:///./lib/support/getType.js","webpack:///./lib/support/isPathValue.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/lib/index.js","webpack:///./~/symbol-observable/lib/ponyfill.js","webpack:///(webpack)/buildin/module.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","o","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","now","$now","$never","module.exports","node","expireImmediate","exp","undefined","splice","expired","lru","global","FalcorJSON","f_meta","bindArrayMethod","fn","bound","arguments","getInst","inst","typeofInst","argsLen","typeofString","typeofObject","toJSON","serialize","toProps","f_meta_inst","f_meta_json","version","json","serializer","includeMetadata","createWithProto","count","total","keys","key","xs","isArray","$code","abs_path","deref_to","deref_from","ys","reduce","descriptors","writable","Array","toString","JSON","$__hash","$__path","$__version","createErrorClass","message","MESSAGE","init","E","Error","constructor","stack","E.is","x","objTypeof","$type","isInternal","clone","index","length","from","to","backRefs","isObject","getCachePosition","cache","path","type","depth","maxDepth","removeNode","updateBackReferenceVersions","nodeArg","offset","child","keysOrRanges","mesage","EXPIRES_NEVER","head","prev","next","Subscriber","destination","parent","onCompleted","Subscription","error","onError","onNext","complete","Subscriber.prototype.onNext","dest","Subscriber.prototype.onError","signaled","dispose","Subscriber.prototype.onCompleted","Subscriber.prototype.unsubscribe","subscriptions","Subscription.prototype.add","subscription","push","Subscription.prototype.remove","indexOf","Subscription.prototype.unsubscribe","isExpired","expireNode","lruPromote","onValueType","seed","results","requestedPath","requestedLength","optimizedPath","optimizedLength","fromReference","modelRoot","branchSelector","boxValues","materialized","reportMissing","treatErrorsAsValues","onValue","onMissing","onMaterialize","reportMaterialized","getBoundCacheNode","model","isInternalKey","removeNodeAndDescendants","key2","setJSONGraphPathSet","messageRoot","messageParent","requestedPaths","optimizedPaths","comparator","errorSelector","note","branch","keySet","iterateKeySet","optimizedIndex","setNode","nextNode","nextParent","nextOptimizedPath","reference","container","createHardlink","arr","NullInPathError","mergeJSONGraphNode","jsonGraphEnvelopes","initialVersion","jsonGraphEnvelopeIndex","jsonGraphEnvelopeCount","jsonGraphEnvelope","paths","jsonGraph","pathIndex","pathCount","newVersion","rootChangeHandler","setPathMap","pathMap","itr","keyIndex","keyCount","mergeValueOrInsertBranch","pathMapEnvelopes","pathMapIndex","pathMapCount","pathMapEnvelope","flatBufferToPaths","leaf","keysLen","keysIndex","keyset","getHashCode","str","hash","initializeRange","memo","nextValue","el","inlineJSONGraphValue","curr","restPathIndex","restPath","restPathCount","isEmptyKeySet","rangeEnd","mPath","lastKeyIsNull","isRequestedPath","missingPaths","missTotal","missingPath","missDepth","Number","invalidatePathSet","invalidateNode","updateNodeAncestors","getSize","lruSplice","unlinkBackReferences","unlinkForwardReference","setPathSet","pathValues","pathValueIndex","pathValueCount","pathValue","f_","regexp","RegExp","g","Function","eval","e","window","toPaths","toCollapseMap","toCollapseTrees","collapseMap","acc","len","toTree","collapseTrees","collapseKey","collapsePathMap","pathmap","subs","code","codes","codesIndex","codesCount","pathsets","pathsetsCount","subPath","subCode","subKeys","subKeysIndex","subKeysCount","pathsetClone","getSortedKeys","isSafeNumber","sets","parseInt","subSets","firstSubKey","subSetsIndex","subSetsCount","pathset","pathsetIndex","pathsetCount","sortListAscending","a","b","map","sort","materializedAtom","val","num","typeOfString","MIN_SAFE_INTEGER_DIGITS","safeNumberRegEx","MAX_SAFE_INTEGER_DIGITS","typeOfNumber","MAX_SAFE_INTEGER","abs","Math","lengths","allPaths","allPathsLength","typeOfObject","pathsIndex","pathsCount","keysetIndex","keysetCount","isSparseRange","collapseIndex","walkPathAndBuildOutput","walkFlatBufferAndBuildOutput","InvalidModelError","toFlatBuffer","computeFlatBufferHash","getJSON","progressive","referenceContainer","boundPath","isFlatBuffer","data","recycleJSON","hasDataSource","Boolean","allowFromWhenceYouCame","requested","boundRequested","promote","CircularReferenceError","getReferenceTarget","ref","context","copy","onJSONValue","BoundJSONGraphModelError","getJSONGraph","nextDepth","keysetLength","iteratingKeyset","nextKey","keyIsRange","InvalidKeySetError","typeofNumber","isPathValue","isJSONEnvelope","isJSONGraphEnvelope","groupCacheArguments","args","groups","argIndex","argCount","group","groupType","arg","argType","inputType","invalidatePathMap","getType","getTimestamp","wrapNode","insertNode","replaceNode","reconstructPath","mType","isDistinct","sizeOffset","currentPath","transferBackReferences","replacement","getExpires","expiresNow","typeArg","size","modelCreated","atomSize","expires","referencePath","totalArg","max","ratioArg","ratio","shouldUpdate","targetSize","Source","subscribe","source","$$observable","default","Source.prototype.operator","Source.prototype.subscribe","y","operator","Source.prototype.then","_promise","resolve","reject","values","rejected","errors","then","ImmediateScheduler","empty","unsubscribe","ImmediateScheduler.prototype.schedule","action","envelope","Date","falcor","opts","Model","keysLength","hasIntersection","tree","pathToFlatBuffer","keysMap","nullBuffer","pathToTree","options","_node","_path","_source","_root","ModelRoot","_recycleJSON","_scheduler","_seed","_treatErrorsAsValues","__proto__","_boxed","_materialized","_allowFromWhenceYouCame","setCache","Call","ModelDataSourceAdapter","TimeoutScheduler","collapse","lruCollect","setJSONGraphs","getCache","Model.prototype.get","_len","_key","_toJSON","Model.prototype.set","_len2","_key2","Model.prototype.preload","_len3","_key3","Model.prototype.call","_len4","_key4","Model.prototype.invalidate","_len5","_key5","Model.prototype.getValue","lift","subscriber","Model.prototype.setValue","Model.prototype.setCache","cacheOrJSONGraphEnvelope","Model.prototype.getCache","env","Model.prototype.getVersion","concat","_getVersion","Model.prototype._clone","Model.prototype.batch","schedulerOrDelay","scheduler","scheudle","_clone","Model.prototype.unbatch","Model.prototype.treatErrorsAsValues","Model.prototype.asDataSource","Model.prototype._materialize","Model.prototype._dematerialize","Model.prototype.boxValues","Model.prototype.unboxValues","Model.prototype.withoutDataSource","Model.prototype.toJSON","getPath","Model.prototype.getPath","slice","Model.prototype._fromWhenceYouCame","allow","Model.prototype._optimizePath","_model","ModelDataSourceAdapter.prototype.get","pathSets","apply","_toJSONG","ModelDataSourceAdapter.prototype.set","jsongResponse","set","ModelDataSourceAdapter.prototype.call","suffixes","syncRefCount","maxRetryCount","topLevelModel","requests","Requests","collectRatio","maxSize","functionTypeof","onChange","onChangesCompleted","ModelRoot.comparator","cacheNode","messageNode","cType","_args","hasValue","missing","thisPaths","fragments","errorPath","errorValue","refTarget","f_old_keys","f_new_keys","f_code","nextJSON","nextReferenceContainer","nextOptimizedLength","optimizedLengthNext","refContainerAbsPath","refContainerRefPath","nodeAbsPath","jsonAbsPath","nextPath","nextPathKey","hasMissingPath","tmp","rPath","originalOnMissing","inlineValue","onJSONGraphValue","isLeaf","onMaterializeFlatBuffer","_copyCache","out","fromKey","cacheNext","outNext","isUserCreatedcacheNext","clonedValue","boxedValue","invalidate","groupIndex","groupCount","groupedArgs","pluckPaths","invalidatePathMaps","invalidatePathValues","cIsObject","mIsObject","cTimestamp","mTimestamp","setGroupsIntoCache","changed","selector","operation","arrayFlatMap","optimized","relative","jsong","setPathMaps","setPathValues","fromNode","destNode","fromNodeRefsLength","destNodeRefsLength","hasValidParentReference","_referenceContainer","cacheRoot","absolutePath","originalRefPath","originalAbsPath","validContainer","CONTAINER_DOES_NOT_EXIST","currentRefPath","shortedPath","printPaths","absolute","String","CallOperator","CallSubscriber","retryCount","completed","tryOnNext","tryOnError","self","err","mergeInto","destValue","nodeValue","InvalidSourceError","MaxRetryExceededError","Call.prototype.lift","Call.prototype.operator","_subscribe","Call.prototype._subscribe","Call.prototype._toJSON","Call.prototype._toJSONG","Call.prototype.retry","progresive","Call.prototype.progressively","CallOperator.prototype.call","CallSubscriber.prototype.onNext","started","seedIsImmutable","operations","CallSubscriber.prototype.onError","errored","CallSubscriber.prototype.onCompleted","request","CallSubscriber.prototype.unsubscribe","rootOnChangesCompletedHandler","Queue","Dedupe","queue","dataSource","Request","isolateSet","isolateCall","callArgs","batchAndDedupeGet","Dedupe.prototype.subscribe","requestsIndex","requestsCount","batch","Subject","responded","active","disposable","flush","obs","filterPathsBoundTo","boundLength","filtered","filteredIndex","outer","invalidatePaths","Request.prototype.onNext","envelopes","envelopeIndex","envelopeCount","invalidated","observers","forEach","observer","Request.prototype.onError","errorPathValues","Request.prototype.onCompleted","Request.prototype.remove","Request.prototype.unsubscribe","Request.prototype.connect","scheduledDisposable","schedule","Request.prototype.batch","requestedComplements","optimizedComplements","requestedIntersection","optimizedIntersection","complementIndex","intersectionIndex","optTotal","reqTotal","pathLen","subTree","Subject.prototype.onError","Subject.prototype.onCompleted","Subject.prototype.subscribe","Subject.prototype.unsubscribe","delay","TimerDisposable","id","disposed","TimeoutScheduler.prototype.schedule","setTimeout","TimerDisposable.prototype.unsubscribe","clearTimeout","array","array2","array3","j","k","anyType","_ponyfill","_ponyfill2","result","symbolObservablePonyfill","_Symbol","Symbol","observable","webpackPolyfill","deprecate","module.deprecate","children"],"mappings":"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","file":"falcor.all.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 109);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(61);\nvar $now = __webpack_require__(33);\nvar $never = __webpack_require__(62);\n\nmodule.exports = function isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar splice = __webpack_require__(55);\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[\"\u001eƒ_invalidated\"]) {\n        node[\"\u001eƒ_invalidated\"] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {function FalcorJSON(f_meta) {\n    if (!f_meta) {\n        this[\"\u001eƒ_meta\"] = {};\n    } else if (!(this[\"\u001eƒ_meta\"] = f_meta[\"\u001eƒ_meta\"])) {\n        this[\"\u001eƒ_meta\"] = f_meta;\n    }\n}\n\nObject.defineProperties(FalcorJSON.prototype, ['concat', 'copyWithin', 'entries', 'every', 'fill', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'keys', 'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight', 'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'unshift', 'values'].reduce(function (descriptors, name) {\n    descriptors[name] = {\n        writable: true, enumerable: false,\n        value: bindArrayMethod(Array.prototype[name])\n    };\n    return descriptors;\n}, {\n    toJSON: { enumerable: false, value: toJSON },\n    toProps: { enumerable: false, value: toProps },\n    toString: { enumerable: false, value: toString },\n    $__hash: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta['$code'] || '';\n        }\n    },\n    $__path: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta[\"abs_path\"] || [];\n        }\n    },\n    $__version: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta[\"version\"] || 0;\n        }\n    }\n}));\n\nfunction bindArrayMethod(fn) {\n    return (bound.fn = fn) && bound;\n    function bound() {\n        return bound.fn.apply(this, arguments);\n    }\n}\n\nvar isArray = Array.isArray;\nvar typeofObject = 'object';\nvar typeofString = 'string';\n\nfunction getInst(inst) {\n    var typeofInst = typeof inst;\n    var argsLen = arguments.length;\n    if (argsLen === 0) {\n        inst = this;\n    } else if (typeofInst !== typeofString) {\n        if (!inst || typeofInst !== typeofObject) {\n            return inst;\n        }\n    } else if (argsLen !== 1) {\n        return inst;\n    } else {\n        inst = this;\n    }\n    return inst === global ? undefined : inst;\n}\n\nfunction toJSON() {\n    return serialize(getInst.apply(this, arguments), toJSON);\n}\n\nfunction toString(includeMetadata) {\n    return JSON.stringify(serialize(getInst.call(this, this), serialize, includeMetadata === true));\n}\n\nfunction toProps(inst) {\n\n    inst = getInst.apply(this, arguments);\n\n    var f_meta_inst,\n        f_meta_json,\n        version = 0;\n    var json = serialize(inst, toProps, true, true);\n\n    if (inst && (f_meta_inst = inst[\"\u001eƒ_meta\"])) {\n        version = f_meta_inst[\"version\"];\n    }\n\n    if (!(!json || typeof json !== typeofObject)) {\n        if (f_meta_json = json[\"\u001eƒ_meta\"]) {\n            f_meta_json[\"version\"] = version;\n        }\n    }\n\n    return json;\n}\n\nfunction serialize(inst, serializer, includeMetadata, createWithProto) {\n\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    }\n\n    var count, total, f_meta, keys, key, xs, ys;\n\n    if (isArray(inst)) {\n        xs = inst;\n    } else {\n\n        count = -1;\n        keys = Object.keys(inst);\n        total = keys.length;\n        xs = {};\n\n        if (createWithProto) {\n            xs.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (includeMetadata && (f_meta = inst[\"\u001eƒ_meta\"])) {\n\n            var $code = f_meta['$code'];\n            var abs_path = f_meta[\"abs_path\"];\n            var deref_to = f_meta[\"deref_to\"];\n            var deref_from = f_meta[\"deref_from\"];\n\n            f_meta = {};\n            $code && (f_meta['$code'] = $code);\n            abs_path && (f_meta[\"abs_path\"] = abs_path);\n            deref_to && (f_meta[\"deref_to\"] = deref_to);\n            deref_from && (f_meta[\"deref_from\"] = deref_from);\n\n            xs[\"\u001eƒ_meta\"] = f_meta;\n\n            if (createWithProto) {\n                ys = {};\n                ys.__proto__ = xs;\n                xs = ys;\n            }\n        }\n\n        while (++count < total) {\n            if ((key = keys[count]) !== \"\u001eƒ_meta\") {\n                xs[key] = serializer(inst[key], serializer, includeMetadata);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = '`null` is not allowed in branch key positions.';\n\n/**\n * Do not allow null in path.\n */\nmodule.exports = createErrorClass('NullInPathError', function () {\n  this.message = MESSAGE;\n});\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = createErrorClass;\n\nfunction createErrorClass(name, init) {\n    function E(message) {\n        this.message = message;\n        init && init.apply(this, arguments);\n        if (!Error.captureStackTrace) {\n            this.stack = new Error().stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    E.prototype = Object.create(Error.prototype);\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    E.is = function (x) {\n        return x.name === name;\n    };\n    return E;\n}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nvar objTypeof = 'object';\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nmodule.exports = { $type: 'atom' };\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternal = __webpack_require__(32);\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key,\n        keys = Object.keys(node),\n        json = {},\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (isInternal(key)) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[\"\u001eƒ_refs_length\"] || 0;\n    to[\"\u001eƒ_ref\" + backRefs] = from;\n    to[\"\u001eƒ_refs_length\"] = backRefs + 1;\n\n    // create a hard reference\n    from[\"\u001eƒ_ref_index\"] = backRefs;\n    from[\"\u001eƒ_context\"] = to;\n};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type,\n        depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === \"ref\") {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(30);\nvar updateBackReferenceVersions = __webpack_require__(50);\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child[\"\u001eƒ_parent\"];\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child[\"\u001eƒ_key\"], lru);\n        } else if (child[\"\u001eƒ_version\"] !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidKeySetError', function (path, keysOrRanges) {\n  this.mesage = '' + 'The KeySet ' + JSON.stringify(keysOrRanges) + ' in path ' + JSON.stringify(path) + ' contains a KeySet. ' + 'Keysets can only contain Keys or Ranges';\n});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EXPIRES_NEVER = __webpack_require__(62);\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root[\"\u001eƒ_head\"];\n\n    // Nothing is in the cache.\n    if (!head) {\n        root[\"\u001eƒ_head\"] = root[\"\u001eƒ_tail\"] = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[\"\u001eƒ_prev\"];\n    var next = object[\"\u001eƒ_next\"];\n    if (next) {\n        next[\"\u001eƒ_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\u001eƒ_next\"] = next;\n    }\n    object[\"\u001eƒ_prev\"] = undefined;\n\n    // Insert into head position\n    root[\"\u001eƒ_head\"] = object;\n    object[\"\u001eƒ_next\"] = head;\n    head[\"\u001eƒ_prev\"] = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root[\"\u001eƒ_tail\"]) {\n        root[\"\u001eƒ_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscription = __webpack_require__(15);\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' || typeof parent === 'function' || typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        };\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next = Subscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n};\n\nSubscriber.prototype.error = Subscriber.prototype.onError = function onError(error) {\n    var signaled = false;\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            signaled = true;\n            dest.onError(error);\n        } else if (dest.error) {\n            signaled = true;\n            dest.error(error);\n        }\n        this.dispose();\n    }\n    if (!signaled) {\n        throw error;\n    }\n};\n\nSubscriber.prototype.complete = Subscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n};\n\nSubscriber.prototype.dispose = Subscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\nmodule.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function (subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n};\n\nSubscription.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n};\n\nSubscription.prototype.dispose = Subscription.prototype.unsubscribe = function () {\n    var subscription,\n        subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) && subscription.dispose && subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar lruPromote = __webpack_require__(13);\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, reportMissing, treatErrorsAsValues, onValue, onMissing, onMaterialize) {\n\n    var reportMaterialized = reportMissing;\n\n    if (type) {\n        if (isExpired(node, expireImmediate)) {\n            if (!node[\"\u001eƒ_invalidated\"]) {\n                expireNode(node, expired, modelRoot);\n            }\n        } else {\n            lruPromote(modelRoot, node);\n            if (node.value === undefined) {\n                reportMissing = false;\n                reportMaterialized = materialized;\n            } else {\n                if (seed) {\n                    if (fromReference) {\n                        requestedPath[depth] = null;\n                    }\n                    return onValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues);\n                }\n                return undefined;\n            }\n        }\n    }\n\n    if (materialized) {\n        seed && (results.hasValue = true);\n    } else if (!reportMaterialized) {\n        return undefined;\n    }\n\n    return onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, materialized, json, branchSelector, boxValues, onMaterialize);\n}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getCachePosition = __webpack_require__(10);\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[\"\u001eƒ_parent\"] === undefined || node[\"\u001eƒ_invalidated\"]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(30);\nvar isInternalKey = __webpack_require__(21);\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (!isInternalKey(key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(5);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar createHardlink = __webpack_require__(8);\nvar mergeJSONGraphNode = __webpack_require__(83);\nvar NullInPathError = __webpack_require__(3);\nvar iterateKeySet = __webpack_require__(24);\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n    var initialVersion = cache[\"\u001eƒ_version\"];\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    var newVersion = cache[\"\u001eƒ_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (initialVersion !== newVersion) {\n        modelRoot.version = version;\n        rootChangeHandler && rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths, initialVersion !== newVersion];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, results[3], results[2], requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            node = results[0];\n            optimizedPath = results[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[\"\u001eƒ_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, messageRoot, messageParent, message, key, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isArray = Array.isArray;\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar createHardlink = __webpack_require__(8);\nvar getCachePosition = __webpack_require__(10);\nvar isInternalKey = __webpack_require__(21);\nvar NullInPathError = __webpack_require__(3);\nvar mergeValueOrInsertBranch = __webpack_require__(47);\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n    var initialVersion = cache[\"\u001eƒ_version\"];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, modelRoot, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[\"\u001eƒ_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (initialVersion !== newVersion) {\n        modelRoot.version = version;\n        rootChangeHandler && rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths, initialVersion !== newVersion];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[\"\u001eƒ_context\"];\n\n        if (node != null) {\n            parent = node[\"\u001eƒ_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\u001eƒ_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (type === void 0) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = 'length';\n        }\n        for (var key in pathMap) {\n            if (isInternalKey(key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nmodule.exports = isInternalKey;\n\nvar isInternal = __webpack_require__(32);\n\nfunction isInternalKey(key) {\n  return key && key[0] === '$' || isInternal(key);\n}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\nmodule.exports = flatBufferToPaths;\n\nfunction flatBufferToPaths(seed, paths, path) {\n\n    path = path || [];\n    paths = paths || [];\n\n    if (!seed) {\n        return paths;\n    }\n\n    var leaf = [];\n    var keys = seed['$keys'];\n    var keysLen = keys.length;\n    var keysIndex = -1,\n        key,\n        len;\n\n    while (++keysIndex < keysLen) {\n\n        var next = seed[keysIndex];\n        var keyset = keys[keysIndex];\n\n        if (!next || typeof next !== 'object') {\n            leaf.push(keyset);\n        } else {\n            flatBufferToPaths(next, paths, path.concat([keyset]));\n        }\n    }\n\n    if (leaf.length === 1) {\n        paths.push(path.concat(leaf));\n    } else if (leaf.length > 1) {\n        paths.push(path.concat([leaf]));\n    }\n\n    return paths;\n}\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nmodule.exports = getHashCode;\n\nfunction getHashCode(str) {\n    var hash = 5381,\n        i = str.length;\n    while (i) {\n        hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset,\n                length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                    ++note.arrayOffset;\n                    nextValue = el;\n                }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n            if (!note.loaded) {\n                initializeRange(keySet, note);\n            }\n            if (note.rangeOffset > note.to) {\n                note.done = true;\n                return undefined;\n            }\n\n            return note.rangeOffset++;\n        }\n\n        // Primitive value\n        else {\n                note.done = true;\n                return keySet;\n            }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to || typeof key.length === 'number' && memo.from + key.length - 1 || 0;\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(39);\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(42);\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\nmodule.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key,\n        depth = 0,\n        prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, json, branchSelector, boxValues, onMaterialize) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        return onMaterialize(json, mPath, missDepth, missTotal, branchSelector, boxValues);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if ('object' !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if ('number' !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar lruPromote = __webpack_require__(13);\nvar getSize = __webpack_require__(9);\nvar createHardlink = __webpack_require__(8);\nvar getBoundCacheNode = __webpack_require__(17);\nvar updateNodeAncestors = __webpack_require__(11);\nvar removeNodeAndDescendants = __webpack_require__(18);\nvar iterateKeySet = __webpack_require__(24);\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return;\n    }\n\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n    var initialVersion = cache[\"\u001eƒ_version\"];\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(path, 0, cache, parent, node, version, expired, lru, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    var newVersion = cache[\"\u001eƒ_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(path, depth, root, parent, node, version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        arr = invalidateNode(root, parent, node, key, branch, false, version, expired, lru, expireImmediate);\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru, expireImmediate);\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\u001eƒ_context\"];\n\n    if (node != null) {\n        parent = node[\"\u001eƒ_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(root, parent, node, key, branch, true, version, expired, lru, expireImmediate);\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[\"\u001eƒ_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(root, parent, node, key, branch, reference, version, expired, lru, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        arr = invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error('`null` is not allowed in branch key positions.');\n        } else if (node) {\n            key = node[\"\u001eƒ_key\"];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar lruSplice = __webpack_require__(55);\nvar unlinkBackReferences = __webpack_require__(86);\nvar unlinkForwardReference = __webpack_require__(87);\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type) {\n            if (type === \"ref\") {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node[\"\u001eƒ_parent\"] = void 0;\n        return true;\n    }\n    return false;\n};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar createHardlink = __webpack_require__(8);\nvar getCachePosition = __webpack_require__(10);\nvar NullInPathError = __webpack_require__(3);\nvar iterateKeySet = __webpack_require__(24);\nvar mergeValueOrInsertBranch = __webpack_require__(47);\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n    var initialVersion = cache[\"\u001eƒ_version\"];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, modelRoot, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[\"\u001eƒ_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (initialVersion !== newVersion) {\n        modelRoot.version = version;\n        rootChangeHandler && rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths, initialVersion !== newVersion];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[\"\u001eƒ_context\"];\n\n        if (node != null) {\n            parent = node[\"\u001eƒ_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\u001eƒ_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an f_ internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nvar f_ = __webpack_require__(94);\nvar regexp = new RegExp('^' + f_, 'i', 'g');\n\nmodule.exports = regexp.test.bind(regexp);\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\nmodule.exports = 0;\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toPaths = __webpack_require__(38);\nvar toCollapseMap = __webpack_require__(36);\nvar toCollapseTrees = __webpack_require__(37);\n\nmodule.exports = function collapse(paths) {\n    return toPaths(toCollapseTrees(toCollapseMap(paths)));\n};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar flatBufferToPaths = __webpack_require__(22);\n\nmodule.exports = toCollapseMap;\n\nfunction toCollapseMap(paths, collapseMap) {\n    if (!paths) {\n        return collapseMap;\n    } else if (!isArray(paths)) {\n        if (isArray(paths.$keys)) {\n            paths = flatBufferToPaths(paths);\n        }\n    }\n    return paths.reduce(function (acc, path) {\n        var len = path.length;\n        if (!acc[len]) {\n            acc[len] = [];\n        }\n        acc[len].push(path);\n        return acc;\n    }, collapseMap || {});\n}\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toTree = __webpack_require__(67);\n\nmodule.exports = toCollapseTrees;\n\nfunction toCollapseTrees(collapseMap, collapseTrees) {\n    return Object.keys(collapseMap).reduce(function (collapseTrees, collapseKey) {\n        collapseTrees[collapseKey] = toTree(collapseMap[collapseKey], collapseTrees[collapseKey]);\n        return collapseTrees;\n    }, collapseTrees || {});\n}\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeOfObject = 'object';\nvar typeOfString = 'string';\nvar typeOfNumber = 'number';\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\nvar getHashCode = __webpack_require__(23);\nvar materializedAtom = __webpack_require__(6);\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var subs = Object.create(null);\n    var code = '' + getHashCode('' + depth);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode, subKeys, subKeysIndex, subKeysCount, subSets, subSetsIndex, subSetsCount, pathset, pathsetIndex, pathsetCount, firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if (subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = '' + getHashCode(code + key + subCode);\n\n            isSafeNumber(key) && subPath.keys.push(parseInt(key, 10)) || subPath.keys.push(key);\n        }\n\n        while (++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = '' + getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {'from':1, 'to':6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/) {\n                isSparseRange = false;\n                break;\n            }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to '==='.\n        if (to - from <= keyCount) {\n            return { from: from, to: to };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === materializedAtom) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar walkPathAndBuildOutput = __webpack_require__(75);\nvar walkFlatBufferAndBuildOutput = __webpack_require__(74);\nvar getBoundCacheNode = __webpack_require__(17);\nvar InvalidModelError = __webpack_require__(92);\nvar toFlatBuffer = __webpack_require__(66);\nvar computeFlatBufferHash = __webpack_require__(64);\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        results = { data: seed },\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        materialized = seed && model._materialized,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    var arr,\n        path,\n        pathsIndex = 0,\n        pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n        if (recycleJSON) {\n            isFlatBuffer = true;\n            if (pathsCount > 1 || isArray(paths[0])) {\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n            arr = walkFlatBufferAndBuildOutput(cache, node, json, paths[0], 0, seed, results, requestedPath, optimizedPath, optimizedLength,\n            /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            json = arr[0];\n            arr[0] = undefined;\n            arr[1] = undefined;\n        } else {\n            do {\n                path = paths[pathsIndex];\n                requestedLength = path.length;\n                json = walkPathAndBuildOutput(cache, node, json, path,\n                /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            } while (++pathsIndex < pathsCount);\n        }\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar promote = __webpack_require__(13);\nvar isExpired = __webpack_require__(0);\nvar createHardlink = __webpack_require__(8);\nvar CircularReferenceError = __webpack_require__(52);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\u001eƒ_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === \"ref\") {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(7);\nvar onError = __webpack_require__(73);\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues) {\n\n    if (\"error\" === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath, fromReference, boxValues);\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    return !boxValues ? node.value : clone(node);\n}\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar walkPathAndBuildOutput = __webpack_require__(78);\nvar BoundJSONGraphModelError = __webpack_require__(90);\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        results = { data: seed },\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n        /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n        /* fromReference = */false, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args = results.relative = results.requested;\n\n    return results;\n}\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = __webpack_require__(7);\nvar FalcorJSON = __webpack_require__(2);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(6);\n\nmodule.exports = onMaterialize;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterialize(json, path, depth, length, branchSelector, boxValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (depth === length) {\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta;\n\n    var nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0;\n\n    keyset = path[depth];\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta[\"version\"] = 0;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[\"\u001eƒ_meta\"])) {\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta[\"version\"] = 0;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n    } else {\n        f_meta[\"version\"] = 0;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            // insert the materialized branch\n            json[nextKey] = onMaterialize(json[nextKey], path, nextDepth, length, branchSelector, boxValues);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isPathValue = __webpack_require__(104);\nvar isJSONEnvelope = __webpack_require__(59);\nvar isJSONGraphEnvelope = __webpack_require__(60);\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = 'PathValues';\n        } else if (isPathValue(arg)) {\n            argType = 'PathValues';\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = 'JSONGraphs';\n        } else if (isJSONEnvelope(arg)) {\n            argType = 'PathMaps';\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node[\"\u001eƒ_key\"] = key;\n    node[\"\u001eƒ_parent\"] = parent;\n\n    if (version !== undefined) {\n        node[\"\u001eƒ_version\"] = version;\n    }\n    if (!node[\"\u001eƒ_abs_path\"]) {\n        node[\"\u001eƒ_abs_path\"] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar lruPromote = __webpack_require__(13);\nvar getSize = __webpack_require__(9);\nvar createHardlink = __webpack_require__(8);\nvar getBoundCacheNode = __webpack_require__(17);\nvar isInternalKey = __webpack_require__(21);\nvar updateNodeAncestors = __webpack_require__(11);\nvar removeNodeAndDescendants = __webpack_require__(18);\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return;\n    }\n\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n    var initialVersion = cache[\"\u001eƒ_version\"];\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, expireImmediate);\n    }\n\n    var newVersion = cache[\"\u001eƒ_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (!isInternalKey(key)) {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            var results = invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, expireImmediate);\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, expireImmediate);\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\u001eƒ_context\"];\n\n    if (node != null) {\n        parent = node[\"\u001eƒ_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, expireImmediate);\n            node = results[0];\n            if (!node || typeof node !== 'object') {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container[\"\u001eƒ_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(root, parent, node, key, value, branch, reference, version, expired, lru, comparator, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate);\n\n        node = results[0];\n\n        if (!node && typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error('`null` is not allowed in branch key positions.');\n        } else if (node) {\n            key = node[\"\u001eƒ_key\"];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $now = __webpack_require__(33);\nvar getType = __webpack_require__(103);\nvar getSize = __webpack_require__(9);\nvar getTimestamp = __webpack_require__(58);\n\nvar wrapNode = __webpack_require__(51);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar insertNode = __webpack_require__(45);\nvar replaceNode = __webpack_require__(49);\nvar reconstructPath = __webpack_require__(48);\nvar updateNodeAncestors = __webpack_require__(11);\nvar removeNodeAndDescendants = __webpack_require__(18);\n\nmodule.exports = function mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node,\n        /* expireImmediate:\n         * force true so the node is marked as\n         * expired but keep using it for the merge if it expires immediately\n         */\n        true)) {\n            expireNode(node, expired, lru);\n            type = node.$expires === $now ? type : 'expired';\n        }\n        if (type && type !== \"ref\" || !node || typeof node !== 'object') {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var isDistinct = true;\n        var mType = getType(message);\n\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        if (comparator) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        } else if (!mType) {\n            isDistinct = !node || node.value !== message;\n        } else {\n            isDistinct = !type ||\n            // Comparing either Number or undefined to undefined always results in false.\n            getTimestamp(message) < getTimestamp(node) === false || !(\n            // They're the same if the following fields are the same.\n            type !== mType || node.value !== message.value || node.$expires !== message.$expires);\n        }\n\n        if (isDistinct) {\n\n            if (errorSelector && mType === \"error\") {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            var sizeOffset = getSize(node) - getSize(message = wrapNode(message, mType, mType ? message.value : message));\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n  var path = currentPath.slice(0, currentPath.depth);\n  path[path.length] = key;\n\n  return path;\n};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar transferBackReferences = __webpack_require__(85);\nvar removeNodeAndDescendants = __webpack_require__(18);\nvar updateBackReferenceVersions = __webpack_require__(50);\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        if (node && node[\"\u001eƒ_version\"] !== version) {\n            node[\"\u001eƒ_version\"] = version;\n            stack[count++] = node[\"\u001eƒ_parent\"];\n            var i = -1;\n            var n = node[\"\u001eƒ_refs_length\"] || 0;\n            while (++i < n) {\n                stack[count++] = node[\"\u001eƒ_ref\" + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar now = __webpack_require__(61);\nvar clone = __webpack_require__(101);\nvar getSize = __webpack_require__(9);\nvar getExpires = __webpack_require__(102);\nvar expiresNow = __webpack_require__(33);\n\nvar atomSize = 50;\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[\"\u001eƒ_wrapped_value\"];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[\"\u001eƒ_prev\"] = undefined;\n        node[\"\u001eƒ_next\"] = undefined;\n        node[\"\u001eƒ_wrapped_value\"] = modelCreated || false;\n    } else {\n        node = { $type: \"atom\", value: value };\n        node[\"\u001eƒ_prev\"] = undefined;\n        node[\"\u001eƒ_next\"] = undefined;\n        node[\"\u001eƒ_wrapped_value\"] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case 'object':\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case 'string':\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === 'number' && expires < expiresNow) {\n        node.$expires = now() + expires * -1;\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\n\nmodule.exports = createErrorClass('CircularReferenceError', function (referencePath) {\n    this.message = 'Encountered circular reference ' + JSON.stringify(referencePath);\n});\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'An exception was thrown when making a request';\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidSourceError', function (error) {\n  this.message = MESSAGE + ':\\n\\t' + error;\n});\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(30);\nvar updateNodeAncestors = __webpack_require__(11);\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== 'number') {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === 'number';\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node[\"\u001eƒ_parent\"]) {\n            // eslint-disable-line no-cond-assign\n            removeNode(node, parent, node[\"\u001eƒ_key\"], lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru[\"\u001eƒ_tail\"];\n        node = prev;\n        while (total >= targetSize && node) {\n            prev = prev[\"\u001eƒ_prev\"];\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru[\"\u001eƒ_tail\"] = lru[\"\u001eƒ_prev\"] = node;\n        if (node == null) {\n            lru[\"\u001eƒ_head\"] = lru[\"\u001eƒ_next\"] = undefined;\n        } else {\n            node[\"\u001eƒ_next\"] = undefined;\n        }\n    }\n};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object[\"\u001eƒ_prev\"];\n    var next = object[\"\u001eƒ_next\"];\n    if (next) {\n        next[\"\u001eƒ_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\u001eƒ_next\"] = next;\n    }\n    object[\"\u001eƒ_prev\"] = object[\"\u001eƒ_next\"] = undefined;\n\n    if (object === root[\"\u001eƒ_head\"]) {\n        root[\"\u001eƒ_head\"] = next;\n    }\n    if (object === root[\"\u001eƒ_tail\"]) {\n        root[\"\u001eƒ_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\nvar $$observable = __webpack_require__(105).default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function () {\n    return this;\n};\n\nSource.prototype.operator = function (destination) {\n    return this.subscribe(destination);\n};\n\n// Unused\n// Source.prototype.lift = function(operator, source) {\n//     source = new Source(source || this);\n//     source.operator = operator;\n//     source._promise = this._promise;\n//     return source;\n// }\n\nSource.prototype.subscribe = function (destination, x, y) {\n    return new Subscription([this.operator.call(this.source, !(destination instanceof Subscriber) ? new Subscriber(destination, x, y) : destination)]);\n};\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function (resolve, reject) {\n            var values = [],\n                rejected = false;\n            source.subscribe({\n                next: function (value) {\n                    values[values.length] = value;\n                },\n                error: function (errors) {\n                    (rejected = true) && reject(errors);\n                },\n                complete: function () {\n                    !rejected && resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\nvar empty = {\n    dispose: function () {},\n    unsubscribe: function () {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && 'json' in envelope;\n};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));\n};\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\nmodule.exports = Date.now;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\nmodule.exports = 1;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Model = __webpack_require__(68);\nvar FalcorJSON = __webpack_require__(2);\n\nfunction falcor(opts) {\n    if (!(this instanceof Model)) {\n        return new Model(opts);\n    }\n    Model.call(this, opts);\n}\n\nfalcor.prototype = Object.create(Model.prototype);\n\nfalcor['Model'] = Model;\nfalcor['FalcorJSON'] = FalcorJSON;\nfalcor['toProps'] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar getHashCode = __webpack_require__(23);\n\nmodule.exports = computeFlatBufferHash;\n\nfunction computeFlatBufferHash(seed) {\n\n    if (seed === undefined) {\n        return undefined;\n    }\n\n    var code = '';\n    var keys = seed['$keys'];\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    while (++keysIndex < keysLength) {\n\n        var key = keys[keysIndex];\n\n        if (key === null) {\n            code = '' + getHashCode('' + code + 'null');\n            continue;\n        } else if (typeof key === 'object') {\n            key = '[' + key.from + '..' + (key.from + key.length - 1) + ']';\n        }\n\n        var next = computeFlatBufferHash(seed[keysIndex]);\n        if (next === undefined) {\n            code = '' + getHashCode('' + code + key);\n        } else {\n            code = '' + getHashCode('' + code + key + next['$code']);\n        }\n    }\n\n    seed['$code'] = code;\n\n    return seed;\n}\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar materializedAtom = __webpack_require__(6);\n\nmodule.exports = hasIntersection;\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var next,\n        nextKey,\n        nextDepth = depth + 1,\n        keyIsRange,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar nullBuffer = { '$keys': [null], '$keysMap': { 'null': 0 } };\nvar flatBufferToPaths = __webpack_require__(22);\n\nmodule.exports = toFlatBuffer;\n\nfunction toFlatBuffer(paths, seed) {\n    return paths.reduce(function (seed, path) {\n        if (isArray(path)) {\n            return pathToFlatBuffer(seed, path, 0, path.length);\n        } else if (isArray(path.$keys)) {\n            return toFlatBuffer(flatBufferToPaths(path), seed);\n        }\n        return seed;\n    }, seed || {});\n}\n\nfunction pathToFlatBuffer(seed, path, depth, length) {\n\n    if (depth === length) {\n        return undefined;\n    }\n\n    seed = seed || {};\n    var keys = seed['$keys'] || (seed['$keys'] = []);\n    var keysMap = seed['$keysMap'] || (seed['$keysMap'] = {});\n    var keysIndex = -1;\n\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var node,\n        next,\n        nextKey,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullBuffer;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = nextKey;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyset = { from: nextKey, length: rangeEnd - nextKey + 1 };\n                    nextKey = '[' + nextKey + '..' + rangeEnd + ']';\n                    if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                        keysIndex = keys.length;\n                    }\n                    keys[keysIndex] = keyset;\n                    keysMap[nextKey] = keysIndex;\n                    next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n                    if (next !== undefined) {\n                        seed[keysIndex] = next;\n                    }\n                }\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar materializedAtom = __webpack_require__(6);\n\nmodule.exports = toTree;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\n\nfunction toTree(paths, seed) {\n    return paths.reduce(function (seed, path) {\n        return pathToTree(seed, path, 0, path.length, null);\n    }, seed || {});\n};\n\nfunction pathToTree(seed, path, depth, length, value) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    seed = seed || {};\n\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var node,\n        next,\n        nextKey,\n        nextDepth = depth + 1,\n        keyIsRange,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = value;\n            } else {\n                node = seed[nextKey];\n                next = pathToTree(node, path, nextDepth, length, value);\n                if (!next) {\n                    seed[nextKey] = value;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Call = __webpack_require__(95);\nvar ModelRoot = __webpack_require__(70);\nvar FalcorJSON = __webpack_require__(2);\nvar ModelDataSourceAdapter = __webpack_require__(69);\nvar TimeoutScheduler = __webpack_require__(99);\nvar ImmediateScheduler = __webpack_require__(57);\nvar collapse = __webpack_require__(35);\n\nvar lruCollect = __webpack_require__(54);\nvar getSize = __webpack_require__(9);\nvar isObject = __webpack_require__(5);\nvar isJSONEnvelope = __webpack_require__(59);\nvar getCachePosition = __webpack_require__(10);\nvar isJSONGraphEnvelope = __webpack_require__(60);\n\nvar setCache = __webpack_require__(20);\nvar setJSONGraphs = __webpack_require__(19);\n\nvar getJSON = __webpack_require__(25);\nvar getCache = __webpack_require__(80);\nvar getJSONGraph = __webpack_require__(26);\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n/**\n* This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n* @callback Model~errorSelector\n* @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n* @returns {Object} the JSONGraph Error object to store in the Model cache.\n*/\n\n/**\n* This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n* @callback Model~comparator\n* @param {Object} existingValue - the current value in the Model cache.\n* @param {Object} newValue - the value about to be set into the Model cache.\n* @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n*/\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._treatErrorsAsValues = true;\n        this._seed = {};\n        this._seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get() {\n    var seed = this._seed;\n    if (!seed) {\n        seed = {};\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    return new Call('get', this, args)._toJSON(seed, []);\n};\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set() {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n    }\n\n    return new Call('set', this, args)._toJSON(seed, []);\n};\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n    }\n\n    return new Call('get', this, args)._toJSON(null, []);\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call() {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n    }\n\n    return new Call('call', this, args)._toJSON(seed, []);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n    }\n\n    return new Call('invalidate', this, args)._toJSON(null, null).then();\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.deref = __webpack_require__(89);\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = __webpack_require__(88);\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return new Call('get', this, [path])._toJSON({}, []).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : { path: path, value: value };\n    return new Call('set', this, [value])._toJSON({}, []).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n\n    var modelRoot = this._root;\n    var cache = modelRoot.cache;\n\n    if (cacheOrJSONGraphEnvelope !== cache) {\n\n        var options = {\n            _path: [],\n            _boxed: false,\n            _root: modelRoot,\n            _materialized: false,\n            _treatErrorsAsValues: false\n        };\n\n        modelRoot.cache = this._node = {};\n\n        if (typeof cache !== 'undefined') {\n            lruCollect(modelRoot, modelRoot.expired, getSize(cache), 0);\n            if (this._recycleJSON) {\n                this._seed = {};\n                this._seed.__proto__ = FalcorJSON.prototype;\n            }\n        }\n\n        var paths;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            paths = setJSONGraphs(options, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            paths = setCache(options, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            paths = setCache(options, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (paths) {\n            getJSON(options, paths, null, false, false);\n        }\n    } else if (typeof cache === 'undefined') {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache('genreLists[0...10][0...10].boxshot')));\n */\nModel.prototype.getCache = function _getCache() {\n\n    var paths = Array.prototype.slice.call(arguments, 0);\n\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    var env = getJSONGraph({\n        _path: [],\n        _root: this._root,\n        _boxed: this._boxed,\n        _materialized: this._materialized,\n        _treatErrorsAsValues: this._treatErrorsAsValues\n    }, paths, seed).data;\n\n    env.paths = collapse(paths);\n\n    return env;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path) {\n    path = path || [];\n    if (Array.isArray(path) === false) {\n        throw new Error('Model#getVersion must be called with an Array path.');\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === 'delete') {\n                delete clone[key];\n            } else if (key === '_path') {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty('_node')) {\n                    delete clone['_node'];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === 'number') {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: 'Steve',\n                surname: 'McGuire'\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints 'Steve'\nproxyModel.getValue('user.name').\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: 'delete'\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: 'ref',\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[\"\u001eƒ_abs_path\"] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = __webpack_require__(81);\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = __webpack_require__(31);\nModel.prototype._setPathMaps = __webpack_require__(20);\nModel.prototype._setJSONGs = __webpack_require__(19);\nModel.prototype._setCache = __webpack_require__(20);\n\nModel.prototype._invalidatePathValues = __webpack_require__(29);\nModel.prototype._invalidatePathMaps = __webpack_require__(46);\n\n/***/ },\n/* 69 */\n/***/ function(module, exports) {\n\nfunction ModelDataSourceAdapter(model) {\n    this._model = model\n    // .boxValues()\n    ._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [path, args, suffixes].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar functionTypeof = 'function';\nvar Requests = __webpack_require__(96);\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = -1;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nModelRoot.comparator = function comparator(cacheNode, messageNode) {\n    var cType = cacheNode && cacheNode.$type;\n    var mType = messageNode && messageNode.$type;\n    if (cType) {\n        if (!mType) {\n            return cacheNode.value === messageNode;\n        } else {\n            // They are the same only if the following fields are the same.\n            return !(cType !== mType || cacheNode.value !== messageNode.value || cacheNode.$expires !== messageNode.$expires);\n        }\n    } else if (mType) {\n        return false;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(25);\nvar getJSONGraph = __webpack_require__(26);\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n    json: __webpack_require__(39),\n    jsonGraph: __webpack_require__(42)\n};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(7);\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results, requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = __webpack_require__(41);\nvar FalcorJSON = __webpack_require__(2);\nvar isExpired = __webpack_require__(0);\nvar onValueType = __webpack_require__(16);\nvar originalOnMissing = __webpack_require__(28);\nvar getReferenceTarget = __webpack_require__(40);\nvar onMaterialize = __webpack_require__(79);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(12);\nvar getHashCode = __webpack_require__(23);\nvar flatBufferToPaths = __webpack_require__(22);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node || undefined !== (type = node.$type) || undefined === path) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json, path, depth, seed, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta,\n        f_old_keys,\n        f_new_keys,\n        f_code = '';\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        keys = path['$keys'],\n        nodeAbsPath,\n        jsonAbsPath,\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextJSON,\n        nextReferenceContainer,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\u001eƒ_abs_path\"];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[\"\u001eƒ_meta\"]) {\n\n        nodeAbsPath = node[\"\u001eƒ_abs_path\"];\n        jsonAbsPath = f_meta[\"abs_path\"];\n\n        if (!branchSelector && !(json instanceof FalcorJSON)) {\n            json.__proto__ = {};\n            json.__proto__[\"\u001eƒ_meta\"] = f_meta;\n            json.__proto__.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (nodeAbsPath !== jsonAbsPath) {\n            f_meta['$code'] = '__incomplete__';\n            f_meta[\"abs_path\"] = nodeAbsPath;\n            f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n            f_meta[\"deref_to\"] = refContainerRefPath;\n            f_meta[\"deref_from\"] = refContainerAbsPath;\n            if (f_old_keys = f_meta[\"keys\"]) {\n                f_meta[\"keys\"] = Object.create(null);\n                for (nextKey in f_old_keys) {\n                    if (f_old_keys[nextKey]) {\n                        delete json[nextKey];\n                    }\n                }\n            }\n            arr[0] = json;\n            arr[1] = true;\n            return arr;\n        } else if (!(f_meta[\"version\"] !== node[\"\u001eƒ_version\"] || f_meta['$code'] !== path['$code'])) {\n            results.hasValue = true;\n            arr[0] = json;\n            arr[1] = false;\n            return arr;\n        }\n\n        f_old_keys = f_meta[\"keys\"];\n        f_meta[\"abs_path\"] = nodeAbsPath;\n        f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n        f_meta[\"deref_to\"] = refContainerRefPath;\n        f_meta[\"deref_from\"] = refContainerAbsPath;\n    }\n\n    f_new_keys = Object.create(null);\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath,\n        nextPathKey,\n        hasMissingPath = false;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = '' + getHashCode('' + f_code + 'null');\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n                nextPathKey = nextKey;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                    nextPathKey = '[' + nextKey + '..' + rangeEnd + ']';\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextPath === undefined) {\n\n                arr = walkPathAndBuildOutput(root, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                nextJSON = arr[0];\n                hasMissingPath = hasMissingPath || arr[1];\n\n                if (nextJSON === undefined && !materialized) {\n                    hasMissingPath = true;\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            } else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                arr = walkPathAndBuildOutput(root, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                nextJSON = arr[0];\n                hasMissingPath = hasMissingPath || arr[1];\n\n                if (nextJSON === undefined) {\n                    hasMissingPath = true;\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n                f_meta[\"abs_path\"] = node[\"\u001eƒ_abs_path\"];\n                f_meta[\"deref_to\"] = refContainerRefPath;\n                f_meta[\"deref_from\"] = refContainerAbsPath;\n                json = {};\n                json[\"\u001eƒ_meta\"] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                } else {\n                    var tmp = json;\n                    json = {};\n                    json.__proto__ = tmp;\n                    tmp = undefined;\n                }\n            }\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && nextKey in f_old_keys) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        if (!hasMissingPath) {\n            f_code = '' + getHashCode('' + f_code + nextPathKey + (nextPath && nextPath['$code'] || ''));\n        }\n    }\n\n    if (hasMissingPath) {\n        f_code = '__incomplete__';\n    }\n\n    if (f_meta) {\n        f_meta['$code'] = f_code;\n        f_meta[\"keys\"] = f_new_keys;\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, json, branchSelector, boxValues, onMaterialize) {\n\n    if (reportMaterialized) {\n        return onMaterialize(json, path, depth, depth, branchSelector, boxValues, results, requestedPath, optimizedPath, optimizedLength, fromReference, reportMissing, onMissing);\n    }\n\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n\n    return paths.forEach(function (restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, false, json, branchSelector, boxValues, onMaterialize);\n    });\n}\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = __webpack_require__(41);\nvar onMissing = __webpack_require__(28);\nvar FalcorJSON = __webpack_require__(2);\nvar onValueType = __webpack_require__(16);\nvar isExpired = __webpack_require__(0);\nvar onMaterialize = __webpack_require__(43);\nvar getReferenceTarget = __webpack_require__(40);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(6);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var f_meta;\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        nextJSON,\n        nextReferenceContainer,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return json;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\u001eƒ_abs_path\"];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[\"\u001eƒ_meta\"]) {\n        f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n        f_meta[\"abs_path\"] = node[\"\u001eƒ_abs_path\"];\n        f_meta[\"deref_to\"] = refContainerRefPath;\n        f_meta[\"deref_from\"] = refContainerAbsPath;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextDepth === requestedLength) {\n                nextJSON = walkPathAndBuildOutput(root, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n                if (nextJSON === undefined && !materialized) {\n                    continue;\n                }\n            } else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                if (undefined === (nextJSON = walkPathAndBuildOutput(root, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame))) {\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n                f_meta[\"abs_path\"] = node[\"\u001eƒ_abs_path\"];\n                f_meta[\"deref_to\"] = refContainerRefPath;\n                f_meta[\"deref_from\"] = refContainerAbsPath;\n                json = {};\n                json[\"\u001eƒ_meta\"] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                if (branchSelector) {\n                    json = branchSelector(json);\n                }\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n/* eslint-enable */\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar clone = __webpack_require__(7);\nvar inlineValue = __webpack_require__(27);\nvar promote = __webpack_require__(13);\nvar isExpired = __webpack_require__(0);\nvar createHardlink = __webpack_require__(8);\nvar CircularReferenceError = __webpack_require__(52);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\u001eƒ_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === \"ref\") {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar typeofObject = 'object';\nvar clone = __webpack_require__(7);\nvar inlineValue = __webpack_require__(27);\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized) {\n\n    var value = node.value;\n\n    // boxValues always clones the node\n    if (boxValues || !(\n    /**\n     * JSON Graph should always clone:\n     * - refs\n     * - errors\n     * - atoms we didn't create\n     * - atoms we created to wrap Objects\n     **/\n    \"ref\" !== type && \"error\" !== type && node[\"\u001eƒ_wrapped_value\"] && typeofObject !== typeof value)) {\n        value = clone(node);\n    }\n\n    results.hasValue = true;\n    inlineValue(value, optimizedPath, optimizedLength, seed);\n    (seed.paths || (seed.paths = [])).push(requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n    );\n\n    return value;\n}\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar clone = __webpack_require__(7);\nvar onValue = __webpack_require__(77);\nvar inlineValue = __webpack_require__(27);\nvar isExpired = __webpack_require__(0);\nvar onValueType = __webpack_require__(16);\nvar onMaterialize = __webpack_require__(43);\nvar originalOnMissing = __webpack_require__(28);\nvar getReferenceTarget = __webpack_require__(76);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(6);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, seed, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, undefined, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                keyset = keysOrRanges[keysetIndex];\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(root, next, modelRoot, seed, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(root, next, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, seed, branchSelector, boxValues, onMaterialize) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push((isLeaf = 0 === requestedLength - depth) &&\n        // depth + 1 if fromReference === true\n        requestedPath.slice(0, depth + !!fromReference) || requestedPath.slice(0, depth).concat(path.slice(depth, requestedLength + !!fromReference)));\n\n        json = inlineValue(isLeaf && clone(materializedAtom) || undefined, optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, !isLeaf && reportMaterialized, json, branchSelector, true, onMaterialize);\n}\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = __webpack_require__(7);\nvar onValueType = __webpack_require__(16);\nvar FalcorJSON = __webpack_require__(2);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(6);\n\nmodule.exports = onMaterializeFlatBuffer;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterializeFlatBuffer(json, path, depth, length, branchSelector, boxValues, results, requestedPath, optimizedPath, optimizedLength, fromReference, reportMissing, onMissing) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === path) {\n        onValueType(undefined, undefined, json, path, depth, undefined, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, undefined, undefined, false, branchSelector, boxValues, false, reportMissing, false, undefined, onMissing, undefined);\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta, f_old_keys, f_new_keys;\n\n    var nextKey,\n        keyset,\n        keyIsRange,\n        keys = path['$keys'],\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextOptimizedLength = optimizedLength + 1;\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta[\"version\"] = 0;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[\"\u001eƒ_meta\"])) {\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta[\"version\"] = 0;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n    } else {\n        f_old_keys = f_meta[\"keys\"];\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n    }\n\n    f_new_keys = {};\n\n    var nextPath;\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && nextKey in f_old_keys) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // insert the materialized branch\n            json[nextKey] = onMaterializeFlatBuffer(json[nextKey], nextPath, nextDepth, nextDepth, branchSelector, boxValues, results, requestedPath, optimizedPath, nextOptimizedLength, fromReference, reportMissing, onMissing);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n    }\n\n    f_meta['$code'] = '__incomplete__';\n    f_meta[\"keys\"] = f_new_keys;\n    if (f_old_keys) {\n        for (nextKey in f_old_keys) {\n            if (f_old_keys[nextKey]) {\n                delete json[nextKey];\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternalKey = __webpack_require__(21);\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (key === '$type' || !isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    // only copy objects\n    if (!node || typeof node !== 'object') {\n        return;\n    }\n\n    Object.keys(node).filter(function (key) {\n        // Its not an internal key and the node has a value.  In the cache\n        // there are 3 possibilities for values.\n        // 1: A branch node.\n        // 2: A $type-value node.\n        // 3: undefined\n        // We will strip out 3\n        return (key === '$type' || !isInternalKey(key)) && node[key] !== undefined;\n    }).forEach(function (key) {\n        var cacheNext = node[key];\n        var outNext = out[key];\n\n        if (!outNext) {\n            outNext = out[key] = {};\n        }\n\n        // Paste the node into the out cache.\n        if (cacheNext.$type) {\n            var isObject = cacheNext.value && typeof cacheNext.value === 'object';\n            var isUserCreatedcacheNext = !cacheNext[\"\u001eƒ_wrapped_value\"];\n            var value;\n            if (isObject || isUserCreatedcacheNext) {\n                value = cloneBoxedValue(cacheNext);\n            } else {\n                value = cacheNext.value;\n            }\n\n            out[key] = value;\n            return;\n        }\n\n        _copyCache(cacheNext, outNext, key);\n    });\n}\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getBoundCacheNode = __webpack_require__(17);\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[\"\u001eƒ_version\"];\n    return version == null ? -1 : version;\n};\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar groupCacheArguments = __webpack_require__(44);\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n    invalidatePathMaps: __webpack_require__(46),\n    invalidatePathValues: __webpack_require__(29)\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    invalidateArgumentGroups(model, groupCacheArguments(args), expireImmediate);\n    return {};\n}\n\nfunction invalidateArgumentGroups(model, xs, expireImmediate) {\n\n    var groupIndex = -1;\n    var groupCount = xs.length;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            if (inputType === 'PathValues') {\n                groupedArgs = groupedArgs.map(pluckPaths);\n            }\n            module.exports['invalidate' + inputType](model, groupedArgs, expireImmediate);\n        }\n    }\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar wrapNode = __webpack_require__(51);\nvar isExpired = __webpack_require__(0);\nvar insertNode = __webpack_require__(45);\nvar expireNode = __webpack_require__(1);\nvar replaceNode = __webpack_require__(49);\nvar getSize = __webpack_require__(9);\nvar reconstructPath = __webpack_require__(48);\nvar getTimestamp = __webpack_require__(58);\nvar updateNodeAncestors = __webpack_require__(11);\n\nmodule.exports = function mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n\n    var cType, mType, cIsObject, mIsObject, cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // The message and cache are both undefined, return undefined.\n        if (message === undefined) {\n            return message;\n        }\n        // There should not be undefined values. Those should always be\n        // wrapped in an $atom\n        else if (message === null) {\n                node = wrapNode(message, undefined, message);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, undefined, optimizedPath);\n                return node;\n            }\n            // Is the cache node a branch? If so, return the cache branch.\n            else if ((cIsObject = !(!node || typeof node !== 'object')) && (cType = node.$type) === undefined) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node[\"\u001eƒ_parent\"] === undefined) {\n                        insertNode(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n    } else if (cIsObject = !(!node || typeof node !== 'object')) {\n        cType = node.$type;\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== \"ref\") {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || mIsObject && !mType) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n            // If the cache is a reference, but the message is empty, leave the cache alone...\n            if (message == null) {\n                // ...unless the cache is an expired reference. In that case, expire\n                // the cache node and return undefined.\n                if (isExpired(node, expireImmediate)) {\n                    expireNode(node, expired, lru);\n                    return void 0;\n                }\n                return node;\n            }\n            mIsObject = !(!message || typeof message !== 'object');\n            if (mIsObject) {\n                mType = message.$type;\n                // If the cache and the message are both references,\n                // check if we need to replace the cache reference.\n                if (mType === \"ref\") {\n                    if (node === message) {\n                        // If the cache and message are the same reference,\n                        // we performed a whole-branch merge of one of the\n                        // grandparents. If we've previously graphed this\n                        // reference, break early. Otherwise, continue to\n                        // leaf insertion below.\n                        if (node[\"\u001eƒ_parent\"] != null) {\n                            return node;\n                        }\n                    } else {\n\n                        cTimestamp = node.$timestamp;\n                        mTimestamp = message.$timestamp;\n\n                        // - If either the cache or message reference is expired,\n                        //   replace the cache reference with the message.\n                        // - If neither of the references are expired, compare their\n                        //   timestamps. If either of them don't have a timestamp,\n                        //   or the message's timestamp is newer, replace the cache\n                        //   reference with the message reference.\n                        // - If the message reference is older than the cache\n                        //   reference, short-circuit.\n                        if (!isExpired(node, expireImmediate) && !isExpired(message, expireImmediate) && mTimestamp < cTimestamp) {\n                            return void 0;\n                        }\n                    }\n                }\n            }\n        }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n            // If the cache and the message are the same value, we branch-merged one\n            // of the message's ancestors. If this is the first time we've seen this\n            // leaf, give the message a $size and $type, attach its graph pointers,\n            // and update the cache sizes and versions.\n\n            if (mType === \"error\" && errorSelector) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            if (mType && node === message) {\n                if (node[\"\u001eƒ_parent\"] == null) {\n                    node = wrapNode(node, cType, node.value);\n                    parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                    node = insertNode(node, parent, key, version, optimizedPath);\n                }\n            }\n            // If the cache and message are different, the cache value is expired,\n            // or the message is a primitive, replace the cache with the message value.\n            // If the message is a sentinel, clone and maintain its type.\n            // If the message is a primitive value, wrap it in an atom.\n            else {\n                    var isDistinct = true;\n                    // If the cache is a branch, but the message is a leaf, replace the\n                    // cache branch with the message leaf.\n                    if (!cIsObject || cType && !isExpired(node, expireImmediate)) {\n\n                        // Compare the current cache value with the new value. If either of\n                        // them don't have a timestamp, or the message's timestamp is newer,\n                        // replace the cache value with the message value. If a comparator\n                        // is specified, the comparator takes precedence over timestamps.\n                        if (comparator) {\n                            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                        } else if (!mType) {\n                            isDistinct = !node || node.value !== message;\n                        } else {\n                            isDistinct = !cType ||\n                            // Comparing either Number or undefined to undefined always results in false.\n                            getTimestamp(message) < getTimestamp(node) === false || !(\n                            // They're the same if the following fields are the same.\n                            cType !== mType || node.value !== message.value || node.$expires !== message.$expires);\n                        }\n                    }\n                    if (isDistinct) {\n                        message = wrapNode(message, mType, mType ? message.value : message);\n                        sizeOffset = getSize(node) - getSize(message);\n                        node = replaceNode(node, message, parent, key, lru, version);\n                        parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                    }\n                }\n\n            // Promote the message edge in the LRU.\n            if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n                expireNode(node, expired, lru);\n            }\n        } else if (node == null) {\n            node = insertNode(message, parent, key, undefined, optimizedPath);\n        }\n\n    return node;\n};\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(25);\nvar getJSONGraph = __webpack_require__(26);\nvar arrayFlatMap = __webpack_require__(100);\nvar groupCacheArguments = __webpack_require__(44);\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: __webpack_require__(20),\n    setPathValues: __webpack_require__(31),\n    setJSONGraphs: __webpack_require__(19)\n};\n\nfunction json(model, _args, data, progressive, expireImmediate) {\n\n    var set,\n        get,\n        jsong,\n        changed,\n        relative,\n        optimized,\n        missing,\n        fragments,\n        requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args /*, expireImmediate */);\n\n    if ((relative = set.requested).length) {\n\n        if (!(changed = set.changed) || progressive) {\n            get = getJSON(model, relative, data, progressive, expireImmediate);\n        }\n\n        if (changed) {\n\n            jsong = getJSONGraph({\n                _root: model._root,\n                _boxed: model._boxed, _materialized: true,\n                _treatErrorsAsValues: model._treatErrorsAsValues\n            }, set.optimized, {}, progressive, expireImmediate);\n\n            fragments = jsong.data;\n            missing = fragments.paths;\n            requested = jsong.requested;\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: get && get.error,\n        errors: get && get.errors,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive, expireImmediate) {\n\n    var set,\n        jsong,\n        changed,\n        relative,\n        optimized,\n        missing,\n        fragments,\n        requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args /*, expireImmediate */);\n\n    if ((relative = set.requested).length && (progressive || set.changed)) {\n\n        jsong = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed, _materialized: true,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, set.optimized, data, progressive, expireImmediate);\n\n        fragments = jsong.data;\n        missing = fragments.paths;\n        requested = jsong.requested;\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: jsong && jsong.error,\n        hasValue: jsong && jsong.hasValue\n    };\n}\n\nfunction setGroupsIntoCache(model, xs /*, expireImmediate */) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var selector = modelRoot.errorSelector;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports['set' + inputType];\n            var results = operation(model, groupedArgs, selector, null, false);\n            changed = changed || results[2];\n            optimizedPaths.push.apply(optimizedPaths, results[1]);\n            if (inputType === 'PathValues') {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === 'JSONGraphs') {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, results[0]);\n            }\n        }\n    }\n\n    return {\n        changed: changed,\n        requested: requestedPaths,\n        optimized: optimizedPaths\n    };\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[\"\u001eƒ_refs_length\"] || 0,\n        destNodeRefsLength = destNode[\"\u001eƒ_refs_length\"] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[\"\u001eƒ_ref\" + i];\n        if (ref !== void 0) {\n            ref[\"\u001eƒ_context\"] = destNode;\n            destNode[\"\u001eƒ_ref\" + (destNodeRefsLength + i)] = ref;\n            fromNode[\"\u001eƒ_ref\" + i] = void 0;\n        }\n    }\n    destNode[\"\u001eƒ_refs_length\"] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[\"\u001eƒ_refs_length\"] = void 0;\n    return destNode;\n};\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function unlinkBackReferences(node) {\n    var i = -1,\n        n = node[\"\u001eƒ_refs_length\"] || 0;\n    while (++i < n) {\n        var ref = node[\"\u001eƒ_ref\" + i];\n        if (ref != null) {\n            ref[\"\u001eƒ_context\"] = ref[\"\u001eƒ_ref_index\"] = node[\"\u001eƒ_ref\" + i] = void 0;\n        }\n    }\n    node[\"\u001eƒ_refs_length\"] = void 0;\n    return node;\n};\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function unlinkForwardReference(reference) {\n    var destination = reference[\"\u001eƒ_context\"];\n    if (destination) {\n        var i = (reference[\"\u001eƒ_ref_index\"] || 0) - 1,\n            n = (destination[\"\u001eƒ_refs_length\"] || 0) - 1;\n        while (++i <= n) {\n            destination[\"\u001eƒ_ref\" + i] = destination[\"\u001eƒ_ref\" + (i + 1)];\n        }\n        destination[\"\u001eƒ_refs_length\"] = n;\n        reference[\"\u001eƒ_ref_index\"] = reference[\"\u001eƒ_context\"] = destination = void 0;\n    }\n    return reference;\n};\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[\"\u001eƒ_parent\"] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[\"\u001eƒ_invalidated\"]) {\n        return false;\n    }\n\n    return true;\n}\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar CONTAINER_DOES_NOT_EXIST = 'e';\nvar FalcorJSON = __webpack_require__(2);\nvar getCachePosition = __webpack_require__(10);\nvar InvalidDerefInputError = __webpack_require__(91);\n\nmodule.exports = function deref(json) {\n\n    var seed, f_meta;\n\n    if (!json || 'object' !== typeof json || !(f_meta = json[\"\u001eƒ_meta\"]) || 'object' !== typeof f_meta) {\n        return null;\n    }\n\n    var cacheRoot = this._root.cache;\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = f_meta[\"abs_path\"];\n    var referenceContainer, currentRefPath, i, len;\n\n    if (!absolutePath) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: undefined,\n            _seed: seed\n        });\n    } else if (absolutePath.length === 0) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: cacheRoot,\n            _path: absolutePath,\n            _referenceContainer: true,\n            _seed: seed\n        });\n    }\n\n    var originalRefPath = f_meta[\"deref_to\"];\n    var originalAbsPath = f_meta[\"deref_from\"];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === \"ref\") {\n            validContainer = true;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n            for (i = 0; i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    cacheNode = undefined;\n                    validContainer = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n            referenceContainer = true;\n        }\n\n    if (recycleJSON) {\n        seed = { json: json };\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    return this._clone({\n        _seed: seed,\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer\n    });\n};\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'It is not legal to use the JSON Graph ' + 'format from a bound Model. JSON Graph format' + ' can only be used from a root model.';\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nmodule.exports = createErrorClass('BoundJSONGraphModelError', function () {\n    this.message = MESSAGE;\n});\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'Deref can only be used with a non-primitive object from get, set, or call.';\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidDerefInputError', function () {\n  this.message = MESSAGE;\n});\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'The boundPath of the model is not valid since a value or error was found before the path end.';\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidModelError', function (boundPath, shortedPath) {\n  this.message = MESSAGE;\n  this.boundPath = boundPath;\n  this.shortedPath = shortedPath;\n});\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nmodule.exports = createErrorClass('MaxRetryExceededError', function (maxRetryCount, absolute, relative, optimized) {\n    this.message = '' + 'Exceeded the max retry count (' + maxRetryCount + ') for these paths: \\n' + (absolute && 'absolute: [\\n\\t' + printPaths(absolute) + '\\n]\\n' || '') + (relative && 'relative: [\\n\\t' + printPaths(relative) + '\\n]\\n' || '') + (optimized && 'optimized: [\\n\\t' + printPaths(optimized) + '\\n]\\n' || '');\n});\n\nfunction printPaths(paths) {\n    return paths.map(function (path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n/***/ },\n/* 94 */\n/***/ function(module, exports) {\n\nmodule.exports = String.fromCharCode(30) + 'ƒ_';\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(56);\nvar Subscriber = __webpack_require__(14);\nvar lruCollect = __webpack_require__(54);\nvar FalcorJSON = __webpack_require__(2);\nvar collapse = __webpack_require__(35);\nvar InvalidSourceError = __webpack_require__(53);\nvar MaxRetryExceededError = __webpack_require__(93);\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function (operator, source) {\n    source = new Call(source || this);\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    source.operator = operator;\n    operator.data = operator.data || this.operator.data;\n    operator.errors = operator.errors || this.operator.errors;\n    operator.operation = operator.operation || this.operator.operation;\n    operator.progressive = operator.progressive || this.operator.progressive;\n    operator.maxRetryCount = operator.maxRetryCount || this.operator.maxRetryCount;\n    return source;\n};\n\nCall.prototype.operator = function (subscriber) {\n    return this._subscribe(subscriber);\n};\n\nCall.prototype._subscribe = function (subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n};\n\nCall.prototype._toJSON = function (data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(data, errors || this.operator.errors, 'json', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype._toJSONG = function (data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(data, errors || this.operator.errors, 'jsonGraph', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype.retry = function (maxRetryCount) {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, this.operator.progresive, maxRetryCount), this.source);\n};\n\nCall.prototype.progressively = function () {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, true, this.operator.maxRetryCount), this.source);\n};\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function (source, destination) {\n    return source.subscribe(new CallSubscriber(destination, this.data, this.errors, this.operation, this.progressive));\n};\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.hasValue = false;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: __webpack_require__(72),\n    set: __webpack_require__(84),\n    call: __webpack_require__(71),\n    invalidate: __webpack_require__(82)\n};\n\nCallSubscriber.prototype.next = CallSubscriber.prototype.onNext = function (seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n\n    var seedIsImmutable = progressive && data;\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type][operation](model, args, data, progressive || !model._source, this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            return tryOnError(this, results.error);\n        }\n\n        errors && results.errors && errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n};\n\nCallSubscriber.prototype.error = CallSubscriber.prototype.onError = function (error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n};\n\nCallSubscriber.prototype.complete = CallSubscriber.prototype.onCompleted = function (error) {\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && ((data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return tryOnError(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return tryOnError(this, new MaxRetryExceededError(this.retryCount, this.requested, this.relative, this.missing));\n    }\n\n    this.request = this.model._root.requests[this.type](this.model, this.missing, this.relative, this.fragments).subscribe(this);\n};\n\nCallSubscriber.prototype.dispose = CallSubscriber.prototype.unsubscribe = function () {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 && version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot, modelRoot.expired, cache.$size || 0, modelRoot.maxSize, modelRoot.collectRatio, modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n};\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch (e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction tryOnError(self, error) {\n    try {\n        throw error;\n    } catch (err) {\n        Subscriber.prototype.onError.call(self, err);\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue,\n        nodeValue,\n        key,\n        keys = Object.keys(node),\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === \"\u001eƒ_meta\") {\n            dest[\"\u001eƒ_meta\"] = node[\"\u001eƒ_meta\"];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (!nodeValue || typeof nodeValue !== 'object') {\n                    if (destValue === undefined) {\n                        dest[key] = nodeValue;\n                    }\n                } else if (destValue === undefined) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(56);\nvar Request = __webpack_require__(97);\nvar Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\nvar ImmediateScheduler = __webpack_require__(57);\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = env.jsonGraph;\n        request.requested.push(requested);\n        request.optimized.push(optimized);\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, callArgs) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = callArgs;\n        request.boundPath = model._path;\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(this, model._source, model._scheduler, requested, optimized);\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function (destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] = new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar Subject = __webpack_require__(98);\nvar Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\nvar InvalidSourceError = __webpack_require__(53);\n\nvar setJSONGraphs = __webpack_require__(19);\nvar setPathValues = __webpack_require__(31);\nvar invalidatePaths = __webpack_require__(29);\n\nvar toPaths = __webpack_require__(38);\nvar toCollapseMap = __webpack_require__(36);\nvar toCollapseTrees = __webpack_require__(37);\nvar hasIntersection = __webpack_require__(65);\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.tree = {};\n    this.paths = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next = Request.prototype.onNext = function (envelopes) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    var env = envelopes,\n        envelopeIndex = 0,\n        envelopeCount = 0;\n\n    if (isArray(envelopes)) {\n        if ((envelopeCount = envelopes.length) <= 0) {\n            return;\n        }\n        env = envelopes[0];\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    var boundPath = this.boundPath;\n\n    do {\n\n        var jsonGraph = env.jsonGraph;\n        var requested = this.requested;\n        var modelRoot = queue.modelRoot;\n        var invalidated = env.invalidated;\n        var paths = env.paths || this.paths;\n\n        // Run invalidations first.\n        if (invalidated && invalidated.length) {\n            invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n        }\n\n        if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n            paths = setJSONGraphs({ _root: modelRoot }, [{ paths: paths, jsonGraph: jsonGraph }], modelRoot.errorSelector, modelRoot.comparator, false)[0];\n        }\n    } while (++envelopeIndex < envelopeCount && (env = envelopes[envelopeIndex]));\n\n    this.observers.slice(0).forEach(function (observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] || filterPathsBoundTo(boundPath, paths)\n        });\n    });\n};\n\nRequest.prototype.error = Request.prototype.onError = function (error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    error = error || {};\n\n    // Converts errors to object we can insert into the cache.\n    error = !(error instanceof Error) ?\n    // if it's $type error, use it raw\n    error.$type === \"error\" && error ||\n    // Otherwise make it an error\n    { $type: \"error\", value: error } :\n    // If it's instanceof Error, pluck error.message\n    { $type: \"error\", value: { message: error.message } };\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(this.requested.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {}))).map(function (path) {\n        return { path: path, value: error };\n    });\n\n    if (errorPathValues.length) {\n        setPathValues({ _root: modelRoot, _path: [] }, errorPathValues, modelRoot.errorSelector, modelRoot.comparator, false);\n    }\n\n    Subject.prototype.onError.call(this, error);\n};\n\nRequest.prototype.complete = Request.prototype.onCompleted = function () {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n};\n\nRequest.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n};\n\nRequest.prototype.dispose = Request.prototype.unsubscribe = function () {\n    this.tree = {};\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.boundPath = null;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n};\n\nRequest.prototype.connect = function () {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n};\n\nRequest.prototype.batch = function (requested, optimized, requestedComplements, optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.tree, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            return this;\n        }\n        return null;\n    }\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    return this;\n};\n\nfunction flush() {\n\n    this.active = true;\n\n    var obs,\n        paths = this.paths = toPaths(this.tree = toCollapseTrees(this.optimized.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {})));\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = {};\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\n\nfunction findIntersections(tree, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = -1;\n    var intersectionIndex = -1;\n    var optTotal = optimized.length;\n    var reqTotal = requested.length - 1;\n\n    while (++index < optTotal) {\n        var path = optimized[index];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n        if (subTree && hasIntersection(subTree, path, 0, pathLen)) {\n            optimizedIntersection[++intersectionIndex] = path;\n            requestedIntersection[intersectionIndex] = requested[index < reqTotal ? index : reqTotal];\n        } else {\n            optimizedComplements[++complementIndex] = path;\n            requestedComplements[complementIndex] = requested[index < reqTotal ? index : reqTotal];\n        }\n    }\n\n    return ~intersectionIndex;\n}\n\nfunction filterPathsBoundTo(boundPath, paths) {\n\n    var boundLength;\n\n    if (!boundPath || (boundLength = boundPath.length) === 0) {\n        return paths;\n    }\n\n    var filtered = [],\n        filteredIndex = -1,\n        keyIndex;\n    var path,\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    outer: while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        if (path.length > boundLength) {\n            keyIndex = 0;\n            do {\n                if (path[keyIndex] !== boundPath[keyIndex]) {\n                    continue outer;\n                }\n            } while (++keyIndex < boundLength);\n            filtered[++filteredIndex] = path.slice(boundLength);\n        }\n    }\n\n    return filtered;\n}\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\n// Unused\n// Subject.prototype.onNext = function(value) {\n//     this.observers.slice(0).forEach(function(observer) {\n//         observer.onNext(value);\n//     });\n// }\n\nSubject.prototype.onError = function (error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onError(error);\n    });\n};\n\nSubject.prototype.onCompleted = function () {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onCompleted();\n    });\n};\n\nSubject.prototype.subscribe = function (subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n};\n\nSubject.prototype.dispose = Subject.prototype.unsubscribe = function () {\n    this.observers = [];\n};\n\n/***/ },\n/* 99 */\n/***/ function(module, exports) {\n\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose = TimerDisposable.prototype.unsubscribe = function () {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\nmodule.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isInternal = __webpack_require__(32);\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (isInternal(key)) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return 'branch';\n    }\n    return type;\n};\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (isArray(pathValue.path) || typeof pathValue.path === 'string');\n};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(106);\n\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = __webpack_require__(107);\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34), __webpack_require__(108)(module)))\n\n/***/ },\n/* 107 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n/***/ },\n/* 108 */\n/***/ function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(63);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// falcor.all.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 109);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap af7425e96c02772a101c","var now = require('../support/now');\nvar $now = require('../values/expires-now');\nvar $never = require('../values/expires-never');\n\nmodule.exports = function isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/isExpired.js","var splice = require('./../lru/splice');\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[f_invalidated]) {\n        node[f_invalidated] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/expireNode.js","function FalcorJSON(f_meta) {\n    if (!f_meta) {\n        this[f_meta_data] = {};\n    } else if (!(this[f_meta_data] = f_meta[f_meta_data])) {\n        this[f_meta_data] = f_meta;\n    }\n}\n\nObject.defineProperties(FalcorJSON.prototype, [\n        'concat', 'copyWithin', 'entries', 'every', 'fill', 'filter',\n        'find', 'findIndex', 'forEach', 'includes', 'indexOf', 'join',\n        'keys', 'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight',\n        'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'unshift', 'values'\n    ]\n    .reduce(function (descriptors, name) {\n        descriptors[name] = {\n            writable: true, enumerable: false,\n            value: bindArrayMethod(Array.prototype[name])\n        };\n        return descriptors;\n    }, {\n        toJSON: { enumerable: false, value: toJSON },\n        toProps: { enumerable: false, value: toProps },\n        toString: { enumerable: false, value: toString },\n        $__hash: {\n            enumerable: false,\n            get: function() {\n                var f_meta = this[f_meta_data];\n                return f_meta && f_meta['$code'] || '';\n            }\n        },\n        $__path: {\n            enumerable: false,\n            get: function() {\n                var f_meta = this[f_meta_data];\n                return f_meta && f_meta[f_meta_abs_path] || [];\n            }\n        },\n        $__version: {\n            enumerable: false,\n            get: function() {\n                var f_meta = this[f_meta_data];\n                return f_meta && f_meta[f_meta_version] || 0;\n            }\n        }\n    })\n);\n\nfunction bindArrayMethod(fn) {\n    return (bound.fn = fn) && bound;\n    function bound() {\n        return bound.fn.apply(this, arguments);\n    }\n}\n\nvar isArray = Array.isArray;\nvar typeofObject = 'object';\nvar typeofString = 'string';\n\nfunction getInst(inst) {\n    var typeofInst = typeof inst;\n    var argsLen = arguments.length;\n    if (argsLen === 0) {\n        inst = this;\n    } else if (typeofInst !== typeofString) {\n        if (!inst || typeofInst !== typeofObject) {\n            return inst;\n        }\n    } else if (argsLen !== 1) {\n        return inst;\n    } else {\n        inst = this;\n    }\n    return inst === global ? undefined : inst;\n}\n\nfunction toJSON() {\n    return serialize(getInst.apply(this, arguments), toJSON);\n}\n\nfunction toString(includeMetadata) {\n    return JSON.stringify(serialize(\n        getInst.call(this, this),\n        serialize, includeMetadata === true\n    ));\n}\n\nfunction toProps(inst) {\n\n    inst = getInst.apply(this, arguments);\n\n    var f_meta_inst, f_meta_json, version = 0;\n    var json = serialize(inst, toProps, true, true);\n\n    if (inst && (f_meta_inst = inst[f_meta_data])) {\n        version = f_meta_inst[f_meta_version];\n    }\n\n    if (!(!json || typeof json !== typeofObject)) {\n        if (f_meta_json = json[f_meta_data]) {\n            f_meta_json[f_meta_version] = version;\n        }\n    }\n\n    return json;\n}\n\nfunction serialize(inst, serializer, includeMetadata, createWithProto) {\n\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    }\n\n    var count, total, f_meta, keys, key, xs, ys;\n\n    if (isArray(inst)) {\n        xs = inst;\n    } else {\n\n        count = -1;\n        keys = Object.keys(inst);\n        total = keys.length;\n        xs = {};\n\n        if (createWithProto) {\n            xs.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (includeMetadata && (f_meta = inst[f_meta_data])) {\n\n            var $code = f_meta['$code'];\n            var abs_path = f_meta[f_meta_abs_path];\n            var deref_to = f_meta[f_meta_deref_to];\n            var deref_from = f_meta[f_meta_deref_from];\n\n            f_meta = {};\n            $code && (f_meta['$code'] = $code);\n            abs_path && (f_meta[f_meta_abs_path] = abs_path);\n            deref_to && (f_meta[f_meta_deref_to] = deref_to);\n            deref_from && (f_meta[f_meta_deref_from] = deref_from);\n\n            xs[f_meta_data] = f_meta;\n\n            if (createWithProto) {\n                ys = {};\n                ys.__proto__ = xs;\n                xs = ys;\n            }\n        }\n\n        while (++count < total) {\n            if ((key = keys[count]) !== f_meta_data) {\n                xs[key] = serializer(inst[key], serializer, includeMetadata);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/FalcorJSON.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = '`null` is not allowed in branch key positions.';\n\n/**\n * Do not allow null in path.\n */\nmodule.exports = createErrorClass('NullInPathError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NullInPathError.js","module.exports = createErrorClass;\n\nfunction createErrorClass(name, init) {\n    function E(message) {\n        this.message = message;\n        init && init.apply(this, arguments);\n        if (!Error.captureStackTrace) {\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    E.prototype = Object.create(Error.prototype);\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    E.is = function(x) { return x.name === name; };\n    return E;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/createErrorClass.js","var objTypeof = 'object';\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isObject.js","module.exports = { $type: 'atom' };\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/support/materializedAtom.js","var isInternal = require('../internal/isInternal');\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key, keys = Object.keys(node),\n        json = {}, index = -1, length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (isInternal(key)) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/clone.js","module.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[f_refs_length] || 0;\n    to[f_ref + backRefs] = from;\n    to[f_refs_length] = backRefs + 1;\n\n    // create a hard reference\n    from[f_ref_index] = backRefs;\n    from[f_context] = to;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/createHardlink.js","var isObject = require('./../support/isObject');\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getSize.js","/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type, depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === $ref) {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCachePosition.js","var removeNode = require('./removeNode');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child[f_parent];\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child[f_key], lru);\n        } else if (child[f_version] !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateNodeAncestors.js","var createErrorClass = require('./createErrorClass');\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidKeySetError', function(path, keysOrRanges) {\n    this.mesage = '' +\n        'The KeySet ' + JSON.stringify(keysOrRanges) +\n        ' in path ' + JSON.stringify(path) + ' contains a KeySet. ' +\n        'Keysets can only contain Keys or Ranges';\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidKeySetError.js","var EXPIRES_NEVER = require('./../values/expires-never');\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root[f_head];\n\n    // Nothing is in the cache.\n    if (!head) {\n        root[f_head] = root[f_tail] = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[f_prev];\n    var next = object[f_next];\n    if (next) {\n        next[f_prev] = prev;\n    }\n    if (prev) {\n        prev[f_next] = next;\n    }\n    object[f_prev] = undefined;\n\n    // Insert into head position\n    root[f_head] = object;\n    object[f_next] = head;\n    head[f_prev] = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root[f_tail]) {\n        root[f_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/promote.js","var Subscription = require('./Subscription');\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' ||\n             typeof parent === 'function' ||\n        typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        }\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next =\nSubscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n}\n\nSubscriber.prototype.error =\nSubscriber.prototype.onError = function onError(error) {\n    var signaled = false;\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            signaled = true;\n            dest.onError(error);\n        } else if (dest.error) {\n            signaled = true;\n            dest.error(error);\n        }\n        this.dispose();\n    }\n    if (!signaled) {\n        throw error;\n    }\n}\n\nSubscriber.prototype.complete =\nSubscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n}\n\nSubscriber.prototype.dispose =\nSubscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscriber.js","module.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function(subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n}\n\nSubscription.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n}\n\nSubscription.prototype.dispose =\nSubscription.prototype.unsubscribe = function () {\n    var subscription, subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) &&\n            subscription.dispose &&\n            subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscription.js","var isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json,\n                     path, depth, seed, results,\n                     requestedPath, requestedLength,\n                     optimizedPath, optimizedLength,\n                     fromReference, modelRoot, expired, expireImmediate,\n                     branchSelector, boxValues, materialized, reportMissing,\n                     treatErrorsAsValues, onValue, onMissing, onMaterialize) {\n\n    var reportMaterialized = reportMissing;\n\n    if (type) {\n        if (isExpired(node, expireImmediate)) {\n            if (!node[f_invalidated]) {\n                expireNode(node, expired, modelRoot);\n            }\n        } else {\n            lruPromote(modelRoot, node);\n            if (node.value === undefined) {\n                reportMissing = false;\n                reportMaterialized = materialized;\n            } else {\n                if (seed) {\n                    if (fromReference) {\n                        requestedPath[depth] = null;\n                    }\n                    return onValue(node, type, depth, seed, results,\n                                   requestedPath, optimizedPath, optimizedLength,\n                                   fromReference, boxValues, materialized, treatErrorsAsValues);\n                }\n                return undefined;\n            }\n        }\n    }\n\n    if (materialized) {\n        seed && (results.hasValue = true);\n    } else if (!reportMaterialized) {\n        return undefined;\n    }\n\n    return onMissing(path, depth, results,\n                     requestedPath, requestedLength, fromReference,\n                     optimizedPath, optimizedLength, reportMissing,\n                     materialized, json, branchSelector,\n                     boxValues, onMaterialize);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onValueType.js","var getCachePosition = require('./getCachePosition');\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[f_parent] === undefined || node[f_invalidated]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getBoundCacheNode.js","var removeNode = require('./removeNode');\nvar isInternalKey = require('../support/isInternalKey');\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (!isInternalKey(key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/removeNodeAndDescendants.js","var arr = new Array(5);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar mergeJSONGraphNode = require('../mergeJSONGraphNode');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n    var initialVersion = cache[f_version];\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, expireImmediate\n            );\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    var newVersion = cache[f_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (initialVersion !== newVersion) {\n        modelRoot.version = version;\n        rootChangeHandler && rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths, initialVersion !== newVersion];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(\n                root, parent, node, messageRoot, messageParent, message,\n                key, branch, true, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n            node = results[0];\n            optimizedPath = results[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(\n            parent, node, message, key, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setJSONGraphs.js","var arr = new Array(3);\nvar isArray = Array.isArray;\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar getCachePosition = require('../getCachePosition');\nvar isInternalKey = require('../../support/isInternalKey');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar mergeValueOrInsertBranch = require('../mergeValueOrInsertBranch');\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[f_parent] || cache;\n    var initialVersion = cache[f_version];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, modelRoot, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[f_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (initialVersion !== newVersion) {\n        modelRoot.version = version;\n        rootChangeHandler && rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths, initialVersion !== newVersion];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                        version, expired, lru, comparator, errorSelector, expireImmediate\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[f_context];\n\n        if (node != null) {\n            parent = node[f_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[f_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (type === void 0) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = 'length';\n        }\n        for (var key in pathMap) {\n            if (isInternalKey(key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathMaps.js","/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nmodule.exports = isInternalKey;\n\nvar isInternal = require('../internal/isInternal');\n\nfunction isInternalKey(key) {\n    return key && key[0] === '$' || isInternal(key);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isInternalKey.js","module.exports = flatBufferToPaths;\n\nfunction flatBufferToPaths(seed, paths, path) {\n\n    path = path || [];\n    paths = paths || [];\n\n    if (!seed) {\n        return paths;\n    }\n\n    var leaf = [];\n    var keys = seed['$keys'];\n    var keysLen = keys.length;\n    var keysIndex = -1, key, len;\n\n    while (++keysIndex < keysLen) {\n\n        var next = seed[keysIndex];\n        var keyset = keys[keysIndex];\n\n        if (!next || typeof next !== 'object') {\n            leaf.push(keyset);\n        } else {\n            flatBufferToPaths(next, paths, path.concat([keyset]));\n        }\n    }\n\n    if (leaf.length === 1) {\n        paths.push(path.concat(leaf));\n    } else if (leaf.length > 1) {\n        paths.push(path.concat([leaf]));\n    }\n\n    return paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/flatBufferToPaths.js","module.exports = getHashCode;\n\nfunction getHashCode(str) {\n    var hash = 5381, i = str.length;\n    while (i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/getHashCode.js","var isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/iterateKeySet.js","module.exports = require('./getJSON');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/index.js","module.exports = require('./getJSONGraph');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/index.js","module.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key, depth = 0, prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/inlineValue.js","var isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, json, branchSelector,\n                   boxValues, onMaterialize) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        return onMaterialize(json, mPath, missDepth, missTotal, branchSelector, boxValues);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if ('object' !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if ('number' !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMissing.js","var arr = new Array(2);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\nvar getSize = require('../../support/getSize');\nvar createHardlink = require('../createHardlink');\nvar getBoundCacheNode = require('../getBoundCacheNode');\nvar updateNodeAncestors = require('../updateNodeAncestors');\nvar removeNodeAndDescendants = require('../removeNodeAndDescendants');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return;\n    }\n\n    var parent = node[f_parent] || cache;\n    var initialVersion = cache[f_version];\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    var newVersion = cache[f_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        arr = invalidateNode(\n            root, parent, node,\n            key, branch, false, version,\n            expired, lru, expireImmediate\n        );\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru, expireImmediate\n                );\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[f_context];\n\n    if (node != null) {\n        parent = node[f_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(\n                root, parent, node,\n                key, branch, true, version,\n                expired, lru, expireImmediate\n            );\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, branch, reference, version,\n    expired, lru, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        arr = invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error('`null` is not allowed in branch key positions.');\n        } else if (node) {\n            key = node[f_key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathSets.js","var lruSplice = require('../lru/splice');\nvar unlinkBackReferences = require('./unlinkBackReferences');\nvar unlinkForwardReference = require('./unlinkForwardReference');\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node[f_parent] = void 0;\n        return true;\n    }\n    return false;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/removeNode.js","var arr = new Array(3);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar getCachePosition = require('../getCachePosition');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\nvar mergeValueOrInsertBranch = require('../mergeValueOrInsertBranch');\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[f_parent] || cache;\n    var initialVersion = cache[f_version];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, modelRoot, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[f_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (initialVersion !== newVersion) {\n        modelRoot.version = version;\n        rootChangeHandler && rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths, initialVersion !== newVersion];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[f_context];\n\n        if (node != null) {\n            parent = node[f_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[f_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathValues.js","/**\n * Determined if the key passed in is an f_ internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nvar f_ = require('./f_');\nvar regexp = new RegExp('^' + f_, 'i', 'g');\n\nmodule.exports = regexp.test.bind(regexp);\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/isInternal.js","module.exports = 0;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-now.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 34\n// module chunks = 0","var toPaths = require('./toPaths');\nvar toCollapseMap = require('./toCollapseMap');\nvar toCollapseTrees = require('./toCollapseTrees');\n\nmodule.exports = function collapse(paths) {\n    return toPaths(toCollapseTrees(toCollapseMap(paths)));\n};\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/collapse.js","var isArray = Array.isArray;\nvar flatBufferToPaths = require('./flatBufferToPaths');\n\nmodule.exports = toCollapseMap;\n\nfunction toCollapseMap(paths, collapseMap) {\n    if (!paths) { return collapseMap; }\n    else if (!isArray(paths)) {\n        if (isArray(paths.$keys)) {\n            paths = flatBufferToPaths(paths);\n        }\n    }\n    return paths.reduce(function(acc, path) {\n        var len = path.length;\n        if (!acc[len]) {\n            acc[len] = [];\n        }\n        acc[len].push(path);\n        return acc;\n    }, collapseMap || {});\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toCollapseMap.js","var toTree = require('./toTree');\n\nmodule.exports = toCollapseTrees;\n\nfunction toCollapseTrees(collapseMap, collapseTrees) {\n    return Object.keys(collapseMap).reduce(function(collapseTrees, collapseKey) {\n        collapseTrees[collapseKey] = toTree(\n            collapseMap[collapseKey],\n            collapseTrees[collapseKey]\n        );\n        return collapseTrees;\n    }, collapseTrees || {});\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toCollapseTrees.js","var isArray = Array.isArray;\nvar typeOfObject = 'object';\nvar typeOfString = 'string';\nvar typeOfNumber = 'number';\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\nvar getHashCode = require('./getHashCode');\nvar materializedAtom = require('./support/materializedAtom');\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var subs = Object.create(null);\n    var code = '' + getHashCode('' + depth);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = '' + getHashCode(code + key + subCode);\n\n            isSafeNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = '' + getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {'from':1, 'to':6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to '==='.\n        if (to - from <= keyCount) {\n            return { from: from, to: to };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === materializedAtom) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toPaths.js","var isArray = Array.isArray;\nvar walkPathAndBuildOutput = require('./walkPath');\nvar walkFlatBufferAndBuildOutput = require('./walkFlatBuffer');\nvar getBoundCacheNode = require('../../getBoundCacheNode');\nvar InvalidModelError = require('../../../errors/InvalidModelError');\nvar toFlatBuffer = require('@graphistry/falcor-path-utils/lib/toFlatBuffer');\nvar computeFlatBufferHash = require('@graphistry/falcor-path-utils/lib/computeFlatBufferHash');\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        results = { data: seed },\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        materialized = seed && model._materialized,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    var arr, path, pathsIndex = 0, pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n        if (recycleJSON) {\n            isFlatBuffer = true;\n            if (pathsCount > 1 || isArray(paths[0])) {\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n            arr = walkFlatBufferAndBuildOutput(cache, node, json, paths[0], 0, seed, results,\n                                               requestedPath, optimizedPath, optimizedLength,\n                                               /* fromReference = */ false, referenceContainer,\n                                               modelRoot, expired, expireImmediate, branchSelector,\n                                               boxValues, materialized, hasDataSource,\n                                               treatErrorsAsValues, allowFromWhenceYouCame);\n            json = arr[0];\n            arr[0] = undefined;\n            arr[1] = undefined;\n        } else {\n            do {\n                path = paths[pathsIndex];\n                requestedLength = path.length;\n                json = walkPathAndBuildOutput(cache, node, json, path,\n                                           /* depth = */ 0, seed, results,\n                                              requestedPath, requestedLength,\n                                              optimizedPath, optimizedLength,\n                                              /* fromReference = */ false, referenceContainer,\n                                              modelRoot, expired, expireImmediate, branchSelector,\n                                              boxValues, materialized, hasDataSource,\n                                              treatErrorsAsValues, allowFromWhenceYouCame);\n            } while (++pathsIndex < pathsCount)\n        }\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getJSON.js","var arr = new Array(3);\nvar promote = require('../../../lru/promote');\nvar isExpired = require('../../isExpired');\nvar createHardlink = require('../../createHardlink');\nvar CircularReferenceError = require('../../../errors/CircularReferenceError');\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[f_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getReferenceTarget.js","var clone = require('../../clone');\nvar onError = require('./onError');\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results,\n                     requestedPath, optimizedPath, optimizedLength,\n                     fromReference, boxValues, materialized,\n                     treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath,\n                       fromReference, boxValues);\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    return !boxValues ? node.value : clone(node);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onValue.js","var walkPathAndBuildOutput = require('./walkPath');\nvar BoundJSONGraphModelError = require('../../../errors/BoundJSONGraphModelError');\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node, cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n\n        results = { data: seed },\n        pathsIndex = -1, pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n                            /* depth = */ 0, seed, results,\n                               requestedPath, requestedLength,\n                               optimizedPath, optimizedLength,\n              /* fromReference = */ false, modelRoot, expired, expireImmediate,\n                               boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args =\n    results.relative = results.requested;\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getJSONGraph.js","var isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = require('../clone');\nvar FalcorJSON = require('./json/FalcorJSON');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMaterialize;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterialize(json, path, depth, length,\n                       branchSelector, boxValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (depth === length) {\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta;\n\n    var nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0;\n\n    keyset = path[depth];\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_version] = 0;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[f_meta_data])) {\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_version] = 0;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n    } else {\n        f_meta[f_meta_version] = 0;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            // insert the materialized branch\n            json[nextKey] = onMaterialize(\n                json[nextKey], path,\n                nextDepth, length,\n                branchSelector,\n                boxValues\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMaterialize.js","var isArray = Array.isArray;\nvar isPathValue = require('../support/isPathValue');\nvar isJSONEnvelope = require('../support/isJSONEnvelope');\nvar isJSONGraphEnvelope = require('../support/isJSONGraphEnvelope');\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = 'PathValues';\n        } else if (isPathValue(arg)) {\n            argType = 'PathValues';\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = 'JSONGraphs';\n        } else if (isJSONEnvelope(arg)) {\n            argType = 'PathMaps';\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/groupCacheArguments.js","module.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node[f_key] = key;\n    node[f_parent] = parent;\n\n    if (version !== undefined) {\n        node[f_version] = version;\n    }\n    if (!node[f_abs_path]) {\n        node[f_abs_path] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/insertNode.js","var isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\nvar getSize = require('../../support/getSize');\nvar createHardlink = require('../createHardlink');\nvar getBoundCacheNode = require('../getBoundCacheNode');\nvar isInternalKey = require('../../support/isInternalKey');\nvar updateNodeAncestors = require('../updateNodeAncestors');\nvar removeNodeAndDescendants = require('../removeNodeAndDescendants');\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return;\n    }\n\n    var parent = node[f_parent] || cache;\n    var initialVersion = cache[f_version];\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, expireImmediate\n        );\n    }\n\n    var newVersion = cache[f_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(\n    pathMap, depth, root, parent, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (!isInternalKey(key)) {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            var results = invalidateNode(\n                root, parent, node,\n                key, child, branch, false, version, expired,\n                lru, comparator, expireImmediate\n            );\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, expireImmediate\n                    );\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(\n    value, root, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[f_context];\n\n    if (node != null) {\n        parent = node[f_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, value, branch, true, version,\n                expired, lru, comparator, expireImmediate\n            );\n            node = results[0];\n            if (!node || typeof node !== 'object') {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, value, branch, reference, version,\n    expired, lru, comparator, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(\n            value, root, node, version, expired,\n            lru, comparator, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node && typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error('`null` is not allowed in branch key positions.');\n        } else if (node) {\n            key = node[f_key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathMaps.js","var $now = require('../values/expires-now');\nvar getType = require('../support/getType');\nvar getSize = require('../support/getSize');\nvar getTimestamp = require('../support/getTimestamp');\n\nvar wrapNode = require('./wrapNode');\nvar isExpired = require('./isExpired');\nvar expireNode = require('./expireNode');\nvar insertNode = require('./insertNode');\nvar replaceNode = require('./replaceNode');\nvar reconstructPath = require('./reconstructPath');\nvar updateNodeAncestors = require('./updateNodeAncestors');\nvar removeNodeAndDescendants = require('./removeNodeAndDescendants');\n\nmodule.exports = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge if it expires immediately\n             */\n            true)) {\n            expireNode(node, expired, lru);\n            type = node.$expires === $now ? type : 'expired';\n        }\n        if ((type && type !== $ref) || (!node || typeof node !== 'object')) {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var isDistinct = true;\n        var mType = getType(message);\n\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        if (comparator) {\n            isDistinct = !comparator(\n                node, message, optimizedPath.slice(0, optimizedPath.index)\n            );\n        } else if (!mType) {\n            isDistinct = !node || node.value !== message;\n        } else {\n            isDistinct = !type || ((\n                // Comparing either Number or undefined to undefined always results in false.\n                getTimestamp(message) < getTimestamp(node)) === false) || !(\n                // They're the same if the following fields are the same.\n                type !== mType ||\n                node.value !== message.value ||\n                node.$expires !== message.$expires);\n        }\n\n        if (isDistinct) {\n\n            if (errorSelector && mType === $error) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            var sizeOffset = getSize(node) - getSize(message =\n                wrapNode(message, mType, mType ? message.value : message));\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeValueOrInsertBranch.js","/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/reconstructPath.js","var transferBackReferences = require('./transferBackReferences');\nvar removeNodeAndDescendants = require('./removeNodeAndDescendants');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/replaceNode.js","module.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        if (node && node[f_version] !== version) {\n            node[f_version] = version;\n            stack[count++] = node[f_parent];\n            var i = -1;\n            var n = node[f_refs_length] || 0;\n            while (++i < n) {\n                stack[count++] = node[f_ref + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateBackReferenceVersions.js","var isArray = Array.isArray;\nvar now = require('../support/now');\nvar clone = require('./../support/clone');\nvar getSize = require('./../support/getSize');\nvar getExpires = require('../support/getExpires');\nvar expiresNow = require('../values/expires-now');\n\nvar atomSize = 50;\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[f_wrapped_value];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[f_prev] = undefined;\n        node[f_next] = undefined;\n        node[f_wrapped_value] = modelCreated || false;\n    } else {\n        node = { $type: $atom, value: value };\n        node[f_prev] = undefined;\n        node[f_next] = undefined;\n        node[f_wrapped_value] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case 'object':\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case 'string':\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === 'number' && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/wrapNode.js","var createErrorClass = require('./createErrorClass');\n\nmodule.exports = createErrorClass('CircularReferenceError', function(referencePath) {\n    this.message = 'Encountered circular reference ' + JSON.stringify(referencePath);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/CircularReferenceError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'An exception was thrown when making a request';\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidSourceError', function(error) {\n    this.message = MESSAGE + ':\\n\\t' + error;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidSourceError.js","var removeNode = require('../cache/removeNode');\nvar updateNodeAncestors = require('../cache/updateNodeAncestors');\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== 'number') {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === 'number';\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node[f_parent]) {  // eslint-disable-line no-cond-assign\n            removeNode(node, parent, node[f_key], lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru[f_tail];\n        node = prev;\n        while ((total >= targetSize) && node) {\n            prev = prev[f_prev];\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru[f_tail] = lru[f_prev] = node;\n        if (node == null) {\n            lru[f_head] = lru[f_next] = undefined;\n        } else {\n            node[f_next] = undefined;\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/collect.js","module.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object[f_prev];\n    var next = object[f_next];\n    if (next) {\n        next[f_prev] = prev;\n    }\n    if (prev) {\n        prev[f_next] = next;\n    }\n    object[f_prev] = object[f_next] = undefined;\n\n    if (object === root[f_head]) {\n        root[f_head] = next;\n    }\n    if (object === root[f_tail]) {\n        root[f_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/splice.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar $$observable = require('symbol-observable').default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function() {\n    return this;\n}\n\nSource.prototype.operator = function(destination) {\n    return this.subscribe(destination);\n}\n\n// Unused\n// Source.prototype.lift = function(operator, source) {\n//     source = new Source(source || this);\n//     source.operator = operator;\n//     source._promise = this._promise;\n//     return source;\n// }\n\nSource.prototype.subscribe = function(destination, x, y) {\n    return new Subscription([\n        this.operator.call(\n            this.source, !(destination instanceof Subscriber) ?\n                new Subscriber(destination, x, y) : destination)\n    ]);\n}\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function(resolve, reject) {\n            var values = [], rejected = false;\n            source.subscribe({\n                next: function(value) { values[values.length] = value; },\n                error: function(errors) { (rejected = true) && reject(errors); },\n                complete: function() {\n                    !rejected &&\n                    resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Source.js","var empty = {\n    dispose: function() {},\n    unsubscribe: function() {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/ImmediateScheduler.js","var isObject = require('./../support/isObject');\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getTimestamp.js","var isObject = require('./../support/isObject');\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && ('json' in envelope);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONEnvelope.js","var isArray = Array.isArray;\nvar isObject = require('./../support/isObject');\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONGraphEnvelope.js","module.exports = Date.now;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/now.js","module.exports = 1;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-never.js","var Model = require('./Model');\nvar FalcorJSON = require('./cache/get/json/FalcorJSON');\n\nfunction falcor(opts) {\n    if (!(this instanceof Model)) {\n        return new Model(opts);\n    }\n    Model.call(this, opts);\n}\n\nfalcor.prototype = Object.create(Model.prototype);\n\nfalcor['Model'] = Model;\nfalcor['FalcorJSON'] = FalcorJSON;\nfalcor['toProps'] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","var isArray = Array.isArray;\nvar getHashCode = require('./getHashCode');\n\nmodule.exports = computeFlatBufferHash;\n\nfunction computeFlatBufferHash(seed) {\n\n    if (seed === undefined) {\n        return undefined;\n    }\n\n    var code = '';\n    var keys = seed['$keys'];\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    while (++keysIndex < keysLength) {\n\n        var key = keys[keysIndex];\n\n        if (key === null) {\n            code = '' + getHashCode('' + code + 'null');\n            continue;\n        } else if (typeof key === 'object') {\n            key = '[' + key.from + '..' + (key.from + key.length - 1) + ']';\n        }\n\n        var next = computeFlatBufferHash(seed[keysIndex]);\n        if (next === undefined) {\n            code = '' + getHashCode('' + code + key);\n        } else {\n            code = '' + getHashCode('' + code + key + next['$code']);\n        }\n    }\n\n    seed['$code'] = code;\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/computeFlatBufferHash.js","var isArray = Array.isArray;\nvar materializedAtom = require('./support/materializedAtom');\n\nmodule.exports = hasIntersection\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/hasIntersection.js","var isArray = Array.isArray;\nvar nullBuffer = { '$keys': [null], '$keysMap': { 'null': 0 } };\nvar flatBufferToPaths = require('./flatBufferToPaths');\n\nmodule.exports = toFlatBuffer;\n\nfunction toFlatBuffer(paths, seed) {\n    return paths.reduce(function(seed, path) {\n        if (isArray(path)) {\n            return pathToFlatBuffer(seed, path, 0, path.length);\n        } else if (isArray(path.$keys)) {\n            return toFlatBuffer(flatBufferToPaths(path), seed);\n        }\n        return seed;\n    }, seed || {});\n}\n\nfunction pathToFlatBuffer(seed, path, depth, length) {\n\n    if (depth === length) {\n        return undefined;\n    }\n\n    seed = seed || {};\n    var keys = seed['$keys'] || (seed['$keys'] = []);\n    var keysMap = seed['$keysMap'] || (seed['$keysMap'] = {});\n    var keysIndex = -1;\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullBuffer;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = nextKey;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyset = { from: nextKey, length: rangeEnd - nextKey + 1 };\n            nextKey = '[' + nextKey + '..' + rangeEnd + ']';\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = keyset;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toFlatBuffer.js","var isArray = Array.isArray;\nvar materializedAtom = require('./support/materializedAtom');\n\nmodule.exports = toTree;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\n\nfunction toTree(paths, seed) {\n    return paths.reduce(function(seed, path) {\n        return pathToTree(seed, path, 0, path.length, null);\n    }, seed || {});\n};\n\nfunction pathToTree(seed, path, depth, length, value) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    seed = seed || {};\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = value;\n            } else {\n                node = seed[nextKey];\n                next = pathToTree(node, path, nextDepth, length, value);\n                if (!next) {\n                    seed[nextKey] = value;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toTree.js","var Call = require('./request/Call');\nvar ModelRoot = require('./ModelRoot');\nvar FalcorJSON = require('./cache/get/json/FalcorJSON');\nvar ModelDataSourceAdapter = require('./ModelDataSourceAdapter');\nvar TimeoutScheduler = require('./schedulers/TimeoutScheduler');\nvar ImmediateScheduler = require('./schedulers/ImmediateScheduler');\nvar collapse = require('@graphistry/falcor-path-utils/lib/collapse');\n\nvar lruCollect = require('./lru/collect');\nvar getSize = require('./support/getSize');\nvar isObject = require('./support/isObject');\nvar isJSONEnvelope = require('./support/isJSONEnvelope');\nvar getCachePosition = require('./cache/getCachePosition');\nvar isJSONGraphEnvelope = require('./support/isJSONGraphEnvelope');\n\nvar setCache = require('./cache/set/setPathMaps');\nvar setJSONGraphs = require('./cache/set/setJSONGraphs');\n\nvar getJSON = require('./cache/get/json');\nvar getCache = require('./cache/getCache');\nvar getJSONGraph = require('./cache/get/jsonGraph');\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._treatErrorsAsValues = true;\n        this._seed = {};\n        this._seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get(...args) {\n    var seed = this._seed;\n    if (!seed) {\n        seed = {};\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n    return new Call('get', this, args)._toJSON(seed, []);\n}\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set(...args) {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n    return new Call('set', this, args)._toJSON(seed, []);\n}\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload(...args) {\n    return new Call('get', this, args)._toJSON(null, []);\n}\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call(...args) {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n    return new Call('call', this, args)._toJSON(seed, []);\n}\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate(...args) {\n    return new Call('invalidate', this, args)._toJSON(null, null).then();\n}\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.deref = require('./deref');\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = require('./deref/hasValidParentReference');\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return new Call('get', this, [path])\n        ._toJSON({}, [])\n        .lift(function(subscriber) {\n            return this.subscribe({\n                onNext: function(data) {\n                    var depth = -1;\n                    var x = data.json;\n                    var length = path.length;\n                    while (x && !x.$type && ++depth < length) {\n                        x = x[path[depth]];\n                    }\n                    subscriber.onNext(x);\n                },\n                onError: subscriber.onError.bind(subscriber),\n                onCompleted: subscriber.onCompleted.bind(subscriber)\n            })\n        });\n}\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : {path:path,value:value};\n    return new Call('set', this, [value])\n        ._toJSON({}, [])\n        .lift(function(subscriber) {\n            return this.subscribe({\n                onNext: function(data) {\n                    var depth = -1;\n                    var x = data.json;\n                    var length = path.length;\n                    while (x && !x.$type && ++depth < length) {\n                        x = x[path[depth]];\n                    }\n                    subscriber.onNext(x);\n                },\n                onError: subscriber.onError.bind(subscriber),\n                onCompleted: subscriber.onCompleted.bind(subscriber)\n            })\n        });\n}\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n\n    var modelRoot = this._root;\n    var cache = modelRoot.cache;\n\n    if (cacheOrJSONGraphEnvelope !== cache) {\n\n        var options = {\n            _path: [],\n            _boxed: false,\n            _root: modelRoot,\n            _materialized: false,\n            _treatErrorsAsValues: false\n        };\n\n        modelRoot.cache = this._node = {};\n\n        if (typeof cache !== 'undefined') {\n            lruCollect(modelRoot, modelRoot.expired, getSize(cache), 0);\n            if (this._recycleJSON) {\n                this._seed = {};\n                this._seed.__proto__ = FalcorJSON.prototype;\n            }\n        }\n\n        var paths;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            paths = setJSONGraphs(options, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            paths = setCache(options, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            paths = setCache(options, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (paths) {\n            getJSON(options, paths, null, false, false);\n        }\n    } else if (typeof cache === 'undefined') {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache('genreLists[0...10][0...10].boxshot')));\n */\nModel.prototype.getCache = function _getCache() {\n\n    var paths = Array.prototype.slice.call(arguments, 0);\n\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    var env = getJSONGraph({\n        _path: [],\n        _root: this._root,\n        _boxed: this._boxed,\n        _materialized: this._materialized,\n        _treatErrorsAsValues: this._treatErrorsAsValues\n    }, paths, seed).data;\n\n    env.paths = collapse(paths);\n\n    return env;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path) {\n    path = path || [];\n    if (Array.isArray(path) === false) {\n        throw new Error('Model#getVersion must be called with an Array path.');\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === 'delete') {\n                delete clone[key];\n            } else if (key === '_path') {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty('_node')) {\n                    delete clone['_node'];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === 'number') {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: 'Steve',\n                surname: 'McGuire'\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints 'Steve'\nproxyModel.getValue('user.name').\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: 'delete'\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: 'ref',\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[f_abs_path] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = require('./cache/getVersion');\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = require('./cache/set/setPathValues');\nModel.prototype._setPathMaps = require('./cache/set/setPathMaps');\nModel.prototype._setJSONGs = require('./cache/set/setJSONGraphs');\nModel.prototype._setCache = require('./cache/set/setPathMaps');\n\nModel.prototype._invalidatePathValues = require('./cache/invalidate/invalidatePathSets');\nModel.prototype._invalidatePathMaps = require('./cache/invalidate/invalidatePathMaps');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/Model.js","function ModelDataSourceAdapter(model) {\n    this._model = model\n        // .boxValues()\n        ._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [\n        path, args, suffixes\n    ].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelDataSourceAdapter.js","var functionTypeof = 'function';\nvar Requests = require('./request/Queue');\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = -1;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nModelRoot.comparator = function comparator(cacheNode, messageNode) {\n    var cType = cacheNode && cacheNode.$type;\n    var mType = messageNode && messageNode.$type;\n    if (cType) {\n        if (!mType) {\n            return cacheNode.value === messageNode;\n        } else {\n            // They are the same only if the following fields are the same.\n            return !(cType !== mType ||\n                     cacheNode.value !== messageNode.value ||\n                     cacheNode.$expires !== messageNode.$expires);\n        }\n    } else if (mType) {\n        return false;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelRoot.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue =  getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/call/index.js","module.exports = {\n    json: require('./json/getJSON'),\n    jsonGraph: require('./jsonGraph/getJSONGraph')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/index.js","var clone = require('../../clone');\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results,\n                 requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onError.js","var arr = new Array(2);\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = require('./onValue');\nvar FalcorJSON = require('./FalcorJSON');\nvar isExpired = require('../../isExpired');\nvar onValueType = require('../onValueType');\nvar originalOnMissing = require('../onMissing');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar onMaterialize = require('../onMaterializeFlatBuffer');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar getHashCode = require('@graphistry/falcor-path-utils/lib/getHashCode');\nvar flatBufferToPaths = require('@graphistry/falcor-path-utils/lib/flatBufferToPaths');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path,\n                                depth, seed, results, requestedPath,\n                                optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node ||\n        undefined !== (type = node.$type) ||\n        undefined === path) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json,\n                             path, depth, seed, results,\n                             requestedPath, depth,\n                             optimizedPath, optimizedLength,\n                             fromReference, modelRoot, expired, expireImmediate,\n                             branchSelector, boxValues, materialized, hasDataSource,\n                             treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta, f_old_keys, f_new_keys, f_code = '';\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        keys = path['$keys'],\n        nodeAbsPath, jsonAbsPath,\n        nextDepth = depth + 1, rangeEnd,\n        nextJSON, nextReferenceContainer,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[f_abs_path];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[f_meta_data]) {\n\n        nodeAbsPath = node[f_abs_path];\n        jsonAbsPath = f_meta[f_meta_abs_path];\n\n        if (!branchSelector && !(json instanceof FalcorJSON)) {\n            json.__proto__ = {};\n            json.__proto__[f_meta_data] = f_meta;\n            json.__proto__.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (nodeAbsPath !== jsonAbsPath) {\n            f_meta['$code'] = '__incomplete__';\n            f_meta[f_meta_abs_path] = nodeAbsPath;\n            f_meta[f_meta_version] = node[f_version];\n            f_meta[f_meta_deref_to] = refContainerRefPath;\n            f_meta[f_meta_deref_from] = refContainerAbsPath;\n            if (f_old_keys = f_meta[f_meta_keys]) {\n                f_meta[f_meta_keys] = Object.create(null);\n                for (nextKey in f_old_keys) {\n                    if (f_old_keys[nextKey]) {\n                        delete json[nextKey];\n                    }\n                }\n            }\n            arr[0] = json;\n            arr[1] = true;\n            return arr;\n        } else if (!(\n            f_meta[f_meta_version]  !== node[f_version]  ||\n            f_meta['$code']         !== path['$code'])) {\n            results.hasValue = true;\n            arr[0] = json;\n            arr[1] = false;\n            return arr;\n        }\n\n        f_old_keys = f_meta[f_meta_keys];\n        f_meta[f_meta_abs_path] = nodeAbsPath;\n        f_meta[f_meta_version] = node[f_version];\n        f_meta[f_meta_deref_to] = refContainerRefPath;\n        f_meta[f_meta_deref_from] = refContainerAbsPath;\n    }\n\n    f_new_keys = Object.create(null);\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath, nextPathKey,\n        hasMissingPath = false;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = '' + getHashCode('' + f_code + 'null');\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n            nextPathKey = nextKey;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n            nextPathKey = '[' + nextKey + '..' + rangeEnd + ']';\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextPath === undefined) {\n\n                arr = walkPathAndBuildOutput(\n                    root, next, nextJSON, nextPath, nextDepth, seed,\n                    results, requestedPath, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                nextJSON = arr[0];\n                hasMissingPath = hasMissingPath || arr[1];\n\n                if (nextJSON === undefined && !materialized) {\n                    hasMissingPath = true;\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n            else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                    // If the reference is expired, it will be invalidated and\n                    // reported as missing in the next call to walkPath below.\n                    next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                arr = walkPathAndBuildOutput(\n                    root, next, nextJSON, nextPath, nextDepth, seed,\n                    results, requestedPath, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                nextJSON = arr[0];\n                hasMissingPath = hasMissingPath || arr[1];\n\n                if (nextJSON === undefined) {\n                    hasMissingPath = true;\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[f_meta_version] = node[f_version];\n                f_meta[f_meta_abs_path] = node[f_abs_path];\n                f_meta[f_meta_deref_to] = refContainerRefPath;\n                f_meta[f_meta_deref_from] = refContainerAbsPath;\n                json = {};\n                json[f_meta_data] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                } else {\n                    var tmp = json;\n                    json = {};\n                    json.__proto__ = tmp;\n                    tmp = undefined;\n                }\n            }\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && (nextKey in f_old_keys)) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        if (!hasMissingPath) {\n            f_code = '' + getHashCode('' + f_code + nextPathKey +\n                                     (  nextPath && nextPath['$code'] || ''));\n        }\n    }\n\n    if (hasMissingPath) {\n        f_code = '__incomplete__';\n    }\n\n    if (f_meta) {\n        f_meta['$code'] = f_code;\n        f_meta[f_meta_keys] = f_new_keys;\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, json, branchSelector,\n                   boxValues, onMaterialize) {\n\n    if (reportMaterialized) {\n        return onMaterialize(json, path, depth, depth, branchSelector,\n                             boxValues, results, requestedPath, optimizedPath,\n                             optimizedLength, fromReference, reportMissing, onMissing);\n    }\n\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n\n    return paths.forEach(function(restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results,\n                                 requestedPath, requestedLength, fromReference,\n                                 optimizedPath, optimizedLength, reportMissing,\n                                 false, json, branchSelector,\n                                 boxValues, onMaterialize);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkFlatBuffer.js","var isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = require('./onValue');\nvar onMissing = require('../onMissing');\nvar FalcorJSON = require('./FalcorJSON');\nvar onValueType = require('../onValueType');\nvar isExpired = require('../../isExpired');\nvar onMaterialize = require('../onMaterialize');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type, json,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired, expireImmediate,\n                           branchSelector, boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var f_meta;\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        nextJSON, nextReferenceContainer,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return json;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[f_abs_path];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[f_meta_data]) {\n        f_meta[f_meta_version] = node[f_version];\n        f_meta[f_meta_abs_path] = node[f_abs_path];\n        f_meta[f_meta_deref_to] = refContainerRefPath;\n        f_meta[f_meta_deref_from] = refContainerAbsPath;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextDepth === requestedLength) {\n                nextJSON = walkPathAndBuildOutput(\n                    root, next, nextJSON, path, nextDepth, seed,\n                    results, requestedPath, requestedLength, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n                if (nextJSON === undefined && !materialized) {\n                    continue;\n                }\n            }\n            else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                    // If the reference is expired, it will be invalidated and\n                    // reported as missing in the next call to walkPath below.\n                    next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                if (undefined === (nextJSON = walkPathAndBuildOutput(\n                        root, next, nextJSON, path, nextDepth, seed,\n                        results, requestedPath, requestedLength, nextOptimizedPath,\n                        nextOptimizedLength, fromReference, nextReferenceContainer,\n                        modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                        materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                    ))) {\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[f_meta_version] = node[f_version];\n                f_meta[f_meta_abs_path] = node[f_abs_path];\n                f_meta[f_meta_deref_to] = refContainerRefPath;\n                f_meta[f_meta_deref_from] = refContainerAbsPath;\n                json = {};\n                json[f_meta_data] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                if (branchSelector) {\n                    json = branchSelector(json);\n                }\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkPath.js","var arr = new Array(2);\nvar clone = require('../../clone');\nvar inlineValue = require('./inlineValue');\nvar promote = require('../../../lru/promote');\nvar isExpired = require('../../isExpired');\nvar createHardlink = require('../../createHardlink');\nvar CircularReferenceError = require('../../../errors/CircularReferenceError');\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[f_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getReferenceTarget.js","var typeofObject = 'object';\nvar clone = require('../../clone');\nvar inlineValue = require('./inlineValue');\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results,\n                          requestedPath, optimizedPath, optimizedLength,\n                          fromReference, boxValues, materialized) {\n\n    var value = node.value;\n\n    // boxValues always clones the node\n    if (boxValues || !(\n        /**\n         * JSON Graph should always clone:\n         * - refs\n         * - errors\n         * - atoms we didn't create\n         * - atoms we created to wrap Objects\n         **/\n        $ref !== type &&\n        $error !== type &&\n        node[f_wrapped_value] &&\n        typeofObject !== typeof value)) {\n        value = clone(node);\n    }\n\n    results.hasValue = true;\n    inlineValue(value, optimizedPath, optimizedLength, seed);\n    (seed.paths || (seed.paths = [])).push(\n        requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n    );\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/onValue.js","var isArray = Array.isArray;\nvar clone = require('../../clone');\nvar onValue = require('./onValue');\nvar inlineValue = require('./inlineValue');\nvar isExpired = require('../../isExpired');\nvar onValueType = require('../onValueType');\nvar onMaterialize = require('../onMaterialize');\nvar originalOnMissing = require('../onMissing');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, modelRoot, expired, expireImmediate,\n                                boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type, seed,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired, expireImmediate,\n                           undefined, boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            keyset = keysOrRanges[keysetIndex];\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(root, next, modelRoot, seed, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(\n                root, next, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate,\n                boxValues, materialized, hasDataSource, treatErrorsAsValues\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, seed, branchSelector,\n                   boxValues, onMaterialize) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push(\n            (isLeaf = 0 === requestedLength - depth) &&\n                                 // depth + 1 if fromReference === true\n                requestedPath.slice(0, depth + !!fromReference) ||\n                requestedPath.slice(0, depth).concat(path\n                    .slice(depth, requestedLength + !!fromReference))\n        );\n\n        json = inlineValue(isLeaf && clone(materializedAtom) || undefined,\n                           optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results,\n                             requestedPath, requestedLength, fromReference,\n                             optimizedPath, optimizedLength, reportMissing,\n                             !isLeaf && reportMaterialized, json,\n                             branchSelector, true, onMaterialize);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/walkPath.js","var typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = require('../clone');\nvar onValueType = require('./onValueType');\nvar FalcorJSON = require('./json/FalcorJSON');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMaterializeFlatBuffer;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterializeFlatBuffer(json, path, depth, length,\n                                 branchSelector, boxValues, results,\n                                 requestedPath, optimizedPath, optimizedLength,\n                                 fromReference, reportMissing, onMissing) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === path) {\n        onValueType(undefined, undefined, json,\n                    path, depth, undefined, results,\n                    requestedPath, depth, optimizedPath,\n                    optimizedLength, fromReference, undefined, undefined,\n                    false, branchSelector, boxValues, false, reportMissing,\n                    false, undefined, onMissing, undefined);\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta, f_old_keys, f_new_keys;\n\n    var nextKey,\n        keyset, keyIsRange,\n        keys = path['$keys'],\n        nextDepth = depth + 1, rangeEnd,\n        nextOptimizedLength = optimizedLength + 1;\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_version] = 0;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[f_meta_data])) {\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_version] = 0;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n    } else {\n        f_old_keys = f_meta[f_meta_keys];\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n    }\n\n    f_new_keys = {};\n\n    var nextPath;\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && (nextKey in f_old_keys)) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // insert the materialized branch\n            json[nextKey] = onMaterializeFlatBuffer(\n                json[nextKey], nextPath, nextDepth,\n                nextDepth, branchSelector, boxValues, results,\n                requestedPath, optimizedPath, nextOptimizedLength,\n                fromReference, reportMissing, onMissing\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n    }\n\n    f_meta['$code'] = '__incomplete__';\n    f_meta[f_meta_keys] = f_new_keys;\n    if (f_old_keys) {\n        for (nextKey in f_old_keys) {\n            if (f_old_keys[nextKey]) {\n                delete json[nextKey];\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMaterializeFlatBuffer.js","var isInternalKey = require('../support/isInternalKey');\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (key === '$type' || !isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    // only copy objects\n    if (!node || typeof node !== 'object') {\n        return;\n    }\n\n    Object.\n        keys(node).\n        filter(function(key) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return (key === '$type' || !isInternalKey(key)) && node[key] !== undefined;\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === 'object';\n                var isUserCreatedcacheNext = !cacheNext[f_wrapped_value];\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext, key);\n        });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCache.js","var getBoundCacheNode = require('./getBoundCacheNode');\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[f_version];\n    return (version == null) ? -1 : version;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getVersion.js","var groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n    invalidatePathMaps: require('./invalidatePathMaps'),\n    invalidatePathValues: require('./invalidatePathSets')\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    invalidateArgumentGroups(model, groupCacheArguments(args), expireImmediate);\n    return {};\n}\n\nfunction invalidateArgumentGroups(model, xs, expireImmediate) {\n\n    var groupIndex = -1;\n    var groupCount = xs.length;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            if (inputType === 'PathValues') {\n                groupedArgs = groupedArgs.map(pluckPaths);\n            }\n            module.exports['invalidate' + inputType](model, groupedArgs, expireImmediate);\n        }\n    }\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/index.js","var wrapNode = require('./wrapNode');\nvar isExpired = require('./isExpired');\nvar insertNode = require('./insertNode');\nvar expireNode = require('./expireNode');\nvar replaceNode = require('./replaceNode');\nvar getSize = require('../support/getSize');\nvar reconstructPath = require('./reconstructPath');\nvar getTimestamp = require('../support/getTimestamp');\nvar updateNodeAncestors = require('./updateNodeAncestors');\n\nmodule.exports = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // The message and cache are both undefined, return undefined.\n        if (message === undefined) {\n            return message;\n        }\n        // There should not be undefined values. Those should always be\n        // wrapped in an $atom\n        else if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n        // Is the cache node a branch? If so, return the cache branch.\n        else if ((\n            cIsObject = !(!node || typeof node !== 'object')) && (\n            cType = node.$type) === undefined) {\n            // Has the branch been introduced to the cache yet? If not,\n            // give it a parent, key, and absolute path.\n            if (node[f_parent] === undefined) {\n                insertNode(node, parent, key, version, optimizedPath);\n            }\n            return node;\n        }\n    } else if (cIsObject = !(!node || typeof node !== 'object')) {\n        cType = node.$type;\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty, leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node, expireImmediate)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node[f_parent] != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node, expireImmediate) &&\n                        !isExpired(message, expireImmediate) &&\n                        mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(\n                node, message, parent, key, lru, version),\n            parent, key, undefined, optimizedPath\n        );\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n\n        if (mType === $error && errorSelector) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n        }\n\n        if (mType && node === message) {\n            if (node[f_parent] == null) {\n                node = wrapNode(node, cType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            if (!cIsObject || (cType && !isExpired(node, expireImmediate))) {\n\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                if (comparator) {\n                    isDistinct = !comparator(\n                        node, message, optimizedPath.slice(0, optimizedPath.index)\n                    );\n                } else if (!mType) {\n                    isDistinct = !node || node.value !== message;\n                } else {\n                    isDistinct = !cType || ((\n                        // Comparing either Number or undefined to undefined always results in false.\n                        getTimestamp(message) < getTimestamp(node)) === false) || !(\n                        // They're the same if the following fields are the same.\n                        cType !== mType ||\n                        node.value !== message.value ||\n                        node.$expires !== message.$expires);\n                }\n            }\n            if (isDistinct) {\n                message = wrapNode(message, mType, mType ? message.value : message);\n                sizeOffset = getSize(node) - getSize(message);\n                node = replaceNode(node, message, parent, key, lru, version);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n            expireNode(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode(message, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeJSONGraphNode.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\nvar arrayFlatMap = require('../../support/array-flat-map');\nvar groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: require('./setPathMaps'),\n    setPathValues: require('./setPathValues'),\n    setJSONGraphs: require('./setJSONGraphs')\n};\n\nfunction json(model, _args, data, progressive, expireImmediate) {\n\n    var set, get, jsong,\n        changed, relative, optimized,\n        missing, fragments, requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args /*, expireImmediate */);\n\n    if ((relative = set.requested).length) {\n\n        if (!(changed = set.changed) || progressive) {\n            get = getJSON(model, relative, data, progressive, expireImmediate);\n        }\n\n        if (changed) {\n\n            jsong = getJSONGraph({\n                _root: model._root,\n                _boxed: model._boxed, _materialized: true,\n                _treatErrorsAsValues: model._treatErrorsAsValues\n            }, set.optimized, {}, progressive, expireImmediate);\n\n            fragments = jsong.data;\n            missing = fragments.paths;\n            requested = jsong.requested;\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: get && get.error,\n        errors: get && get.errors,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive, expireImmediate) {\n\n    var set, jsong,\n        changed, relative, optimized,\n        missing, fragments, requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args /*, expireImmediate */);\n\n    if ((relative = set.requested).length && (\n         progressive || set.changed)) {\n\n        jsong = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed, _materialized: true,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, set.optimized, data, progressive, expireImmediate);\n\n        fragments = jsong.data;\n        missing = fragments.paths;\n        requested = jsong.requested;\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: jsong && jsong.error,\n        hasValue: jsong && jsong.hasValue\n    };\n}\n\nfunction setGroupsIntoCache(model, xs /*, expireImmediate */) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var selector = modelRoot.errorSelector;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports['set' + inputType];\n            var results = operation(model, groupedArgs, selector, null, false);\n            changed = changed || results[2];\n            optimizedPaths.push.apply(optimizedPaths, results[1]);\n            if (inputType === 'PathValues') {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === 'JSONGraphs') {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, results[0]);\n            }\n        }\n    }\n\n    return {\n        changed: changed,\n        requested: requestedPaths,\n        optimized: optimizedPaths\n    };\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/index.js","module.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[f_refs_length] || 0,\n        destNodeRefsLength = destNode[f_refs_length] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[f_ref + i];\n        if (ref !== void 0) {\n            ref[f_context] = destNode;\n            destNode[f_ref + (destNodeRefsLength + i)] = ref;\n            fromNode[f_ref + i] = void 0;\n        }\n    }\n    destNode[f_refs_length] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[f_refs_length] = void 0;\n    return destNode;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/transferBackReferences.js","module.exports = function unlinkBackReferences(node) {\n    var i = -1, n = node[f_refs_length] || 0;\n    while (++i < n) {\n        var ref = node[f_ref + i];\n        if (ref != null) {\n            ref[f_context] = ref[f_ref_index] = node[f_ref + i] = void 0;\n        }\n    }\n    node[f_refs_length] = void 0;\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkBackReferences.js","module.exports = function unlinkForwardReference(reference) {\n    var destination = reference[f_context];\n    if (destination) {\n        var i = (reference[f_ref_index] || 0) - 1,\n            n = (destination[f_refs_length] || 0) - 1;\n        while (++i <= n) {\n            destination[f_ref + i] = destination[f_ref + (i + 1)];\n        }\n        destination[f_refs_length] = n;\n        reference[f_ref_index] = reference[f_context] = destination = void 0;\n    }\n    return reference;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkForwardReference.js","module.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[f_parent] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[f_invalidated]) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/hasValidParentReference.js","var CONTAINER_DOES_NOT_EXIST = 'e';\nvar FalcorJSON = require('../cache/get/json/FalcorJSON');\nvar getCachePosition = require('../cache/getCachePosition');\nvar InvalidDerefInputError = require('../errors/InvalidDerefInputError');\n\nmodule.exports = function deref(json) {\n\n    var seed, f_meta;\n\n    if (!json || 'object' !== typeof json || !(\n        f_meta = json[f_meta_data]) || 'object' !== typeof f_meta) {\n        return null;\n    }\n\n    var cacheRoot = this._root.cache;\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = f_meta[f_meta_abs_path];\n    var referenceContainer, currentRefPath, i, len;\n\n    if (!absolutePath) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: undefined,\n            _seed: seed\n        });\n    } else if (absolutePath.length === 0) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: cacheRoot,\n            _path: absolutePath,\n            _referenceContainer: true,\n            _seed: seed\n        });\n    }\n\n    var originalRefPath = f_meta[f_meta_deref_to];\n    var originalAbsPath = f_meta[f_meta_deref_from];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n            validContainer = true;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n            for (i = 0; i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    cacheNode = undefined;\n                    validContainer = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n        referenceContainer = true;\n    }\n\n    if (recycleJSON) {\n        seed = { json: json };\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    return this._clone({\n        _seed: seed,\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/index.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'It is not legal to use the JSON Graph ' +\n    'format from a bound Model. JSON Graph format' +\n    ' can only be used from a root model.';\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nmodule.exports = createErrorClass('BoundJSONGraphModelError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/BoundJSONGraphModelError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'Deref can only be used with a non-primitive object from get, set, or call.';\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidDerefInputError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidDerefInputError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'The boundPath of the model is not valid since a value or error was found before the path end.';\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidModelError', function(boundPath, shortedPath) {\n    this.message = MESSAGE;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidModelError.js","var createErrorClass = require('./createErrorClass');\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nmodule.exports = createErrorClass('MaxRetryExceededError', function(maxRetryCount, absolute, relative, optimized) {\n    this.message = '' +\n        'Exceeded the max retry count (' + maxRetryCount + ') for these paths: \\n' +\n        (absolute &&\n        'absolute: [\\n\\t' + printPaths(absolute) + '\\n]\\n' || '') +\n        (relative &&\n        'relative: [\\n\\t' + printPaths(relative) + '\\n]\\n' || '') +\n        (optimized &&\n        'optimized: [\\n\\t' + printPaths(optimized) + '\\n]\\n' || '');\n});\n\nfunction printPaths(paths) {\n    return paths.map(function(path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/MaxRetryExceededError.js","module.exports = String.fromCharCode(30) + 'ƒ_';\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/f_.js","var Source = require('./Source');\nvar Subscriber = require('./Subscriber');\nvar lruCollect = require('../lru/collect');\nvar FalcorJSON = require('../cache/get/json/FalcorJSON');\nvar collapse = require('@graphistry/falcor-path-utils/lib/collapse');\nvar InvalidSourceError = require('../errors/InvalidSourceError');\nvar MaxRetryExceededError = require('../errors/MaxRetryExceededError');\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function(operator, source) {\n    source = new Call(source || this);\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    source.operator = operator;\n    operator.data = operator.data || this.operator.data;\n    operator.errors = operator.errors || this.operator.errors;\n    operator.operation = operator.operation || this.operator.operation;\n    operator.progressive = operator.progressive || this.operator.progressive;\n    operator.maxRetryCount = operator.maxRetryCount || this.operator.maxRetryCount;\n    return source;\n}\n\nCall.prototype.operator = function(subscriber) {\n    return this._subscribe(subscriber);\n}\n\nCall.prototype._subscribe = function(subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n}\n\nCall.prototype._toJSON = function(data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(\n        data, errors || this.operator.errors, 'json',\n        this.operator.progressive, this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype._toJSONG = function(data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(\n        data, errors || this.operator.errors, 'jsonGraph',\n        this.operator.progressive, this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.retry = function(maxRetryCount) {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        this.operator.progresive,\n        maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.progressively = function() {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        true,\n        this.operator.maxRetryCount\n    ), this.source);\n}\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function(source, destination) {\n    return source.subscribe(new CallSubscriber(\n        destination, this.data, this.errors, this.operation, this.progressive\n    ));\n}\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.hasValue = false;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: require('../cache/get'),\n    set: require('../cache/set'),\n    call: require('../cache/call'),\n    invalidate: require('../cache/invalidate')\n};\n\nCallSubscriber.prototype.next =\nCallSubscriber.prototype.onNext = function(seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n\n    var seedIsImmutable = progressive && data;\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type]\n            [operation](model, args, data,\n                        progressive || !model._source,\n                        this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            return tryOnError(this, results.error);\n        }\n\n        errors && results.errors &&\n            errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n}\n\nCallSubscriber.prototype.error =\nCallSubscriber.prototype.onError = function(error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n}\n\nCallSubscriber.prototype.complete =\nCallSubscriber.prototype.onCompleted = function(error) {\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && (\n            (data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return tryOnError(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return tryOnError(this, new MaxRetryExceededError(\n            this.retryCount,\n            this.requested,\n            this.relative,\n            this.missing\n        ));\n    }\n\n    this.request = this.model._root.requests[this.type](\n        this.model, this.missing, this.relative, this.fragments\n    ).subscribe(this);\n}\n\nCallSubscriber.prototype.dispose =\nCallSubscriber.prototype.unsubscribe = function() {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 &&\n                                 version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot,\n                           modelRoot.expired,\n                           cache.$size || 0,\n                           modelRoot.maxSize,\n                           modelRoot.collectRatio,\n                           modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n}\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch(e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction tryOnError(self, error) {\n    try {\n        throw error;\n    } catch (err) {\n        Subscriber.prototype.onError.call(self, err);\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue, nodeValue,\n        key, keys = Object.keys(node),\n        index = -1, length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === f_meta_data) {\n            dest[f_meta_data] = node[f_meta_data];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (!nodeValue || typeof nodeValue !== 'object') {\n                    if (destValue === undefined) {\n                        dest[key] = nodeValue;\n                    }\n                } else if (destValue === undefined) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Call.js","var Source = require('./Source');\nvar Request = require('./Request');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar ImmediateScheduler = require('../schedulers/ImmediateScheduler');\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = env.jsonGraph;\n        request.requested.push(requested);\n        request.optimized.push(optimized);\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, callArgs) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = callArgs;\n        request.boundPath = model._path;\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(\n        this, model._source, model._scheduler, requested, optimized\n    );\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function(destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests  = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] =\n            new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Queue.js","var isArray = Array.isArray;\nvar Subject = require('./Subject');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar InvalidSourceError = require('../errors/InvalidSourceError');\n\nvar setJSONGraphs = require('../cache/set/setJSONGraphs');\nvar setPathValues = require('../cache/set/setPathValues');\nvar invalidatePaths = require('../cache/invalidate/invalidatePathSets');\n\nvar toPaths = require('@graphistry/falcor-path-utils/lib/toPaths');\nvar toCollapseMap = require('@graphistry/falcor-path-utils/lib/toCollapseMap');\nvar toCollapseTrees = require('@graphistry/falcor-path-utils/lib/toCollapseTrees');\nvar hasIntersection = require('@graphistry/falcor-path-utils/lib/hasIntersection');\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.tree = {};\n    this.paths = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next =\nRequest.prototype.onNext = function(envelopes) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    var env = envelopes,\n        envelopeIndex = 0,\n        envelopeCount = 0;\n\n    if (isArray(envelopes)) {\n        if ((envelopeCount = envelopes.length) <= 0) {\n            return;\n        }\n        env = envelopes[0];\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    var boundPath = this.boundPath;\n\n    do {\n\n        var jsonGraph = env.jsonGraph;\n        var requested = this.requested;\n        var modelRoot = queue.modelRoot;\n        var invalidated = env.invalidated;\n        var paths = env.paths || this.paths;\n\n        // Run invalidations first.\n        if (invalidated && invalidated.length) {\n            invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n        }\n\n        if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n            paths = setJSONGraphs(\n                { _root: modelRoot },\n                [{ paths: paths, jsonGraph: jsonGraph }],\n                modelRoot.errorSelector, modelRoot.comparator, false\n            )[0];\n        }\n    } while (++envelopeIndex < envelopeCount && (env = envelopes[envelopeIndex]))\n\n    this.observers.slice(0).forEach(function(observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] ||\n                filterPathsBoundTo(boundPath, paths)\n        });\n    });\n}\n\nRequest.prototype.error =\nRequest.prototype.onError = function(error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    error = error || {};\n\n    // Converts errors to object we can insert into the cache.\n    error = !(error instanceof Error) ?\n        // if it's $type error, use it raw\n        error.$type === $error && error ||\n        // Otherwise make it an error\n        { $type: $error, value: error } :\n        // If it's instanceof Error, pluck error.message\n        { $type: $error, value: { message: error.message }};\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(\n        this.requested.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ))\n    .map(function(path) { return { path: path, value: error }; });\n\n    if (errorPathValues.length) {\n        setPathValues(\n            { _root: modelRoot, _path: [] },\n            errorPathValues,\n            modelRoot.errorSelector,\n            modelRoot.comparator,\n            false\n        );\n    }\n\n    Subject.prototype.onError.call(this, error);\n}\n\nRequest.prototype.complete =\nRequest.prototype.onCompleted = function() {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n}\n\nRequest.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n}\n\nRequest.prototype.dispose =\nRequest.prototype.unsubscribe = function () {\n    this.tree = {};\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.boundPath = null;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n}\n\nRequest.prototype.connect = function() {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n}\n\nRequest.prototype.batch = function(requested, optimized,\n                                   requestedComplements,\n                                   optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.tree,\n                              requested, optimized,\n                              requestedComplements,\n                              optimizedComplements,\n                              requestedIntersection,\n                              optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            return this;\n        }\n        return null;\n    }\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    return this;\n}\n\nfunction flush() {\n\n    this.active = true;\n\n    var obs, paths = this.paths = toPaths(this.tree = toCollapseTrees(\n        this.optimized.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ));\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = {};\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\n\nfunction findIntersections(tree,\n                           requested, optimized,\n                           requestedComplements,\n                           optimizedComplements,\n                           requestedIntersection,\n                           optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = -1;\n    var intersectionIndex = -1;\n    var optTotal = optimized.length;\n    var reqTotal = requested.length - 1;\n\n    while (++index < optTotal) {\n        var path = optimized[index];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n        if (subTree && hasIntersection(subTree, path, 0, pathLen)) {\n            optimizedIntersection[++intersectionIndex] = path;\n            requestedIntersection[intersectionIndex] = requested[\n                index < reqTotal ? index : reqTotal\n            ];\n        } else {\n            optimizedComplements[++complementIndex] = path;\n            requestedComplements[complementIndex] = requested[\n                index < reqTotal ? index : reqTotal\n            ];\n        }\n    }\n\n    return ~intersectionIndex;\n}\n\nfunction filterPathsBoundTo(boundPath, paths) {\n\n    var boundLength;\n\n    if (!boundPath || (boundLength = boundPath.length) === 0) {\n        return paths;\n    }\n\n    var filtered = [], filteredIndex = -1, keyIndex;\n    var path, pathsIndex = -1, pathsCount = paths.length;\n\n    outer: while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        if (path.length > boundLength) {\n            keyIndex = 0;\n            do {\n                if (path[keyIndex] !== boundPath[keyIndex]) {\n                    continue outer;\n                }\n            } while (++keyIndex < boundLength);\n            filtered[++filteredIndex] = path.slice(boundLength);\n        }\n    }\n\n    return filtered;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Request.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\n// Unused\n// Subject.prototype.onNext = function(value) {\n//     this.observers.slice(0).forEach(function(observer) {\n//         observer.onNext(value);\n//     });\n// }\n\nSubject.prototype.onError = function(error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onError(error);\n    });\n}\n\nSubject.prototype.onCompleted = function() {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onCompleted();\n    });\n}\n\nSubject.prototype.subscribe = function(subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n}\n\nSubject.prototype.dispose =\nSubject.prototype.unsubscribe = function () {\n    this.observers = [];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subject.js","function TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose =\nTimerDisposable.prototype.unsubscribe = function() {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/TimeoutScheduler.js","module.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/array-flat-map.js","var isArray = Array.isArray;\nvar isInternal = require('../internal/isInternal');\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (isInternal(key)) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/clone.js","var isObject = require('./isObject');\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getExpires.js","var isObject = require('./../support/isObject');\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return 'branch';\n    }\n    return type;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getType.js","var isArray = Array.isArray;\nvar isObject = require('./../support/isObject');\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === 'string'\n        ));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isPathValue.js","module.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/index.js\n// module id = 105\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/index.js\n// module id = 106\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/ponyfill.js\n// module id = 107\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 108\n// module chunks = 0"],"sourceRoot":""}