{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///falcor.all.min.js","webpack:///webpack/bootstrap 465e9bc50fc9520273de","webpack:///./lib/cache/isExpired.js","webpack:///./lib/cache/clone.js","webpack:///./lib/cache/expireNode.js","webpack:///./lib/cache/get/json/FalcorJSON.js","webpack:///./lib/errors/NullInPathError.js","webpack:///./lib/errors/createErrorClass.js","webpack:///./lib/support/isObject.js","webpack:///./lib/cache/createHardlink.js","webpack:///.-path-utils/lib/support/materializedAtom.js","webpack:///./lib/support/getSize.js","webpack:///./lib/cache/getCachePosition.js","webpack:///./lib/cache/updateNodeAncestors.js","webpack:///./lib/errors/InvalidKeySetError.js","webpack:///./lib/lru/promote.js","webpack:///./lib/request/Subscriber.js","webpack:///./lib/request/Subscription.js","webpack:///./lib/cache/get/onValueType.js","webpack:///./lib/cache/getBoundCacheNode.js","webpack:///./lib/cache/set/setJSONGraphs.js","webpack:///./lib/cache/set/setPathMaps.js","webpack:///./lib/internal/isInternal.js","webpack:///.-path-utils/lib/flatBufferToPaths.js","webpack:///.-path-utils/lib/getHashCode.js","webpack:///.-path-utils/lib/iterateKeySet.js","webpack:///./lib/cache/get/json/index.js","webpack:///./lib/cache/get/jsonGraph/index.js","webpack:///./lib/cache/get/jsonGraph/inlineValue.js","webpack:///./lib/cache/get/onMissing.js","webpack:///./lib/cache/invalidate/invalidatePathSets.js","webpack:///./lib/cache/removeNodeAndDescendants.js","webpack:///./lib/cache/set/setPathValues.js","webpack:///./lib/cache/updateBackReferenceVersions.js","webpack:///./lib/support/getTimestamp.js","webpack:///./lib/support/isInternalKey.js","webpack:///./lib/values/expires-now.js","webpack:///(webpack)/buildin/global.js","webpack:///.-path-utils/lib/collapse.js","webpack:///.-path-utils/lib/toCollapseMap.js","webpack:///.-path-utils/lib/toCollapseTrees.js","webpack:///.-path-utils/lib/toPaths.js","webpack:///./lib/cache/get/json/getJSON.js","webpack:///./lib/cache/get/json/getReferenceTarget.js","webpack:///./lib/cache/get/json/onValue.js","webpack:///./lib/cache/get/jsonGraph/getJSONGraph.js","webpack:///./lib/cache/get/onMaterialize.js","webpack:///./lib/cache/groupCacheArguments.js","webpack:///./lib/cache/insertNode.js","webpack:///./lib/cache/invalidate/invalidatePathMaps.js","webpack:///./lib/cache/mergeValueOrInsertBranch.js","webpack:///./lib/cache/reconstructPath.js","webpack:///./lib/cache/replaceNode.js","webpack:///./lib/cache/wrapNode.js","webpack:///./lib/errors/CircularReferenceError.js","webpack:///./lib/errors/InvalidSourceError.js","webpack:///./lib/lru/splice.js","webpack:///./lib/request/Source.js","webpack:///./lib/schedulers/ImmediateScheduler.js","webpack:///./lib/support/isJSONEnvelope.js","webpack:///./lib/support/isJSONGraphEnvelope.js","webpack:///./lib/support/now.js","webpack:///./lib/values/expires-never.js","webpack:///./lib/index.js","webpack:///.-path-utils/lib/computeFlatBufferHash.js","webpack:///.-path-utils/lib/hasIntersection.js","webpack:///.-path-utils/lib/toFlatBuffer.js","webpack:///.-path-utils/lib/toTree.js","webpack:///./lib/Model.js","webpack:///./lib/ModelDataSourceAdapter.js","webpack:///./lib/ModelRoot.js","webpack:///./lib/cache/call/index.js","webpack:///./lib/cache/get/index.js","webpack:///./lib/cache/get/json/onError.js","webpack:///./lib/cache/get/json/walkFlatBuffer.js","webpack:///./lib/cache/get/json/walkPath.js","webpack:///./lib/cache/get/jsonGraph/getReferenceTarget.js","webpack:///./lib/cache/get/jsonGraph/onValue.js","webpack:///./lib/cache/get/jsonGraph/walkPath.js","webpack:///./lib/cache/get/onMaterializeFlatBuffer.js","webpack:///./lib/cache/getCache.js","webpack:///./lib/cache/getVersion.js","webpack:///./lib/cache/invalidate/index.js","webpack:///./lib/cache/mergeJSONGraphNode.js","webpack:///./lib/cache/set/index.js","webpack:///./lib/cache/transferBackReferences.js","webpack:///./lib/cache/unlinkBackReferences.js","webpack:///./lib/cache/unlinkForwardReference.js","webpack:///./lib/deref/hasValidParentReference.js","webpack:///./lib/deref/index.js","webpack:///./lib/errors/BoundJSONGraphModelError.js","webpack:///./lib/errors/InvalidDerefInputError.js","webpack:///./lib/errors/InvalidModelError.js","webpack:///./lib/errors/MaxRetryExceededError.js","webpack:///./lib/internal/f_.js","webpack:///./lib/lru/collect.js","webpack:///./lib/request/Call.js","webpack:///./lib/request/Queue.js","webpack:///./lib/request/Request.js","webpack:///./lib/request/Subject.js","webpack:///./lib/schedulers/TimeoutScheduler.js","webpack:///./lib/support/clone.js","webpack:///./lib/support/getExpires.js","webpack:///./lib/support/getType.js","webpack:///./lib/support/isPathValue.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/lib/index.js","webpack:///./~/symbol-observable/lib/ponyfill.js","webpack:///(webpack)/buildin/module.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","o","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","now","$now","$never","isExpired","node","expireImmediate","exp","undefined","isInternal","clone","key","keys","json","index","length","splice","expireNode","expired","lru","global","FalcorJSON","f_meta","bindArrayMethod","fn","atom","type","RangeError","arguments","getInst","x","inst","typeofInst","argsLen","toJSON","serialize","toString","includeMetadata","includeStatus","JSON","toProps","f_meta_inst","f_meta_json","version","serializer","createWithProto","count","total","xs","isArray","$code","status","abs_path","deref_to","deref_from","ys","protoBlacklist","constructor","toLocaleString","protoDescriptors","$__hash","$__path","$__status","$__version","Array","descriptors","writable","createErrorClass","message","MESSAGE","init","E","Error","stack","E.is","isObject","createHardlink","from","to","backRefs","$type","getSize","getCachePosition","cache","path","depth","maxDepth","removeNodeAndDescendants","updateBackReferenceVersions","updateNodeAncestors","offset","curr","next","keysOrRanges","mesage","EXPIRES_NEVER","lruPromote","head","prev","Subscriber","destination","parent","onCompleted","Subscription","error","onError","onNext","complete","Subscriber.prototype.onNext","dest","Subscriber.prototype.onError","signaled","dispose","Subscriber.prototype.onCompleted","Subscriber.prototype.unsubscribe","subscriptions","Subscription.prototype.add","subscription","push","Subscription.prototype.remove","indexOf","Subscription.prototype.unsubscribe","onValueType","seed","results","requestedPath","requestedLength","optimizedPath","optimizedLength","fromReference","modelRoot","branchSelector","boxValues","materialized","reportMissing","treatErrorsAsValues","onValue","onMissing","onMaterialize","_reportMissing","reportMaterialized","getBoundCacheNode","model","setJSONGraphPathSet","messageRoot","messageParent","requestedPaths","optimizedPaths","comparator","errorSelector","note","branch","keySet","iterateKeySet","optimizedIndex","setNode","nextNode","arr","nextParent","nextOptimizedPath","parentArg","nodeArg","messageParentArg","messageArg","reference","optimizedPathArg","container","NullInPathError","mergeJSONGraphNode","setJSONGraphs","jsonGraphEnvelopes","jsonGraphEnvelopeIndex","jsonGraphEnvelopeCount","jsonGraphEnvelope","paths","jsonGraph","pathIndex","pathCount","setPathMap","pathMap","itr","isInternalKey","keyIndex","keyCount","child","mergeValueOrInsertBranch","setPathMaps","pathMapEnvelopes","bound","pathMapIndex","pathMapCount","pathMapEnvelope","f_","regexp","RegExp","flatBufferToPaths","leaf","keysLen","keysIndex","keyset","getHashCode","str","hash","initializeRange","memo","module.exports","nextValue","el","inlineJSONGraphValue","restPathIndex","restPath","restPathCount","isEmptyKeySet","rangeEnd","mPath","lastKeyIsNull","isRequestedPath","missingPaths","missTotal","missingPath","missDepth","Number","invalidatePathSet","invalidateNode","invalidatePathSets","key2","lruSplice","unlinkForwardReference","unlinkBackReferences","setPathSet","setPathValues","pathValues","pathValueIndex","pathValueCount","pathValue","ref","getTimestamp","g","Function","eval","e","window","toPaths","toCollapseMap","toCollapseTrees","partitionPathsByLength","collapseMap","pathsArg","collapseMapArg","toTree","pathsByLength","treesByPathLengthArg","pathLengths","pathLengthsIndex","pathLengthsCount","treesByPathLength","pathLength","collapsePathMap","pathmap","subs","code","codes","codesIndex","codesCount","pathsets","pathsetsCount","subPath","subCode","subKeys","subKeysIndex","subKeysCount","pathsetClone","getSortedKeys","isSafeNumber","sets","parseInt","subSets","firstSubKey","subSetsIndex","subSetsCount","pathset","pathsetIndex","pathsetCount","sortListAscending","a","b","map","sort","len","materializedAtom","val","num","typeOfString","MIN_SAFE_INTEGER_DIGITS","safeNumberRegEx","MAX_SAFE_INTEGER_DIGITS","typeOfNumber","MAX_SAFE_INTEGER","abs","Math","lengths","allPaths","allPathsLength","typeOfObject","pathsIndex","pathsCount","keysetIndex","keysetCount","isSparseRange","collapseIndex","walkPathAndBuildOutput","walkFlatBufferAndBuildOutput","InvalidModelError","toFlatBuffer","computeFlatBufferHash","getJSON","progressive","referenceContainer","boundPath","isFlatBuffer","recycleJSON","hasDataSource","Boolean","allowFromWhenceYouCame","args","data","hasValue","relative","requested","missing","boundRequested","promote","CircularReferenceError","getReferenceTarget","refArg","context","copy","onJSONValue","BoundJSONGraphModelError","getJSONGraph","jsonArg","nextDepth","keysetLength","iteratingKeyset","nextKey","keyIsRange","InvalidKeySetError","isPathValue","isJSONEnvelope","isJSONGraphEnvelope","groupCacheArguments","groups","argIndex","argCount","group","groupType","arg","argType","inputType","insertNode","invalidatePathMap","invalidatePathMaps","getType","wrapNode","replaceNode","reconstructPath","cType","mType","sizeOffset","currentPath","transferBackReferences","replacement","getExpires","expiresNow","typeArg","size","modelCreated","atomSize","expires","referencePath","Source","subscribe","source","$$observable","default","Source.prototype.operator","Source.prototype.subscribe","y","operator","Source.prototype.then","_promise","resolve","reject","values","rejected","errors","then","ImmediateScheduler","empty","unsubscribe","ImmediateScheduler.prototype.schedule","action","envelope","Date","falcor","opts","Model","keysLength","hasIntersection","tree","pathToFlatBuffer","keysMap","nullBuffer","pathToTree","options","_node","_path","_source","_root","ModelRoot","_recycleJSON","_scheduler","_seed","_treatErrorsAsValues","__proto__","_boxed","_materialized","_allowFromWhenceYouCame","setCache","Call","ModelDataSourceAdapter","TimeoutScheduler","collapse","getCache","Model.prototype.get","_len","_key","_toJSON","Model.prototype.set","_len2","_key2","Model.prototype.preload","_len3","_key3","Model.prototype.call","_len4","_key4","Model.prototype.invalidate","_len5","_key5","Model.prototype.getValue","lift","subscriber","Model.prototype.setValue","Model.prototype.setCache","cacheOrJSONGraphEnvelope","rootOnChangeHandler","Model.prototype.getCache","_len6","_key6","env","Model.prototype.getVersion","concat","_getVersion","Model.prototype._clone","Model.prototype.batch","schedulerOrDelay","scheduler","scheudle","_clone","Model.prototype.unbatch","Model.prototype.treatErrorsAsValues","Model.prototype.asDataSource","Model.prototype._materialize","Model.prototype._dematerialize","Model.prototype.boxValues","Model.prototype.unboxValues","Model.prototype.withoutDataSource","Model.prototype.inspect","getVersion","join","Model.prototype.toJSON","getPath","Model.prototype.getPath","slice","Model.prototype._fromWhenceYouCame","allow","Model.prototype._optimizePath","_model","ModelDataSourceAdapter.prototype.get","pathSets","apply","_toJSONG","ModelDataSourceAdapter.prototype.set","jsongResponse","set","ModelDataSourceAdapter.prototype.call","suffixes","syncRefCount","maxRetryCount","topLevelModel","requests","Requests","collectRatio","maxSize","functionTypeof","onChange","onChangesCompleted","defaultCompare","_args","thisPaths","fragments","errorPath","errorValue","fromReferenceArg","refTarget","f_old_keys","f_new_keys","f_code","nextJSON","nextReferenceContainer","nextOptimizedLength","optimizedLengthNext","refContainerAbsPath","refContainerRefPath","nodeAbsPath","jsonAbsPath","arrayEqual","nextPath","nextPathKey","hasMissingPath","tmp","rPath","originalOnMissing","inlineValue","onJSONGraphValue","isLeaf","onMaterializeFlatBuffer","getCacheInternal","invalidate","changed","groupIndex","groupCount","groupedArgs","pluckPaths","operation","rootChangeHandler","invalidatePathValues","cIsObject","mIsObject","cTimestamp","mTimestamp","isDistinct","setGroupsIntoCache","expireImmediate_","arrayFlatMap","optimized","array","selector","array2","array3","j","k","jsong","fromNode","destNode","fromNodeRefsLength","destNodeRefsLength","hasValidParentReference","_referenceContainer","deref","cacheRoot","absolutePath","originalRefPath","originalAbsPath","cacheNode","validContainer","CONTAINER_DOES_NOT_EXIST","currentRefPath","shortedPath","printPaths","absolute","String","collect","totalArg","max","ratioArg","ratio","targetSize","CallOperator","CallSubscriber","request","started","retryCount","errored","completed","tryOnNext","tryOnError","self","err","mergeInto","destValue","nodeValue","lruCollect","InvalidSourceError","MaxRetryExceededError","Call.prototype.lift","Call.prototype.operator","_subscribe","Call.prototype._subscribe","Call.prototype._toJSON","dataArg","Call.prototype._toJSONG","Call.prototype.retry","progresive","Call.prototype.progressively","CallOperator.prototype.call","CallSubscriber.prototype.onNext","seedIsImmutable","operations","CallSubscriber.prototype.onError","CallSubscriber.prototype.onCompleted","CallSubscriber.prototype.unsubscribe","rootOnChangesCompletedHandler","Queue","Dedupe","queue","dataSource","Request","isolateSet","isolateCall","callArgs","batchAndDedupeGet","Dedupe.prototype.subscribe","requestsIndex","requestsCount","batch","Subject","trees","responded","active","disposable","flush","obs","reduce","filterPathsBoundTo","boundLength","filtered","filteredIndex","outer","invalidatePaths","Request.prototype.onNext","invalidated","observers","observer","Request.prototype.onError","errorPathValues","Request.prototype.onCompleted","Request.prototype.remove","Request.prototype.unsubscribe","Request.prototype.connect","scheduledDisposable","schedule","Request.prototype.batch","requestedComplements","optimizedComplements","requestedIntersection","optimizedIntersection","complementIndex","reqComplementsIdx","intersectionIndex","reqIntersectionIdx","treesLength","optTotal","reqTotal","toNextPath","treesIndex","pathLen","subTree","Subject.prototype.onError","Subject.prototype.onCompleted","Subject.prototype.subscribe","Subject.prototype.unsubscribe","delay","TimerDisposable","id","disposed","TimeoutScheduler.prototype.schedule","setTimeout","TimerDisposable.prototype.unsubscribe","clearTimeout","anyType","_ponyfill","_ponyfill2","result","symbolObservablePonyfill","_Symbol","Symbol","observable","webpackPolyfill","deprecate","module.deprecate","children"],"mappings":"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","file":"falcor.all.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 107);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(59);\nvar $now = __webpack_require__(34);\nvar $never = __webpack_require__(60);\n\nmodule.exports = isExpired;\n\nfunction isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternal = __webpack_require__(20);\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key,\n        keys = Object.keys(node),\n        json = {},\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (key !== '$size' && !isInternal(key)) {\n            json[key] = node[key];\n        }\n    }\n\n    return json;\n}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar splice = __webpack_require__(54);\n\nmodule.exports = expireNode;\n\nfunction expireNode(node, expired, lru) {\n    if (!node[\"\u001ef_invalidated\"]) {\n        node[\"\u001ef_invalidated\"] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {function FalcorJSON(f_meta) {\n    if (!f_meta) {\n        this[\"\u001ef_meta\"] = {};\n    } else if (!(this[\"\u001ef_meta\"] = f_meta[\"\u001ef_meta\"])) {\n        this[\"\u001ef_meta\"] = f_meta;\n    }\n}\n\nvar protoBlacklist = {\n    length: true,\n    toString: true,\n    constructor: true,\n    toLocaleString: true\n};\n\nvar protoDescriptors = {\n    toJSON: { enumerable: false, value: toJSON },\n    toProps: { enumerable: false, value: toProps },\n    toString: { enumerable: false, value: toString },\n    toLocaleString: { enumerable: false, value: toString },\n    $__hash: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001ef_meta\"];\n            return f_meta && f_meta['$code'] || '';\n        }\n    },\n    $__path: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001ef_meta\"];\n            return f_meta && f_meta[\"abs_path\"] || [];\n        }\n    },\n    $__status: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001ef_meta\"];\n            return f_meta && f_meta[\"status\"] || 'resolved';\n        }\n    },\n    $__version: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001ef_meta\"];\n            return f_meta && f_meta[\"version\"] || 0;\n        }\n    }\n};\n\nObject.defineProperties(FalcorJSON.prototype, Object.getOwnPropertyNames(Array.prototype).reduce(function (descriptors, name) {\n    if (!protoBlacklist.hasOwnProperty(name)) {\n        var fn = Array.prototype[name];\n        if (typeof fn === 'function') {\n            descriptors[name] = {\n                value: bindArrayMethod(fn),\n                writable: true, enumerable: false\n            };\n        }\n    }\n    return descriptors;\n}, protoDescriptors));\n\nfunction bindArrayMethod(fn) {\n    return function () {\n        var node = this,\n            json = node,\n            atom = node.length,\n            length = atom,\n            type;\n        // If length isn't a number, an $atom with a numeric `value`, or if the\n        // unboxed length isn't a valid Array length, bail early.\n        // If we're still waiting on pending updates, return an empty Array.\n        // Otherwise, throw a RangeError.\n        if ((type = typeof atom) !== 'number' && (!atom || type !== 'object' || atom.$type !== \"atom\" || typeof (length = atom.value) !== 'number') || length < 0 || length !== (length | 0)) {\n            if (node.$__status === 'pending') {\n                return [];\n            }\n            throw new RangeError('Invalid FalcorJSON length');\n        }\n        // Temporarily set length to the unboxed length, call the bound Array\n        // method, then reset the length back to the boxed value. This is\n        // necessary because a few Array methods (like sort) operate on the\n        // Array in-place, so we can't pass a sliced copy of this instance to\n        // the bound Array method. Do this even when the length isn't boxed, so\n        // if calling the bound Array method writes to length, it's reset to the\n        // value in the cache.\n        node.length = length;\n        json = fn.apply(node, arguments);\n        node.length = atom;\n        return json;\n    };\n}\n\nvar isArray = Array.isArray;\n\nfunction getInst(x) {\n    var inst = x;\n    var typeofInst = typeof inst;\n    var argsLen = arguments.length;\n    if (argsLen === 0) {\n        inst = this;\n    } else if (typeofInst !== 'string') {\n        if (!inst || typeofInst !== 'object') {\n            return inst;\n        }\n    } else if (argsLen !== 1) {\n        return inst;\n    } else {\n        inst = this;\n    }\n    return inst === global ? undefined : inst;\n}\n\nfunction toJSON() {\n    return serialize(getInst.apply(this, arguments), toJSON);\n}\n\nfunction toString(includeMetadata, includeStatus) {\n    return JSON.stringify(serialize(getInst.call(this, this), serialize, includeMetadata === true, false, includeStatus === true));\n}\n\nfunction toProps(x) {\n\n    var inst = getInst.apply(this, arguments);\n    var f_meta_inst,\n        f_meta_json,\n        version = 0;\n    var json = serialize(inst, toProps, true, true);\n\n    if (inst && (f_meta_inst = inst[\"\u001ef_meta\"])) {\n        version = f_meta_inst[\"version\"];\n    }\n\n    if (!(!json || typeof json !== 'object')) {\n        if (f_meta_json = json[\"\u001ef_meta\"]) {\n            f_meta_json[\"version\"] = version;\n        }\n    }\n\n    return json;\n}\n\nfunction serialize(inst, serializer, includeMetadata, createWithProto, includeStatus) {\n\n    if (!inst || typeof inst !== 'object') {\n        return inst;\n    }\n\n    var count, total, f_meta, keys, key, xs, ys;\n\n    if (isArray(inst)) {\n        xs = inst;\n    } else {\n\n        count = -1;\n        keys = Object.keys(inst);\n        total = keys.length;\n        xs = {};\n\n        if (createWithProto) {\n            xs.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (includeMetadata && (f_meta = inst[\"\u001ef_meta\"])) {\n\n            var $code = f_meta['$code'];\n            var status = f_meta[\"status\"];\n            var abs_path = f_meta[\"abs_path\"];\n            var deref_to = f_meta[\"deref_to\"];\n            var deref_from = f_meta[\"deref_from\"];\n\n            f_meta = {};\n            $code && (f_meta['$code'] = $code);\n            abs_path && (f_meta[\"abs_path\"] = abs_path);\n            deref_to && (f_meta[\"deref_to\"] = deref_to);\n            deref_from && (f_meta[\"deref_from\"] = deref_from);\n            includeStatus && status && (f_meta[\"status\"] = status);\n\n            xs[\"\u001ef_meta\"] = f_meta;\n\n            if (createWithProto) {\n                ys = {};\n                ys.__proto__ = xs;\n                xs = ys;\n            }\n        }\n\n        while (++count < total) {\n            if ((key = keys[count]) !== \"\u001ef_meta\") {\n                xs[key] = serializer(inst[key], serializer, includeMetadata, createWithProto, includeStatus);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\nvar MESSAGE = '`null` is not allowed in branch key positions.';\n\n/**\n * Do not allow null in path.\n */\nmodule.exports = createErrorClass('NullInPathError', function () {\n  this.message = MESSAGE;\n});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = createErrorClass;\n\nfunction createErrorClass(name, init) {\n    function E(message) {\n        this.message = message;\n        init && init.apply(this, arguments);\n        if (!Error.captureStackTrace) {\n            this.stack = new Error().stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    E.prototype = Object.create(Error.prototype);\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    E.is = function (x) {\n        return x.name === name;\n    };\n    return E;\n}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nmodule.exports = isObject;\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = createHardlink;\n\nfunction createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[\"\u001ef_refs_length\"] || 0;\n    to[\"\u001ef_ref\" + backRefs] = from;\n    to[\"\u001ef_refs_length\"] = backRefs + 1;\n\n    // create a hard reference\n    from[\"\u001ef_ref_index\"] = backRefs;\n    from[\"\u001ef_context\"] = to;\n}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\nmodule.exports = { $type: 'atom' };\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\nmodule.exports = getSize;\n\nfunction getSize(node) {\n    return isObject(node) && node.$size || 0;\n}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type,\n        depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === \"ref\") {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNodeAndDescendants = __webpack_require__(29);\nvar updateBackReferenceVersions = __webpack_require__(31);\n\nmodule.exports = updateNodeAncestors;\n\nfunction updateNodeAncestors(node, offset, lru, version) {\n    var curr = node,\n        next;\n    do {\n        if ((curr.$size = (curr.$size || 0) - offset) > 0) {\n            if (!(next = curr[\"\u001ef_parent\"])) {\n                curr[\"\u001ef_version\"] = version;\n            } else if (curr[\"\u001ef_version\"] !== version) {\n                updateBackReferenceVersions(curr, version);\n            }\n        } else if (next = curr[\"\u001ef_parent\"]) {\n            removeNodeAndDescendants(curr, next, curr[\"\u001ef_key\"], lru, version);\n        }\n    } while (curr = next);\n    return node;\n}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidKeySetError', function (path, keysOrRanges) {\n  this.mesage = '' + 'The KeySet ' + JSON.stringify(keysOrRanges) + ' in path ' + JSON.stringify(path) + ' contains a KeySet. ' + 'Keysets can only contain Keys or Ranges';\n});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EXPIRES_NEVER = __webpack_require__(60);\n\nmodule.exports = lruPromote;\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nfunction lruPromote(lru, node) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (node.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = lru[\"\u001ef_head\"];\n\n    // Nothing is in the cache.\n    if (!head) {\n        lru[\"\u001ef_head\"] = lru[\"\u001ef_tail\"] = node;\n        return;\n    }\n\n    if (head === node) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = node[\"\u001ef_prev\"];\n    var next = node[\"\u001ef_next\"];\n    if (next) {\n        next[\"\u001ef_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\u001ef_next\"] = next;\n    }\n    node[\"\u001ef_prev\"] = undefined;\n\n    // Insert into head position\n    lru[\"\u001ef_head\"] = node;\n    node[\"\u001ef_next\"] = head;\n    head[\"\u001ef_prev\"] = node;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (node === lru[\"\u001ef_tail\"]) {\n        lru[\"\u001ef_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscription = __webpack_require__(15);\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' || typeof parent === 'function' || typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        };\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next = Subscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n};\n\nSubscriber.prototype.error = Subscriber.prototype.onError = function onError(error) {\n    var signaled = false;\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            signaled = true;\n            dest.onError(error);\n        } else if (dest.error) {\n            signaled = true;\n            dest.error(error);\n        }\n        this.dispose();\n    }\n    if (!signaled) {\n        throw error;\n    }\n};\n\nSubscriber.prototype.complete = Subscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n};\n\nSubscriber.prototype.dispose = Subscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\nmodule.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function (subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n};\n\nSubscription.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n};\n\nSubscription.prototype.dispose = Subscription.prototype.unsubscribe = function () {\n    var subscription,\n        subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) && subscription.dispose && subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar lruPromote = __webpack_require__(13);\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, reportMissing, treatErrorsAsValues, onValue, onMissing, onMaterialize) {\n\n    var _reportMissing = reportMissing;\n    var reportMaterialized = reportMissing;\n\n    if (type) {\n        if (isExpired(node, expireImmediate)) {\n            if (!node[\"\u001ef_invalidated\"]) {\n                expireNode(node, expired, modelRoot);\n            }\n        } else {\n            lruPromote(modelRoot, node);\n            if (node.value === undefined) {\n                _reportMissing = false;\n                reportMaterialized = materialized;\n            } else {\n                if (seed) {\n                    if (fromReference) {\n                        requestedPath[depth] = null;\n                    }\n                    return onValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues);\n                }\n                return undefined;\n            }\n        }\n    }\n\n    if (materialized) {\n        seed && (results.hasValue = true);\n    } else if (!reportMaterialized) {\n        return undefined;\n    }\n\n    return onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, _reportMissing, materialized, json, branchSelector, boxValues, onMaterialize, modelRoot);\n}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getCachePosition = __webpack_require__(10);\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[\"\u001ef_parent\"] === undefined || node[\"\u001ef_invalidated\"]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(5);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar createHardlink = __webpack_require__(7);\nvar mergeJSONGraphNode = __webpack_require__(81);\nvar NullInPathError = __webpack_require__(4);\nvar iterateKeySet = __webpack_require__(23);\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = setJSONGraphs;\n\nfunction setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    if (cache[\"\u001ef_version\"] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n}\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        var nextOptimizedPath = arr[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, arr[3], arr[2], requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(root, nodeArg, messageRoot, message, requestedPath, optimizedPathArg, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var node = nodeArg;\n    var reference = node.value;\n    var optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            node = arr[0];\n            optimizedPath = arr[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return;\n            }\n            parent = arr[1];\n            message = arr[2];\n            messageParent = arr[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[\"\u001ef_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n}\n\nfunction setNode(root, parentArg, nodeArg, messageRoot, messageParentArg, messageArg, key, branch, reference, requestedPath, optimizedPathArg, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var type = node.$type;\n    var parent = parentArg;\n    var message = messageArg;\n    var optimizedPath = optimizedPathArg;\n    var messageParent = messageParentArg;\n\n    while (type === \"ref\") {\n\n        setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = arr[0];\n\n        if (!node || typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        message = arr[2];\n        messageParent = arr[3];\n        optimizedPath = arr[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isArray = Array.isArray;\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar createHardlink = __webpack_require__(7);\nvar getCachePosition = __webpack_require__(10);\nvar isInternalKey = __webpack_require__(33);\nvar NullInPathError = __webpack_require__(4);\nvar mergeValueOrInsertBranch = __webpack_require__(48);\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = setPathMaps;\n\nfunction setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[\"\u001ef_parent\"] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, modelRoot, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[\"\u001ef_version\"] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n}\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = arr[0];\n            var nextParent = arr[1];\n            var nextOptimizedPath = arr[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(value, root, nodeArg, requestedPath, optimizedPathArg, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var node = nodeArg;\n    var reference = node.value;\n    var optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[\"\u001ef_context\"];\n\n        if (node != null) {\n            parent = node[\"\u001ef_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = arr[0];\n                optimizedPath = arr[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return;\n                }\n                parent = arr[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\u001ef_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\nfunction setNode(root, parentArg, nodeArg, key, value, branch, reference, requestedPath, optimizedPathArg, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var type = node.$type;\n    var parent = parentArg;\n    var optimizedPath = optimizedPathArg;\n\n    while (type === \"ref\") {\n\n        setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = arr[0];\n\n        if (!node || typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        optimizedPath = arr[2];\n        type = node && node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = 'length';\n        }\n        for (var key in pathMap) {\n            if (isInternalKey(key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return undefined;\n}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an f_ internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nvar f_ = __webpack_require__(92);\nvar regexp = new RegExp('^' + f_, 'i', 'g');\n\nmodule.exports = regexp.test.bind(regexp);\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\nmodule.exports = flatBufferToPaths;\n\nfunction flatBufferToPaths(seed, paths, path) {\n\n    path = path || [];\n    paths = paths || [];\n\n    if (!seed) {\n        return paths;\n    }\n\n    var leaf = [];\n    var keys = seed['$keys'];\n    var keysLen = keys.length;\n    var keysIndex = -1,\n        key,\n        len;\n\n    while (++keysIndex < keysLen) {\n\n        var next = seed[keysIndex];\n        var keyset = keys[keysIndex];\n\n        if (!next || typeof next !== 'object') {\n            leaf.push(keyset);\n        } else {\n            flatBufferToPaths(next, paths, path.concat([keyset]));\n        }\n    }\n\n    if (leaf.length === 1) {\n        paths.push(path.concat(leaf));\n    } else if (leaf.length > 1) {\n        paths.push(path.concat([leaf]));\n    }\n\n    return paths;\n}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\nmodule.exports = getHashCode;\n\nfunction getHashCode(str) {\n    var hash = 5381,\n        i = str.length;\n    while (i) {\n        hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset,\n                length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                    ++note.arrayOffset;\n                    nextValue = el;\n                }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n            if (!note.loaded) {\n                initializeRange(keySet, note);\n            }\n            if (note.rangeOffset > note.to) {\n                note.done = true;\n                return undefined;\n            }\n\n            return note.rangeOffset++;\n        }\n\n        // Primitive value\n        else {\n                note.done = true;\n                return keySet;\n            }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to || typeof key.length === 'number' && memo.from + key.length - 1 || 0;\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(40);\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(43);\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\nmodule.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key,\n        depth = 0,\n        prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, json, branchSelector, boxValues, onMaterialize, modelRoot) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        return onMaterialize(json, mPath, missDepth, missTotal, branchSelector, boxValues, modelRoot);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if ('object' !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if ('number' !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar lruPromote = __webpack_require__(13);\nvar getSize = __webpack_require__(9);\nvar createHardlink = __webpack_require__(7);\nvar getBoundCacheNode = __webpack_require__(17);\nvar updateNodeAncestors = __webpack_require__(11);\nvar iterateKeySet = __webpack_require__(23);\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = invalidatePathSets;\n\nfunction invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n    var parent = node[\"\u001ef_parent\"] || cache;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(path, 0, cache, parent, node, version, expired, lru, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[\"\u001ef_version\"] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathSet(path, depth, root, parent, node, version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        invalidateNode(root, parent, node, key, branch, false, version, expired, lru, expireImmediate);\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru, expireImmediate);\n            } else {\n                updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, nodeArg, version, expired, lru, expireImmediate) {\n\n    var node = nodeArg;\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\u001ef_context\"];\n\n    if (node != null) {\n        parent = node[\"\u001ef_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            invalidateNode(root, parent, node, key, branch, true, version, expired, lru, expireImmediate);\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[\"\u001ef_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\nfunction invalidateNode(root, parentArg, nodeArg, key, branch, reference, version, expired, lru, expireImmediate) {\n\n    var node = nodeArg;\n    var parent = parentArg;\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[\"\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar lruSplice = __webpack_require__(54);\nvar isInternalKey = __webpack_require__(33);\nvar unlinkBackReferences = __webpack_require__(84);\nvar unlinkForwardReference = __webpack_require__(85);\nvar updateBackReferenceVersions = __webpack_require__(31);\n\nmodule.exports = removeNodeAndDescendants;\n\nfunction removeNodeAndDescendants(node, parent, key, lru, version) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type === undefined) {\n            for (var key2 in node) {\n                if (!isInternalKey(key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru, version);\n                }\n            }\n        } else {\n            if (type === \"ref\") {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(updateBackReferenceVersions(node, version));\n        parent[key] = node[\"\u001ef_parent\"] = undefined;\n        return true;\n    }\n    return false;\n}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar createHardlink = __webpack_require__(7);\nvar getCachePosition = __webpack_require__(10);\nvar NullInPathError = __webpack_require__(4);\nvar iterateKeySet = __webpack_require__(23);\nvar mergeValueOrInsertBranch = __webpack_require__(48);\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = setPathValues;\n\nfunction setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[\"\u001ef_parent\"] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, modelRoot, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[\"\u001ef_version\"] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n}\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        var nextOptimizedPath = arr[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(value, root, nodeArg, requestedPath, optimizedPathArg, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var node = nodeArg;\n    var reference = node.value;\n    var optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[\"\u001ef_context\"];\n\n        if (node != null) {\n            parent = node[\"\u001ef_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = arr[0];\n                optimizedPath = arr[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return;\n                }\n                parent = arr[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\u001ef_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\nfunction setNode(root, parentArg, nodeArg, key, value, branch, reference, requestedPath, optimizedPathArg, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var type = node.$type;\n    var parent = parentArg;\n    var optimizedPath = optimizedPathArg;\n\n    while (type === \"ref\") {\n\n        setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = arr[0];\n\n        if (!node || typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        optimizedPath = arr[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = updateBackReferenceVersions;\n\nfunction updateBackReferenceVersions(nodeArg, version) {\n    var node = nodeArg,\n        stack = [],\n        count = 0,\n        ref,\n        i,\n        n;\n    do {\n        i = -1;\n        ref = node[\"\u001ef_parent\"];\n        node[\"\u001ef_version\"] = version;\n        n = node[\"\u001ef_refs_length\"] || 0;\n        do {\n            if (ref && ref[\"\u001ef_version\"] !== version) {\n                stack[count++] = ref;\n            }\n            if (++i < n) {\n                ref = node[\"\u001ef_ref\" + i];\n                continue;\n            }\n            break;\n        } while (true);\n    } while (node = stack[--count]);\n    return nodeArg;\n}\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\nmodule.exports = getTimestamp;\n\nfunction getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n}\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nmodule.exports = isInternalKey;\n\nvar isInternal = __webpack_require__(20);\n\nfunction isInternalKey(key) {\n  return key && key[0] === '$' || isInternal(key);\n}\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\nmodule.exports = 0;\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toPaths = __webpack_require__(39);\nvar toCollapseMap = __webpack_require__(37);\nvar toCollapseTrees = __webpack_require__(38);\n\nmodule.exports = function collapse(paths) {\n    return toPaths(toCollapseTrees(toCollapseMap(paths)));\n};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar flatBufferToPaths = __webpack_require__(21);\n\nmodule.exports = toCollapseMap;\n\nfunction toCollapseMap(pathsArg, collapseMapArg) {\n    var paths = pathsArg,\n        collapseMap = collapseMapArg;\n    if (!collapseMap || typeof collapseMap !== 'object') {\n        collapseMap = {};\n    }\n    if (!paths) {\n        return collapseMap;\n    } else if (!isArray(paths) && isArray(paths.$keys)) {\n        paths = flatBufferToPaths(paths);\n    }\n    return paths.reduce(partitionPathsByLength, collapseMap);\n}\n\nfunction partitionPathsByLength(collapseMap, path) {\n    var length = path.length;\n    var paths = collapseMap[length] || (collapseMap[length] = []);\n    paths[paths.length] = path;\n    return collapseMap;\n}\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toTree = __webpack_require__(65);\n\nmodule.exports = toCollapseTrees;\n\nfunction toCollapseTrees(pathsByLength, treesByPathLengthArg) {\n\n    var pathLengths = Object.keys(pathsByLength);\n    var pathLength,\n        pathLengthsIndex = -1;\n    var pathLengthsCount = pathLengths.length;\n    var treesByPathLength = treesByPathLengthArg;\n\n    if (!treesByPathLength || typeof treesByPathLength !== 'object') {\n        treesByPathLength = {};\n    }\n\n    while (++pathLengthsIndex < pathLengthsCount) {\n        pathLength = pathLengths[pathLengthsIndex];\n        treesByPathLength[pathLength] = toTree(pathsByLength[pathLength], treesByPathLength[pathLength]);\n    }\n\n    return treesByPathLength;\n}\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeOfObject = 'object';\nvar typeOfString = 'string';\nvar typeOfNumber = 'number';\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\nvar getHashCode = __webpack_require__(22);\nvar materializedAtom = __webpack_require__(8);\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var subs = Object.create(null);\n    var code = '' + getHashCode('' + depth);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode, subKeys, subKeysIndex, subKeysCount, subSets, subSetsIndex, subSetsCount, pathset, pathsetIndex, pathsetCount, firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if (subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = '' + getHashCode(code + key + subCode);\n\n            isSafeNumber(key) && subPath.keys.push(parseInt(key, 10)) || subPath.keys.push(key);\n        }\n\n        while (++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = '' + getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {'from':1, 'to':6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/) {\n                isSparseRange = false;\n                break;\n            }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to '==='.\n        if (to - from <= keyCount) {\n            return { from: from, to: to };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === materializedAtom) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar walkPathAndBuildOutput = __webpack_require__(73);\nvar walkFlatBufferAndBuildOutput = __webpack_require__(72);\nvar getBoundCacheNode = __webpack_require__(17);\nvar InvalidModelError = __webpack_require__(90);\nvar toFlatBuffer = __webpack_require__(64);\nvar computeFlatBufferHash = __webpack_require__(62);\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, pathsArg, seed, progressive, expireImmediate) {\n\n    var node,\n        paths = pathsArg,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        materialized = seed && model._materialized,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame,\n        results = { args: null, data: seed, hasValue: false,\n        relative: null, requested: null, missing: null };\n\n    var arr,\n        path,\n        pathsIndex = 0,\n        pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n\n        if (recycleJSON) {\n            isFlatBuffer = true;\n            if (pathsCount > 1 && expireImmediate || isArray(paths[0])) {\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n            pathsCount = 1;\n        }\n\n        do {\n            path = paths[pathsIndex];\n            if (isFlatBuffer) {\n                arr = walkFlatBufferAndBuildOutput(cache, node, json, paths[0], 0, seed, results, requestedPath, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            } else {\n                requestedLength = path.length;\n                arr = walkPathAndBuildOutput(cache, node, json, path,\n                /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            }\n            json = arr[0];\n            arr[0] = undefined;\n            arr[1] = undefined;\n        } while (++pathsIndex < pathsCount);\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar promote = __webpack_require__(13);\nvar isExpired = __webpack_require__(0);\nvar createHardlink = __webpack_require__(7);\nvar CircularReferenceError = __webpack_require__(52);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, refArg, modelRoot, expireImmediate) {\n\n    promote(modelRoot, refArg);\n\n    var context,\n        ref = refArg,\n        key,\n        type,\n        depth = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\u001ef_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === \"ref\") {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(1);\nvar onError = __webpack_require__(71);\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues) {\n\n    if (\"error\" === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath, fromReference, boxValues);\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    return !boxValues ? node.value : clone(node);\n}\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar walkPathAndBuildOutput = __webpack_require__(76);\nvar BoundJSONGraphModelError = __webpack_require__(88);\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        pathsIndex = -1,\n        pathsCount = paths.length,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        results = { args: null, data: seed, paths: null,\n        relative: null, requested: null, jsonGraph: null };\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n        /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n        /* fromReference = */false, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args = results.relative = results.requested;\n\n    return results;\n}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar clone = __webpack_require__(1);\nvar FalcorJSON = __webpack_require__(3);\nvar NullInPathError = __webpack_require__(4);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(8);\n\nmodule.exports = onMaterialize;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterialize(jsonArg, path, depth, length, branchSelector, boxValues, modelRoot) {\n\n    var json = jsonArg,\n        type,\n        refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (depth === length) {\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta;\n\n    var nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0;\n\n    keyset = path[depth];\n\n    if (!json || 'object' !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[\"\u001ef_meta\"] = f_meta = {};\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[\"\u001ef_meta\"])) {\n        json[\"\u001ef_meta\"] = f_meta = {};\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n    } else {\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            // insert the materialized branch\n            json[nextKey] = onMaterialize(json[nextKey], path, nextDepth, length, branchSelector, boxValues, modelRoot);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isPathValue = __webpack_require__(102);\nvar isJSONEnvelope = __webpack_require__(57);\nvar isJSONGraphEnvelope = __webpack_require__(58);\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = 'PathValues';\n        } else if (isPathValue(arg)) {\n            argType = 'PathValues';\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = 'JSONGraphs';\n        } else if (isJSONEnvelope(arg)) {\n            argType = 'PathMaps';\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = insertNode;\n\nfunction insertNode(node, parent, key, version, optimizedPath) {\n    node[\"\u001ef_key\"] = key;\n    node[\"\u001ef_parent\"] = parent;\n\n    if (version !== undefined) {\n        node[\"\u001ef_version\"] = version;\n    }\n    if (!node[\"\u001ef_abs_path\"]) {\n        node[\"\u001ef_abs_path\"] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n}\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar lruPromote = __webpack_require__(13);\nvar getSize = __webpack_require__(9);\nvar createHardlink = __webpack_require__(7);\nvar getBoundCacheNode = __webpack_require__(17);\nvar isInternalKey = __webpack_require__(33);\nvar updateNodeAncestors = __webpack_require__(11);\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = invalidatePathMaps;\n\nfunction invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathMapIndex = -1;\n    var parent = node[\"\u001ef_parent\"] || cache;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[\"\u001ef_version\"] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (!isInternalKey(key)) {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, expireImmediate);\n            var nextNode = arr[0];\n            var nextParent = arr[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, expireImmediate);\n                } else {\n                    updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, nodeArg, version, expired, lru, comparator, expireImmediate) {\n\n    var node = nodeArg;\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\u001ef_context\"];\n\n    if (node != null) {\n        parent = node[\"\u001ef_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, expireImmediate);\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[\"\u001ef_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\nfunction invalidateNode(root, parentArg, nodeArg, key, value, branch, reference, version, expired, lru, comparator, expireImmediate) {\n\n    var node = nodeArg;\n    var parent = parentArg;\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[\"\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $now = __webpack_require__(34);\nvar getType = __webpack_require__(101);\nvar getSize = __webpack_require__(9);\nvar getTimestamp = __webpack_require__(32);\n\nvar wrapNode = __webpack_require__(51);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(2);\nvar insertNode = __webpack_require__(46);\nvar replaceNode = __webpack_require__(50);\nvar reconstructPath = __webpack_require__(49);\nvar updateNodeAncestors = __webpack_require__(11);\nvar removeNodeAndDescendants = __webpack_require__(29);\n\nmodule.exports = mergeValueOrInsertBranch;\n\nfunction mergeValueOrInsertBranch(parentArg, nodeArg, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var parent = parentArg;\n    var cType = getType(node, reference);\n\n    if (branch || reference) {\n        if (cType && isExpired(node,\n        /* expireImmediate:\n         * force true so the node is marked as\n         * expired but keep using it for the merge if it expires immediately\n         */\n        true)) {\n            expireNode(node, expired, lru);\n            cType = node.$expires === $now ? cType : 'expired';\n        }\n        if (cType && cType !== \"ref\" || !node || typeof node !== 'object') {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var isDistinct = true;\n        var mType = getType(message);\n\n        // If both the cache and message are primitives,\n        // insert the message into the cache.\n        if (!cType && !mType) {\n            isDistinct = true;\n        }\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        else if (comparator) {\n                isDistinct = !(comparator.length < 3 ? comparator(node, message) : comparator(node, message, optimizedPath.slice(0, optimizedPath.index)));\n            } else {\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n            }\n\n        if (isDistinct) {\n\n            if (errorSelector && mType === \"error\") {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            var sizeOffset = getSize(node) - getSize(message = wrapNode(message, mType, mType ? message.value : message));\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = reconstructPath;\n\nfunction reconstructPath(currentPath, key) {\n\n  var path = currentPath.slice(0, currentPath.depth);\n  path[path.length] = key;\n\n  return path;\n}\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar transferBackReferences = __webpack_require__(83);\nvar removeNodeAndDescendants = __webpack_require__(29);\nvar updateBackReferenceVersions = __webpack_require__(31);\n\nmodule.exports = replaceNode;\n\nfunction replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n}\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar now = __webpack_require__(59);\nvar clone = __webpack_require__(99);\nvar getSize = __webpack_require__(9);\nvar getExpires = __webpack_require__(100);\nvar expiresNow = __webpack_require__(34);\n\nvar atomSize = 50;\n\nmodule.exports = wrapNode;\n\nfunction wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[\"\u001ef_wrapped_value\"];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[\"\u001ef_prev\"] = undefined;\n        node[\"\u001ef_next\"] = undefined;\n        node[\"\u001ef_wrapped_value\"] = modelCreated || false;\n    } else {\n        node = { $type: \"atom\", value: value };\n        node[\"\u001ef_prev\"] = undefined;\n        node[\"\u001ef_next\"] = undefined;\n        node[\"\u001ef_wrapped_value\"] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case 'object':\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case 'string':\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === 'number' && expires < expiresNow) {\n        node.$expires = now() + expires * -1;\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\n\nmodule.exports = createErrorClass('CircularReferenceError', function (referencePath) {\n    this.message = 'Encountered circular reference ' + JSON.stringify(referencePath);\n});\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\nvar MESSAGE = 'An exception was thrown when making a request';\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidSourceError', function (error) {\n  this.message = MESSAGE + ':\\n\\t' + error;\n});\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = lruSplice;\n\nfunction lruSplice(lru, node) {\n\n    // Its in the cache.  Splice out.\n    var prev = node[\"\u001ef_prev\"];\n    var next = node[\"\u001ef_next\"];\n    if (next) {\n        next[\"\u001ef_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\u001ef_next\"] = next;\n    }\n    node[\"\u001ef_prev\"] = node[\"\u001ef_next\"] = undefined;\n\n    if (node === lru[\"\u001ef_head\"]) {\n        lru[\"\u001ef_head\"] = next;\n    }\n    if (node === lru[\"\u001ef_tail\"]) {\n        lru[\"\u001ef_tail\"] = prev;\n    }\n}\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\nvar $$observable = __webpack_require__(103).default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function () {\n    return this;\n};\n\nSource.prototype.operator = function (destination) {\n    return this.subscribe(destination);\n};\n\n// Unused\n// Source.prototype.lift = function(operator, source) {\n//     source = new Source(source || this);\n//     source.operator = operator;\n//     source._promise = this._promise;\n//     return source;\n// }\n\nSource.prototype.subscribe = function (destination, x, y) {\n    return new Subscription([this.operator.call(this.source, !(destination instanceof Subscriber) ? new Subscriber(destination, x, y) : destination)]);\n};\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function (resolve, reject) {\n            var values = [],\n                rejected = false;\n            source.subscribe({\n                next: function (value) {\n                    values[values.length] = value;\n                },\n                error: function (errors) {\n                    (rejected = true) && reject(errors);\n                },\n                complete: function () {\n                    !rejected && resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\nvar empty = {\n    dispose: function () {},\n    unsubscribe: function () {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\n\nmodule.exports = isJSONEnvelope;\n\nfunction isJSONEnvelope(envelope) {\n    return isObject(envelope) && 'json' in envelope;\n}\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(6);\n\nmodule.exports = isJSONGraphEnvelope;\n\nfunction isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));\n}\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\nmodule.exports = Date.now;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\nmodule.exports = 1;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Model = __webpack_require__(66);\nvar FalcorJSON = __webpack_require__(3);\n\nfunction falcor(opts) {\n    if (!(this instanceof Model)) {\n        return new Model(opts);\n    }\n    Model.call(this, opts);\n}\n\nfalcor.prototype = Object.create(Model.prototype);\n\nfalcor['Model'] = Model;\nfalcor['FalcorJSON'] = FalcorJSON;\nfalcor['toProps'] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar getHashCode = __webpack_require__(22);\n\nmodule.exports = computeFlatBufferHash;\n\nfunction computeFlatBufferHash(seed) {\n\n    if (seed === undefined) {\n        return undefined;\n    }\n\n    var code = '';\n    var keys = seed['$keys'];\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    while (++keysIndex < keysLength) {\n\n        var key = keys[keysIndex];\n\n        if (key === null) {\n            code = '' + getHashCode('' + code + 'null');\n            continue;\n        } else if (typeof key === 'object') {\n            key = '[' + key.from + '..' + (key.from + key.length - 1) + ']';\n        }\n\n        var next = computeFlatBufferHash(seed[keysIndex]);\n        if (next === undefined) {\n            code = '' + getHashCode('' + code + key);\n        } else {\n            code = '' + getHashCode('' + code + key + next['$code']);\n        }\n    }\n\n    seed['$code'] = code;\n\n    return seed;\n}\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar materializedAtom = __webpack_require__(8);\n\nmodule.exports = hasIntersection;\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var next,\n        nextKey,\n        nextDepth = depth + 1,\n        keyIsRange,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar nullBuffer = { '$keys': [null], '$keysMap': { 'null': 0 } };\nvar flatBufferToPaths = __webpack_require__(21);\n\nmodule.exports = toFlatBuffer;\n\nfunction toFlatBuffer(paths, seed) {\n    return paths.reduce(function (seed, path) {\n        if (isArray(path)) {\n            return pathToFlatBuffer(seed, path, 0, path.length);\n        } else if (isArray(path.$keys)) {\n            return toFlatBuffer(flatBufferToPaths(path), seed);\n        }\n        return seed;\n    }, seed || {});\n}\n\nfunction pathToFlatBuffer(seed, path, depth, length) {\n\n    if (depth === length) {\n        return undefined;\n    }\n\n    seed = seed || {};\n    var keys = seed['$keys'] || (seed['$keys'] = []);\n    var keysMap = seed['$keysMap'] || (seed['$keysMap'] = {});\n    var keysIndex = -1;\n\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var node,\n        next,\n        nextKey,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullBuffer;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = nextKey;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyset = { from: nextKey, length: rangeEnd - nextKey + 1 };\n                    nextKey = '[' + nextKey + '..' + rangeEnd + ']';\n                    if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                        keysIndex = keys.length;\n                    }\n                    keys[keysIndex] = keyset;\n                    keysMap[nextKey] = keysIndex;\n                    next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n                    if (next !== undefined) {\n                        seed[keysIndex] = next;\n                    }\n                }\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar materializedAtom = __webpack_require__(8);\n\nmodule.exports = toTree;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\n\nfunction toTree(paths, seed) {\n    return paths.reduce(function (seed, path) {\n        return pathToTree(seed, path, 0, path.length, null);\n    }, seed || {});\n};\n\nfunction pathToTree(seed, path, depth, length, value) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    seed = seed || {};\n\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var node,\n        next,\n        nextKey,\n        nextDepth = depth + 1,\n        keyIsRange,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = value;\n            } else {\n                node = seed[nextKey];\n                next = pathToTree(node, path, nextDepth, length, value);\n                if (!next) {\n                    seed[nextKey] = value;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Call = __webpack_require__(94);\nvar ModelRoot = __webpack_require__(68);\nvar FalcorJSON = __webpack_require__(3);\nvar ModelDataSourceAdapter = __webpack_require__(67);\nvar TimeoutScheduler = __webpack_require__(98);\nvar ImmediateScheduler = __webpack_require__(56);\nvar collapse = __webpack_require__(36);\n\nvar getSize = __webpack_require__(9);\nvar isObject = __webpack_require__(6);\nvar isJSONEnvelope = __webpack_require__(57);\nvar getCachePosition = __webpack_require__(10);\nvar isJSONGraphEnvelope = __webpack_require__(58);\n\nvar setCache = __webpack_require__(19);\nvar setJSONGraphs = __webpack_require__(18);\n\nvar getJSON = __webpack_require__(24);\nvar getCache = __webpack_require__(78);\nvar getJSONGraph = __webpack_require__(25);\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n/**\n* This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n* @callback Model~errorSelector\n* @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n* @returns {Object} the JSONGraph Error object to store in the Model cache.\n*/\n\n/**\n* This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n* @callback Model~comparator\n* @param {Object} existingValue - the current value in the Model cache.\n* @param {Object} newValue - the value about to be set into the Model cache.\n* @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n*/\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._treatErrorsAsValues = true;\n        this._seed = {};\n        this._seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get() {\n    var seed = this._seed;\n    if (!seed) {\n        seed = {};\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    return new Call('get', this, args)._toJSON(seed, []);\n};\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set() {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n    }\n\n    return new Call('set', this, args)._toJSON(seed, []);\n};\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n    }\n\n    return new Call('get', this, args)._toJSON(null, []);\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call() {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n    }\n\n    return new Call('call', this, args)._toJSON(seed, []);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n    }\n\n    return new Call('invalidate', this, args)._toJSON(null, null).then();\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.deref = __webpack_require__(87);\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a request\n * from the parent should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update where the model is bound.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = __webpack_require__(86);\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return new Call('get', this, [path])._toJSON({}, []).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : { path: path, value: value };\n    return new Call('set', this, [value])._toJSON({}, []).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n\n    var modelRoot = this._root;\n    var cache = modelRoot.cache;\n\n    if (cacheOrJSONGraphEnvelope !== cache) {\n\n        var options = {\n            _path: [],\n            _boxed: false,\n            _root: modelRoot,\n            _materialized: false,\n            _treatErrorsAsValues: false\n        };\n\n        modelRoot.cache = this._node = {};\n\n        if (typeof cache !== 'undefined') {\n            modelRoot.expired = [];\n            modelRoot[\"\u001ef_head\"] = undefined;\n            modelRoot[\"\u001ef_tail\"] = undefined;\n            if (this._recycleJSON) {\n                this._seed = {};\n                this._seed.__proto__ = FalcorJSON.prototype;\n            }\n        }\n\n        var results, rootOnChangeHandler;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setJSONGraphs(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [{ json: cacheOrJSONGraphEnvelope }]);\n        }\n\n        if (results) {\n            // performs promotion without producing output.\n            if (results[0].length) {\n                getJSON(options, results[0], null, false, false);\n            }\n            if (results[2] && (rootOnChangeHandler = modelRoot.onChange)) {\n                rootOnChangeHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    } else if (typeof cache === 'undefined') {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache('genreLists[0...10][0...10].boxshot')));\n */\nModel.prototype.getCache = function _getCache() {\n    for (var _len6 = arguments.length, paths = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        paths[_key6] = arguments[_key6];\n    }\n\n    if (paths.length === 0) {\n        return getCache(this, this._root.cache);\n    }\n\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    var env = getJSONGraph({\n        _path: [],\n        _root: this._root,\n        _boxed: this._boxed,\n        _materialized: this._materialized,\n        _treatErrorsAsValues: this._treatErrorsAsValues\n    }, paths, seed).data;\n\n    env.paths = collapse(paths);\n\n    return env;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path) {\n    path = path || [];\n    if (Array.isArray(path) === false) {\n        throw new Error('Model#getVersion must be called with an Array path.');\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === 'delete') {\n                delete clone[key];\n            } else if (key === '_path') {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty('_node')) {\n                    delete clone['_node'];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === 'number') {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: 'Steve',\n                surname: 'McGuire'\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints 'Steve'\nproxyModel.getValue('user.name').\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: 'delete'\n    });\n};\n\n/* implement inspect method for node's inspect utility */\nModel.prototype.inspect = function inspect() {\n    return '{ v: ' + this.getVersion() + ' p: [' + this._path.join(', ') + '] }';\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: 'ref',\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[\"\u001ef_abs_path\"] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = __webpack_require__(79);\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = __webpack_require__(30);\nModel.prototype._setPathMaps = __webpack_require__(19);\nModel.prototype._setJSONGs = __webpack_require__(18);\nModel.prototype._setCache = __webpack_require__(19);\n\nModel.prototype._invalidatePathValues = __webpack_require__(28);\nModel.prototype._invalidatePathMaps = __webpack_require__(47);\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\nfunction ModelDataSourceAdapter(model) {\n    this._model = model\n    // .boxValues()\n    ._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [path, args, suffixes].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar functionTypeof = 'function';\nvar Requests = __webpack_require__(95);\nvar getTimestamp = __webpack_require__(32);\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = -1;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nfunction defaultCompare(node, message) {\n    var cType = node && node.$type;\n    var mType = message && message.$type;\n    if (cType) {\n        // If the cache has a type, but the message is a primitive,\n        // the message might be the primitive response from the datasource.\n        // If so, return true, so we don't update the back-reference versions.\n        if (!mType) {\n            return node.value === message;\n        }\n        // If the message is older than the cache node, then isDistinct = false\n        else if (getTimestamp(message) < getTimestamp(node) === true) {\n                return true; // isDistinct = false\n            }\n        // Otherwise they are the same if all the following fields are the same.\n        return !(cType !== mType || node.value !== message.value || node.$expires !== message.$expires);\n    }\n    // If cache doesn't have a type but the message\n    // does, they must be different.\n    else if (mType) {\n            return false;\n        }\n    return node === message;\n}\n\nModelRoot.comparator = ModelRoot.prototype.comparator = defaultCompare;\n\nmodule.exports = ModelRoot;\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(24);\nvar getJSONGraph = __webpack_require__(25);\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n    json: __webpack_require__(40),\n    jsonGraph: __webpack_require__(43)\n};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(1);\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results, requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar onValue = __webpack_require__(42);\nvar FalcorJSON = __webpack_require__(3);\nvar isExpired = __webpack_require__(0);\nvar onValueType = __webpack_require__(16);\nvar originalOnMissing = __webpack_require__(27);\nvar getReferenceTarget = __webpack_require__(41);\nvar onMaterialize = __webpack_require__(77);\nvar NullInPathError = __webpack_require__(4);\nvar InvalidKeySetError = __webpack_require__(12);\nvar getHashCode = __webpack_require__(22);\nvar flatBufferToPaths = __webpack_require__(21);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, jsonArg, path, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReferenceArg, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var json = jsonArg,\n        type,\n        refTarget;\n    var fromReference = fromReferenceArg;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node || undefined !== (type = node.$type) || undefined === path) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json, path, depth, seed, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta,\n        f_old_keys,\n        f_new_keys,\n        f_code = '';\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        keys = path['$keys'],\n        nodeAbsPath,\n        jsonAbsPath,\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextJSON,\n        nextReferenceContainer,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\u001ef_abs_path\"];\n    }\n\n    if (!json || 'object' !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[\"\u001ef_meta\"]) {\n\n        nodeAbsPath = node[\"\u001ef_abs_path\"];\n        jsonAbsPath = f_meta[\"abs_path\"];\n\n        if (!branchSelector && !(json instanceof FalcorJSON)) {\n            json.__proto__ = {};\n            json.__proto__[\"\u001ef_meta\"] = f_meta;\n            json.__proto__.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (!arrayEqual(nodeAbsPath, jsonAbsPath)) {\n            f_meta['$code'] = '';\n            f_meta[\"status\"] = 'pending';\n            f_meta[\"abs_path\"] = nodeAbsPath;\n            f_meta[\"version\"] = node[\"\u001ef_version\"];\n            refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n            refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n            if (f_old_keys = f_meta[\"keys\"]) {\n                f_meta[\"keys\"] = Object.create(null);\n                for (nextKey in f_old_keys) {\n                    if (f_old_keys[nextKey]) {\n                        delete json[nextKey];\n                    }\n                }\n            }\n            arr[0] = json;\n            arr[1] = true;\n            return arr;\n        } else if (!(f_meta[\"version\"] !== node[\"\u001ef_version\"] || f_meta['$code'] !== path['$code'])) {\n            results.hasValue = true;\n            arr[0] = json;\n            arr[1] = false;\n            return arr;\n        }\n\n        f_old_keys = f_meta[\"keys\"];\n        f_meta[\"abs_path\"] = nodeAbsPath;\n        f_meta[\"version\"] = node[\"\u001ef_version\"];\n        refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n    }\n\n    f_new_keys = Object.create(null);\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath,\n        nextPathKey,\n        hasMissingPath = false;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = '' + getHashCode('' + f_code + 'null');\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if ('object' !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n                nextPathKey = nextKey;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                    nextPathKey = '[' + nextKey + '..' + rangeEnd + ']';\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextPath === undefined) {\n\n                walkPathAndBuildOutput(root, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            } else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                walkPathAndBuildOutput(root, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[\"version\"] = node[\"\u001ef_version\"];\n                f_meta[\"abs_path\"] = node[\"\u001ef_abs_path\"];\n                refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n                json = {};\n                json[\"\u001ef_meta\"] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                } else {\n                    var tmp = json;\n                    json = {};\n                    json.__proto__ = tmp;\n                    tmp = undefined;\n                }\n            }\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && nextKey in f_old_keys) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        f_code = '' + getHashCode('' + f_code + (!hasMissingPath ? nextPathKey : '') + (nextPath ? nextPath['$code'] : ''));\n    }\n\n    if (f_meta) {\n        f_meta['$code'] = f_code;\n        f_meta[\"keys\"] = f_new_keys;\n        f_meta[\"status\"] = hasMissingPath && 'pending' || 'resolved';\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, json, branchSelector, boxValues, onMaterialize, modelRoot) {\n\n    if (reportMaterialized) {\n        return onMaterialize(json, path, depth, depth, branchSelector, boxValues, modelRoot, results, requestedPath, optimizedPath, optimizedLength, fromReference, reportMissing, onMissing);\n    }\n\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n\n    return paths.forEach(function (restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, false, json, branchSelector, boxValues, onMaterialize, modelRoot);\n    });\n}\n\nfunction arrayEqual(xs, ys) {\n    if (xs === ys) {\n        return true;\n    }\n    var len = xs.length;\n    if (len !== ys.length) {\n        return false;\n    }\n    while (~--len) {\n        if (xs[len] !== ys[len]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isArray = Array.isArray;\nvar onValue = __webpack_require__(42);\nvar onMissing = __webpack_require__(27);\nvar FalcorJSON = __webpack_require__(3);\nvar onValueType = __webpack_require__(16);\nvar isExpired = __webpack_require__(0);\nvar onMaterialize = __webpack_require__(44);\nvar getReferenceTarget = __webpack_require__(41);\nvar NullInPathError = __webpack_require__(4);\nvar InvalidKeySetError = __webpack_require__(12);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, jsonArg, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReferenceArg, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var json = jsonArg,\n        type,\n        refTarget;\n    var fromReference = fromReferenceArg;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta;\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        nextJSON,\n        nextReferenceContainer,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        arr[0] = json;\n        arr[1] = false;\n        return arr;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\u001ef_abs_path\"];\n    }\n\n    if (!json || 'object' !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[\"\u001ef_meta\"]) {\n        f_meta[\"version\"] = node[\"\u001ef_version\"];\n        f_meta[\"abs_path\"] = node[\"\u001ef_abs_path\"];\n        refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    var hasMissingPath = false;\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextDepth === requestedLength) {\n\n                walkPathAndBuildOutput(root, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    continue;\n                }\n            } else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                walkPathAndBuildOutput(root, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[\"version\"] = node[\"\u001ef_version\"];\n                f_meta[\"abs_path\"] = node[\"\u001ef_abs_path\"];\n                refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n                json = {};\n                json[\"\u001ef_meta\"] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                }\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    if (f_meta) {\n        f_meta[\"status\"] = hasMissingPath && 'pending' || 'resolved';\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar clone = __webpack_require__(1);\nvar inlineValue = __webpack_require__(26);\nvar promote = __webpack_require__(13);\nvar isExpired = __webpack_require__(0);\nvar createHardlink = __webpack_require__(7);\nvar CircularReferenceError = __webpack_require__(52);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, refArg, modelRoot, seed, expireImmediate) {\n\n    promote(modelRoot, refArg);\n\n    var context,\n        ref = refArg,\n        key,\n        type,\n        depth = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\u001ef_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === \"ref\") {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(1);\nvar inlineValue = __webpack_require__(26);\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized) {\n\n    var value = node.value;\n\n    // boxValues always clones the node\n    if (boxValues || !(\n    /**\n     * JSON Graph should always clone:\n     * - refs\n     * - errors\n     * - atoms we didn't create\n     * - atoms we created to wrap Objects\n     **/\n    \"ref\" !== type && \"error\" !== type && node[\"\u001ef_wrapped_value\"] && 'object' !== typeof value)) {\n        value = clone(node);\n    }\n\n    results.hasValue = true;\n    inlineValue(value, optimizedPath, optimizedLength, seed);\n    (seed.paths || (seed.paths = [])).push(requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n    );\n\n    return value;\n}\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar clone = __webpack_require__(1);\nvar onValue = __webpack_require__(75);\nvar inlineValue = __webpack_require__(26);\nvar isExpired = __webpack_require__(0);\nvar onValueType = __webpack_require__(16);\nvar onMaterialize = __webpack_require__(44);\nvar originalOnMissing = __webpack_require__(27);\nvar getReferenceTarget = __webpack_require__(74);\nvar NullInPathError = __webpack_require__(4);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(8);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReferenceArg, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n    var fromReference = fromReferenceArg;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, seed, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, undefined, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                keyset = keysOrRanges[keysetIndex];\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(root, next, modelRoot, seed, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(root, next, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, seed, branchSelector, boxValues, onMaterialize, modelRoot) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push((isLeaf = 0 === requestedLength - depth) &&\n        // depth + 1 if fromReference === true\n        requestedPath.slice(0, depth + !!fromReference) || requestedPath.slice(0, depth).concat(path.slice(depth, requestedLength + !!fromReference)));\n\n        json = inlineValue(isLeaf && clone(materializedAtom) || undefined, optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, !isLeaf && reportMaterialized, json, branchSelector, true, onMaterialize, modelRoot);\n}\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(1);\nvar onValueType = __webpack_require__(16);\nvar FalcorJSON = __webpack_require__(3);\nvar NullInPathError = __webpack_require__(4);\nvar InvalidKeySetError = __webpack_require__(12);\nvar materializedAtom = __webpack_require__(8);\n\nmodule.exports = onMaterializeFlatBuffer;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterializeFlatBuffer(jsonArg, path, depth, length, branchSelector, boxValues, modelRoot, results, requestedPath, optimizedPath, optimizedLength, fromReference, reportMissing, onMissing) {\n\n    var json = jsonArg,\n        type,\n        refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === path) {\n        onValueType(undefined, undefined, json, path, depth, undefined, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, modelRoot, undefined, false, branchSelector, boxValues, false, reportMissing, false, undefined, onMissing, undefined);\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta, f_old_keys, f_new_keys;\n\n    var nextKey,\n        keyset,\n        keyIsRange,\n        keys = path['$keys'],\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextOptimizedLength = optimizedLength + 1;\n\n    if (!json || 'object' !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[\"\u001ef_meta\"] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[\"\u001ef_meta\"])) {\n        json[\"\u001ef_meta\"] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n    } else {\n        f_old_keys = f_meta[\"keys\"];\n        f_meta['$code'] = '';\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n    }\n\n    f_new_keys = Object.create(null);\n\n    var nextPath;\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if ('object' !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && nextKey in f_old_keys) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // insert the materialized branch\n            json[nextKey] = onMaterializeFlatBuffer(json[nextKey], nextPath, nextDepth, nextDepth, branchSelector, boxValues, modelRoot, results, requestedPath, optimizedPath, nextOptimizedLength, fromReference, reportMissing, onMissing);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n    }\n\n    f_meta[\"keys\"] = f_new_keys;\n    if (f_old_keys) {\n        for (nextKey in f_old_keys) {\n            if (f_old_keys[nextKey]) {\n                delete json[nextKey];\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(1);\nvar isInternal = __webpack_require__(20);\n\nmodule.exports = getCache;\n\nfunction getCache(model, cache) {\n    return getCacheInternal(cache, {}, model._boxed, model._materialized);\n}\n\nfunction getCacheInternal(node, jsonArg, boxValues, materialized) {\n\n    var json = jsonArg,\n        type,\n        value;\n\n    if (!node || typeof node !== 'object') {\n        return node;\n    } else if (type = node.$type) {\n\n        if (undefined === (value = node.value)) {\n            if (materialized) {\n                value = { $type: \"atom\" };\n            } else if (node[\"\u001ef_wrapped_value\"]) {\n                value = clone(node);\n            }\n        }\n        // boxValues always clones the node\n        else if (boxValues || !(\n            /**\n             * getCache should always clone:\n             * - refs\n             * - errors\n             * - atoms we didn't create\n             * - atoms we created to wrap Objects\n             **/\n            \"ref\" !== type && \"error\" !== type && node[\"\u001ef_wrapped_value\"] && typeof value !== 'object')) {\n                value = clone(node);\n            }\n        return value;\n    }\n\n    var keys = Object.keys(node);\n    var keysLen = keys.length,\n        keyIndex = -1;\n\n    while (++keyIndex < keysLen) {\n        var key = keys[keyIndex];\n        if (key !== '$size' && !isInternal(key) && undefined !== (value = getCacheInternal(node[key], json && json[key], boxValues, materialized))) {\n            if (json === undefined) {\n                json = {};\n            }\n            json[key] = value;\n        }\n    }\n\n    return json;\n}\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getBoundCacheNode = __webpack_require__(17);\n\nmodule.exports = getVersion;\n\nfunction getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[\"\u001ef_version\"];\n    return version == null ? -1 : version;\n}\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar groupCacheArguments = __webpack_require__(45);\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n    invalidatePathMaps: __webpack_require__(47),\n    invalidatePathValues: __webpack_require__(28)\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    if (invalidateArgumentGroups(model, groupCacheArguments(args), expireImmediate)) {\n        var rootChangeHandler = model._root.onChange;\n        rootChangeHandler && rootChangeHandler.call(model._root.topLevelModel);\n    }\n    return {};\n}\n\nfunction invalidateArgumentGroups(model, xs, expireImmediate) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            if (inputType === 'PathValues') {\n                groupedArgs = groupedArgs.map(pluckPaths);\n            }\n            var operation = module.exports['invalidate' + inputType];\n            if (operation(model, groupedArgs, expireImmediate)) {\n                changed = true;\n            }\n        }\n    }\n    return changed;\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar wrapNode = __webpack_require__(51);\nvar isExpired = __webpack_require__(0);\nvar insertNode = __webpack_require__(46);\nvar expireNode = __webpack_require__(2);\nvar replaceNode = __webpack_require__(50);\nvar getSize = __webpack_require__(9);\nvar reconstructPath = __webpack_require__(49);\nvar getTimestamp = __webpack_require__(32);\nvar updateNodeAncestors = __webpack_require__(11);\n\nmodule.exports = mergeJSONGraphNode;\n\nfunction mergeJSONGraphNode(parentArg, nodeArg, messageArg, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n    var node = nodeArg;\n    var parent = parentArg;\n    var message = messageArg;\n\n    var cType, mType, cIsObject, mIsObject, cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // The message and cache are both undefined, return undefined.\n        if (message === undefined) {\n            return message;\n        }\n        // There should not be undefined values. Those should always be\n        // wrapped in an $atom\n        else if (message === null) {\n                node = wrapNode(message, undefined, message);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, undefined, optimizedPath);\n                return node;\n            }\n            // Is the cache node a branch? If so, return the cache branch.\n            else if ((cIsObject = !(!node || typeof node !== 'object')) && (cType = node.$type) === undefined) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node[\"\u001ef_parent\"] === undefined) {\n                        insertNode(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n    } else if (cIsObject = !(!node || typeof node !== 'object')) {\n        cType = node.$type;\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== \"ref\") {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || mIsObject && !mType) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n            // If the cache is a reference, but the message is empty,\n            // leave the cache alone...\n            if (message == null) {\n                // ...unless the cache is an expired reference. In that case, expire\n                // the cache node and return undefined.\n                if (isExpired(node, expireImmediate)) {\n                    expireNode(node, expired, lru);\n                    return void 0;\n                }\n                return node;\n            }\n            mIsObject = !(!message || typeof message !== 'object');\n            if (mIsObject) {\n                mType = message.$type;\n                // If the cache and the message are both references,\n                // check if we need to replace the cache reference.\n                if (mType === \"ref\") {\n                    if (node === message) {\n                        // If the cache and message are the same reference,\n                        // we performed a whole-branch merge of one of the\n                        // grandparents. If we've previously graphed this\n                        // reference, break early. Otherwise, continue to\n                        // leaf insertion below.\n                        if (node[\"\u001ef_parent\"] != null) {\n                            return node;\n                        }\n                    } else {\n\n                        cTimestamp = node.$timestamp;\n                        mTimestamp = message.$timestamp;\n\n                        // - If either the cache or message reference is expired,\n                        //   replace the cache reference with the message.\n                        // - If neither of the references are expired, compare their\n                        //   timestamps. If either of them don't have a timestamp,\n                        //   or the message's timestamp is newer, replace the cache\n                        //   reference with the message reference.\n                        // - If the message reference is older than the cache\n                        //   reference, short-circuit.\n                        if (!isExpired(node, expireImmediate) && !isExpired(message, expireImmediate) && mTimestamp < cTimestamp) {\n                            return void 0;\n                        }\n                    }\n                }\n            }\n        }\n\n    // If the cache is a leaf but the message is a branch,\n    // merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n\n            if (mType === \"error\" && errorSelector) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            // If the cache and the message are the same value, we branch-merged one\n            // of the message's ancestors. If this is the first time we've seen this\n            // leaf, give the message a $size and $type, attach its graph pointers,\n            // and update the cache sizes and versions.\n            if (mType && node === message) {\n                if (!node[\"\u001ef_parent\"]) {\n                    node = wrapNode(node, cType, node.value);\n                    parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                    node = insertNode(node, parent, key, version, optimizedPath);\n                }\n            }\n            // If the cache and message are different, the cache value is expired,\n            // or the message is a primitive, replace the cache with the message value.\n            // If the message is a sentinel, clone and maintain its type.\n            // If the message is a primitive value, wrap it in an atom.\n            else {\n                    var isDistinct = true;\n                    // If both the cache and message are primitives, we branch-merged\n                    // one of the message's ancestors. Insert the value into the cache.\n                    if (!cType && !mType) {\n                        isDistinct = true;\n                    }\n                    // If the cache is a branch, but the message is a leaf, replace the\n                    // cache branch with the message leaf.\n                    else if (!cIsObject || !isExpired(node, expireImmediate)) {\n                            // Compare the current cache value with the new value. If either of\n                            // them don't have a timestamp, or the message's timestamp is newer,\n                            // replace the cache value with the message value. If a comparator\n                            // is specified, the comparator takes precedence over timestamps.\n                            if (comparator) {\n                                isDistinct = !(comparator.length < 3 ? comparator(node, message) : comparator(node, message, optimizedPath.slice(0, optimizedPath.index)));\n                            } else {\n                                // Comparing either Number or undefined to undefined always results in false.\n                                isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                            }\n                        }\n                    if (isDistinct) {\n                        sizeOffset = getSize(node) - getSize(message = wrapNode(message, mType, mType ? message.value : message));\n                        node = replaceNode(node, message, parent, key, lru, version);\n                        parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                    }\n                }\n\n            // Promote the message edge in the LRU.\n            if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n                expireNode(node, expired, lru);\n            }\n        } else if (node == null) {\n            node = insertNode(message, parent, key, undefined, optimizedPath);\n        }\n\n    return node;\n};\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(24);\nvar getJSONGraph = __webpack_require__(25);\nvar groupCacheArguments = __webpack_require__(45);\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: __webpack_require__(19),\n    setPathValues: __webpack_require__(30),\n    setJSONGraphs: __webpack_require__(18)\n};\n\nfunction json(model, _args, data, progressive, expireImmediate) {\n\n    var set,\n        get,\n        jsong,\n        changed,\n        relative,\n        optimized,\n        missing,\n        fragments,\n        requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length) {\n\n        if (!(changed = set.changed) || progressive) {\n            get = getJSON(model, relative, data, progressive, expireImmediate);\n        }\n\n        if (changed) {\n\n            jsong = getJSONGraph({\n                _root: model._root,\n                _boxed: model._boxed, _materialized: true,\n                _treatErrorsAsValues: model._treatErrorsAsValues\n            }, set.optimized, {}, progressive, expireImmediate);\n\n            fragments = jsong.data;\n            missing = fragments.paths;\n            requested = jsong.requested;\n\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler.call(model._root.topLevelModel);\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: get && get.error,\n        errors: get && get.errors,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive, expireImmediate) {\n\n    var set,\n        jsong,\n        changed,\n        relative,\n        optimized,\n        missing,\n        fragments,\n        requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length && (progressive || (changed = set.changed))) {\n\n        jsong = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed, _materialized: true,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, set.optimized, data, progressive, expireImmediate);\n\n        fragments = jsong.data;\n        missing = fragments.paths;\n        requested = jsong.requested;\n\n        if (changed) {\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler.call(model._root.topLevelModel);\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: jsong && jsong.error,\n        hasValue: jsong && jsong.hasValue\n    };\n}\n\nfunction setGroupsIntoCache(model, xs, expireImmediate_) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n\n    var expireImmediate = expireImmediate_ && !Boolean(model._source);\n    var comparator = Boolean(model._source) ? null : modelRoot.comparator;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports['set' + inputType];\n            var results = operation(model, groupedArgs, errorSelector, comparator, expireImmediate);\n            changed = changed || results[2];\n            optimizedPaths.push.apply(optimizedPaths, results[1]);\n            if (inputType === 'PathValues') {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === 'JSONGraphs') {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, results[0]);\n            }\n        }\n    }\n\n    return {\n        changed: changed,\n        requested: requestedPaths,\n        optimized: optimizedPaths\n    };\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\nfunction arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n}\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = transferBackReferences;\n\nfunction transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[\"\u001ef_refs_length\"] || 0,\n        destNodeRefsLength = destNode[\"\u001ef_refs_length\"] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[\"\u001ef_ref\" + i];\n        if (ref !== undefined) {\n            ref[\"\u001ef_context\"] = destNode;\n            destNode[\"\u001ef_ref\" + (destNodeRefsLength + i)] = ref;\n            fromNode[\"\u001ef_ref\" + i] = undefined;\n        }\n    }\n    destNode[\"\u001ef_refs_length\"] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[\"\u001ef_refs_length\"] = undefined;\n    return destNode;\n}\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = unlinkBackReferences;\n\nfunction unlinkBackReferences(node) {\n    var i = -1,\n        n = node[\"\u001ef_refs_length\"] || 0;\n    while (++i < n) {\n        var ref = node[\"\u001ef_ref\" + i];\n        if (ref != null) {\n            ref[\"\u001ef_context\"] = ref[\"\u001ef_ref_index\"] = node[\"\u001ef_ref\" + i] = void 0;\n        }\n    }\n    node[\"\u001ef_refs_length\"] = void 0;\n    return node;\n}\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = unlinkForwardReference;\n\nfunction unlinkForwardReference(reference) {\n    var destination = reference[\"\u001ef_context\"];\n    if (destination) {\n        var i = (reference[\"\u001ef_ref_index\"] || 0) - 1,\n            n = (destination[\"\u001ef_refs_length\"] || 0) - 1;\n        while (++i <= n) {\n            destination[\"\u001ef_ref\" + i] = destination[\"\u001ef_ref\" + (i + 1)];\n        }\n        destination[\"\u001ef_refs_length\"] = n;\n        reference[\"\u001ef_ref_index\"] = reference[\"\u001ef_context\"] = destination = void 0;\n    }\n    return reference;\n}\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[\"\u001ef_parent\"] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[\"\u001ef_invalidated\"]) {\n        return false;\n    }\n\n    return true;\n}\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar CONTAINER_DOES_NOT_EXIST = 'e';\nvar FalcorJSON = __webpack_require__(3);\nvar getCachePosition = __webpack_require__(10);\nvar InvalidDerefInputError = __webpack_require__(89);\n\nmodule.exports = deref;\n\nfunction deref(json) {\n\n    var seed, f_meta;\n\n    if (!json || 'object' !== typeof json || !(f_meta = json[\"\u001ef_meta\"]) || 'object' !== typeof f_meta) {\n        return null;\n    }\n\n    var cacheRoot = this._root.cache;\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = f_meta[\"abs_path\"];\n    var referenceContainer, currentRefPath, i, len;\n\n    if (!absolutePath) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: undefined,\n            _seed: seed\n        });\n    } else if (absolutePath.length === 0) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: cacheRoot,\n            _path: absolutePath,\n            _referenceContainer: true,\n            _seed: seed\n        });\n    }\n\n    var originalRefPath = f_meta[\"deref_to\"];\n    var originalAbsPath = f_meta[\"deref_from\"];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === \"ref\") {\n            validContainer = true;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n            for (i = 0; i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    cacheNode = undefined;\n                    validContainer = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n            referenceContainer = true;\n        }\n\n    if (recycleJSON) {\n        seed = { json: json };\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    return this._clone({\n        _seed: seed,\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer\n    });\n};\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\nvar MESSAGE = 'It is not legal to use the JSON Graph ' + 'format from a bound Model. JSON Graph format' + ' can only be used from a root model.';\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nmodule.exports = createErrorClass('BoundJSONGraphModelError', function () {\n    this.message = MESSAGE;\n});\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\nvar MESSAGE = 'Deref can only be used with a non-primitive object from get, set, or call.';\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidDerefInputError', function () {\n  this.message = MESSAGE;\n});\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\nvar MESSAGE = 'The boundPath of the model is not valid since a value or error was found before the path end.';\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidModelError', function (boundPath, shortedPath) {\n  this.message = MESSAGE;\n  this.boundPath = boundPath;\n  this.shortedPath = shortedPath;\n});\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(5);\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nmodule.exports = createErrorClass('MaxRetryExceededError', function (maxRetryCount, absolute, relative, optimized) {\n    this.message = '' + 'Exceeded the max retry count (' + maxRetryCount + ') for these paths: \\n' + (absolute && 'absolute: [\\n\\t' + printPaths(absolute) + '\\n]\\n' || '') + (relative && 'relative: [\\n\\t' + printPaths(relative) + '\\n]\\n' || '') + (optimized && 'optimized: [\\n\\t' + printPaths(optimized) + '\\n]\\n' || '');\n});\n\nfunction printPaths(paths) {\n    return paths.map(function (path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n/***/ },\n/* 92 */\n/***/ function(module, exports) {\n\nmodule.exports = String.fromCharCode(30) + 'f_';\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar updateNodeAncestors = __webpack_require__(11);\n\nmodule.exports = collect;\n\nfunction collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== 'number') {\n        ratio = 0.75;\n    }\n\n    var node,\n        size,\n        targetSize = max * ratio;\n\n    while (node = expired.pop()) {\n        total -= size = node.$size || 0;\n        updateNodeAncestors(node, size, lru, version);\n    }\n\n    if (total >= max) {\n        var prev = lru[\"\u001ef_tail\"];\n        while (total >= targetSize && (node = prev)) {\n            prev = prev[\"\u001ef_prev\"];\n            total -= size = node.$size || 0;\n            updateNodeAncestors(node, size, lru, version);\n        }\n\n        lru[\"\u001ef_tail\"] = node;\n        if (node == null) {\n            lru[\"\u001ef_head\"] = undefined;\n        } else {\n            node[\"\u001ef_next\"] = undefined;\n        }\n    }\n}\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(55);\nvar Subscriber = __webpack_require__(14);\nvar lruCollect = __webpack_require__(93);\nvar FalcorJSON = __webpack_require__(3);\nvar collapse = __webpack_require__(36);\nvar InvalidSourceError = __webpack_require__(53);\nvar MaxRetryExceededError = __webpack_require__(91);\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function (operator, source) {\n    source = new Call(source || this);\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    source.operator = operator;\n    operator.data = operator.data || this.operator.data;\n    operator.errors = operator.errors || this.operator.errors;\n    operator.operation = operator.operation || this.operator.operation;\n    operator.progressive = operator.progressive || this.operator.progressive;\n    operator.maxRetryCount = operator.maxRetryCount || this.operator.maxRetryCount;\n    return source;\n};\n\nCall.prototype.operator = function (subscriber) {\n    return this._subscribe(subscriber);\n};\n\nCall.prototype._subscribe = function (subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n};\n\nCall.prototype._toJSON = function (dataArg, errors) {\n    var data = dataArg;\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(data, errors || this.operator.errors, 'json', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype._toJSONG = function (dataArg, errors) {\n    var data = dataArg;\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(data, errors || this.operator.errors, 'jsonGraph', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype.retry = function (maxRetryCount) {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, this.operator.progresive, maxRetryCount), this.source);\n};\n\nCall.prototype.progressively = function () {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, true, this.operator.maxRetryCount), this.source);\n};\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function (source, destination) {\n    return source.subscribe(new CallSubscriber(destination, this.data, this.errors, this.operation, this.progressive));\n};\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.missing = null;\n    this.request = null;\n    this.started = false;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.errored = false;\n    this.relative = null;\n    this.hasValue = false;\n    this.fragments = null;\n    this.requested = null;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: __webpack_require__(70),\n    set: __webpack_require__(82),\n    call: __webpack_require__(69),\n    invalidate: __webpack_require__(80)\n};\n\nCallSubscriber.prototype.next = CallSubscriber.prototype.onNext = function (seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    } else if (!this.destination) {\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n    var seedIsImmutable = progressive && data;\n\n    if (model._recycleJSON && this.type === 'get') {\n        seedIsImmutable = false;\n    }\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type][operation](model, args, data, progressive || !model._source, this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            return tryOnError(this, results.error);\n        }\n\n        errors && results.errors && errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n};\n\nCallSubscriber.prototype.error = CallSubscriber.prototype.onError = function (error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n};\n\nCallSubscriber.prototype.complete = CallSubscriber.prototype.onCompleted = function (error) {\n\n    if (!this.destination) {\n        return;\n    }\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && ((data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return tryOnError(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return tryOnError(this, new MaxRetryExceededError(this.retryCount, this.requested, this.relative, this.missing));\n    }\n\n    this.request = this.model._root.requests[this.type](this.model, this.missing, this.relative, this.fragments).subscribe(this);\n};\n\nCallSubscriber.prototype.dispose = CallSubscriber.prototype.unsubscribe = function () {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 && version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot, modelRoot.expired, cache.$size || 0, modelRoot.maxSize, modelRoot.collectRatio, modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n};\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch (e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction tryOnError(self, error) {\n    try {\n        throw error;\n    } catch (err) {\n        Subscriber.prototype.onError.call(self, err);\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue,\n        nodeValue,\n        key,\n        keys = Object.keys(node),\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === \"\u001ef_meta\") {\n            dest[\"\u001ef_meta\"] = node[\"\u001ef_meta\"];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (!nodeValue || typeof nodeValue !== 'object') {\n                    if (destValue === undefined) {\n                        dest[key] = nodeValue;\n                    }\n                } else if (destValue === undefined) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(55);\nvar Request = __webpack_require__(96);\nvar Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\nvar ImmediateScheduler = __webpack_require__(56);\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = env.jsonGraph;\n        request.requested.push(requested);\n        request.optimized.push(optimized);\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, callArgs) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = callArgs;\n        request.boundPath = model._path;\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(this, model._source, model._scheduler, requested, optimized);\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function (destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] = new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n};\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar Subject = __webpack_require__(97);\nvar Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\nvar InvalidSourceError = __webpack_require__(53);\n\nvar setJSONGraphs = __webpack_require__(18);\nvar setPathValues = __webpack_require__(30);\nvar invalidatePaths = __webpack_require__(28);\n\nvar toPaths = __webpack_require__(39);\nvar toCollapseMap = __webpack_require__(37);\nvar toCollapseTrees = __webpack_require__(38);\nvar hasIntersection = __webpack_require__(63);\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.trees = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.paths = null;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next = Request.prototype.onNext = function (env) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    this.responded = true;\n    /*\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n    */\n\n    var changed = false;\n    var jsonGraph = env.jsonGraph;\n    var boundPath = this.boundPath;\n    var modelRoot = queue.modelRoot;\n    var invalidated = env.invalidated;\n    var paths = env.paths || this.paths;\n    var requested = this.requested.slice(0);\n    var observers = this.observers.slice(0);\n    var rootChangeHandler = modelRoot.onChange;\n\n    // Run invalidations first.\n    if (invalidated && invalidated.length) {\n        changed = invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n    }\n\n    if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n        var results = setJSONGraphs({ _root: modelRoot }, [{ paths: paths, jsonGraph: jsonGraph }], modelRoot.errorSelector, modelRoot.comparator, false);\n        paths = results[0];\n        changed = changed || results[2];\n    }\n\n    if (changed && rootChangeHandler) {\n        rootChangeHandler.call(modelRoot.topLevelModel);\n    }\n\n    observers.forEach(function (observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] || filterPathsBoundTo(boundPath, paths)\n        });\n    });\n};\n\nRequest.prototype.error = Request.prototype.onError = function (error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    error = error || {};\n\n    // Converts errors to object we can insert into the cache.\n    error = !(error instanceof Error) ?\n    // if it's $type error, use it raw\n    error.$type === \"error\" && error ||\n    // Otherwise make it an error\n    { $type: \"error\", value: error } :\n    // If it's instanceof Error, pluck error.message\n    { $type: \"error\", value: { message: error.message } };\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(this.requested.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {}))).map(function (path) {\n        return { path: path, value: error };\n    });\n\n    if (errorPathValues.length) {\n        setPathValues({ _root: modelRoot, _path: [] }, errorPathValues, modelRoot.errorSelector, modelRoot.comparator, false);\n    }\n\n    Subject.prototype.onError.call(this, error);\n};\n\nRequest.prototype.complete = Request.prototype.onCompleted = function () {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n};\n\nRequest.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.trees.splice(index, 1);\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n};\n\nRequest.prototype.dispose = Request.prototype.unsubscribe = function () {\n    this.trees = [];\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.boundPath = null;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n};\n\nRequest.prototype.connect = function () {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n};\n\nRequest.prototype.batch = function (requested, optimized, requestedComplements, optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.trees, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            this.trees.push(toCollapseTrees(toCollapseMap(optimizedIntersection)));\n            return this;\n        }\n        return null;\n    }\n    this.trees.push({});\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    return this;\n};\n\nfunction flush() {\n\n    var obs,\n        paths = this.paths = toPaths(toCollapseTrees(this.optimized.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {})));\n\n    this.trees = this.optimized.map(function (paths) {\n        return toCollapseTrees(toCollapseMap(paths));\n    });\n\n    this.active = true;\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = {};\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\nfunction findIntersections(trees, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = -1;\n    var reqComplementsIdx = -1;\n    var intersectionIndex = -1;\n    var reqIntersectionIdx = -1;\n    var treesLength = trees.length;\n    var optTotal = optimized.length;\n    var reqTotal = requested.length - 1;\n\n    toNextPath: while (++index < optTotal) {\n\n        var treesIndex = -1;\n        var path = optimized[index];\n        var pathLen = path.length;\n\n        while (++treesIndex < treesLength) {\n            var tree = trees[treesIndex];\n            var subTree = tree[pathLen];\n            if (subTree && hasIntersection(subTree, path, 0, pathLen)) {\n                optimizedIntersection[++intersectionIndex] = path;\n                if (reqIntersectionIdx < reqTotal) {\n                    requestedIntersection[++reqIntersectionIdx] = requested[index < reqTotal ? index : reqTotal];\n                }\n                continue toNextPath;\n            }\n        }\n\n        optimizedComplements[++complementIndex] = path;\n        if (reqComplementsIdx < reqTotal) {\n            requestedComplements[++reqComplementsIdx] = requested[index < reqTotal ? index : reqTotal];\n        }\n    }\n\n    return ~intersectionIndex;\n}\n\nfunction filterPathsBoundTo(boundPath, paths) {\n\n    var boundLength;\n\n    if (!boundPath || (boundLength = boundPath.length) === 0) {\n        return paths;\n    }\n\n    var filtered = [],\n        filteredIndex = -1,\n        keyIndex;\n    var path,\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    outer: while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        if (path.length > boundLength) {\n            keyIndex = 0;\n            do {\n                if (path[keyIndex] !== boundPath[keyIndex]) {\n                    continue outer;\n                }\n            } while (++keyIndex < boundLength);\n            filtered[++filteredIndex] = path.slice(boundLength);\n        }\n    }\n\n    return filtered;\n}\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscriber = __webpack_require__(14);\nvar Subscription = __webpack_require__(15);\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\n// Unused\n// Subject.prototype.onNext = function(value) {\n//     this.observers.slice(0).forEach(function(observer) {\n//         observer.onNext(value);\n//     });\n// }\n\nSubject.prototype.onError = function (error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onError(error);\n    });\n};\n\nSubject.prototype.onCompleted = function () {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onCompleted();\n    });\n};\n\nSubject.prototype.subscribe = function (subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n};\n\nSubject.prototype.dispose = Subject.prototype.unsubscribe = function () {\n    this.observers = [];\n};\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose = TimerDisposable.prototype.unsubscribe = function () {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isInternal = __webpack_require__(20);\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (isInternal(key)) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\nmodule.exports = getSize;\n\nfunction getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n}\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\n\nmodule.exports = getType;\n\nfunction getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return 'branch';\n    }\n    return type;\n}\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(6);\n\nmodule.exports = isPathValue;\n\nfunction isPathValue(pathValue) {\n    return isObject(pathValue) && (isArray(pathValue.path) || typeof pathValue.path === 'string');\n}\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(104);\n\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = __webpack_require__(105);\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35), __webpack_require__(106)(module)))\n\n/***/ },\n/* 105 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n/***/ },\n/* 106 */\n/***/ function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(61);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// falcor.all.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 107);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 465e9bc50fc9520273de","var now = require('../support/now');\nvar $now = require('../values/expires-now');\nvar $never = require('../values/expires-never');\n\nmodule.exports = isExpired;\n\nfunction isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/isExpired.js","var isInternal = require('../internal/isInternal');\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key, keys = Object.keys(node),\n        json = {}, index = -1, length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (key !== '$size' && !isInternal(key)) {\n            json[key] = node[key];\n        }\n    }\n\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/clone.js","var splice = require('./../lru/splice');\n\nmodule.exports = expireNode;\n\nfunction expireNode(node, expired, lru) {\n    if (!node[f_invalidated]) {\n        node[f_invalidated] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/expireNode.js","function FalcorJSON(f_meta) {\n    if (!f_meta) {\n        this[f_meta_data] = {};\n    } else if (!(this[f_meta_data] = f_meta[f_meta_data])) {\n        this[f_meta_data] = f_meta;\n    }\n}\n\nvar protoBlacklist = {\n    length: true,\n    toString: true,\n    constructor: true,\n    toLocaleString: true\n};\n\nvar protoDescriptors = {\n    toJSON: { enumerable: false, value: toJSON },\n    toProps: { enumerable: false, value: toProps },\n    toString: { enumerable: false, value: toString },\n    toLocaleString: { enumerable: false, value: toString },\n    $__hash: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta['$code'] || '';\n        }\n    },\n    $__path: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta[f_meta_abs_path] || [];\n        }\n    },\n    $__status: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta[f_meta_status] || 'resolved';\n        }\n    },\n    $__version: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta[f_meta_version] || 0;\n        }\n    }\n};\n\nObject.defineProperties(FalcorJSON.prototype, Object\n    .getOwnPropertyNames(Array.prototype)\n    .reduce(function (descriptors, name) {\n        if (!protoBlacklist.hasOwnProperty(name)) {\n            var fn = Array.prototype[name];\n            if (typeof fn === 'function') {\n                descriptors[name] = {\n                    value: bindArrayMethod(fn),\n                    writable: true, enumerable: false\n                };\n            }\n        }\n        return descriptors;\n    }, protoDescriptors)\n);\n\nfunction bindArrayMethod(fn) {\n    return function() {\n        var node = this, json = node, atom = node.length, length = atom, type;\n        // If length isn't a number, an $atom with a numeric `value`, or if the\n        // unboxed length isn't a valid Array length, bail early.\n        // If we're still waiting on pending updates, return an empty Array.\n        // Otherwise, throw a RangeError.\n        if ((type = typeof atom) !== 'number' && (!atom ||\n              type !== 'object' || atom.$type !== $atom ||\n              typeof (length = atom.value) !== 'number')||\n            length < 0 || length !== (length | 0)) {\n            if (node.$__status === 'pending') {\n                return [];\n            }\n            throw new RangeError('Invalid FalcorJSON length');\n        }\n        // Temporarily set length to the unboxed length, call the bound Array\n        // method, then reset the length back to the boxed value. This is\n        // necessary because a few Array methods (like sort) operate on the\n        // Array in-place, so we can't pass a sliced copy of this instance to\n        // the bound Array method. Do this even when the length isn't boxed, so\n        // if calling the bound Array method writes to length, it's reset to the\n        // value in the cache.\n        node.length = length;\n        json = fn.apply(node, arguments);\n        node.length = atom;\n        return json;\n    }\n}\n\nvar isArray = Array.isArray;\n\nfunction getInst(x) {\n    var inst = x;\n    var typeofInst = typeof inst;\n    var argsLen = arguments.length;\n    if (argsLen === 0) {\n        inst = this;\n    } else if (typeofInst !== 'string') {\n        if (!inst || typeofInst !== 'object') {\n            return inst;\n        }\n    } else if (argsLen !== 1) {\n        return inst;\n    } else {\n        inst = this;\n    }\n    return inst === global ? undefined : inst;\n}\n\nfunction toJSON() {\n    return serialize(getInst.apply(this, arguments), toJSON);\n}\n\nfunction toString(includeMetadata, includeStatus) {\n    return JSON.stringify(serialize(\n        getInst.call(this, this),\n        serialize,\n        includeMetadata === true,\n        false, includeStatus === true\n    ));\n}\n\nfunction toProps(x) {\n\n    var inst = getInst.apply(this, arguments);\n    var f_meta_inst, f_meta_json, version = 0;\n    var json = serialize(inst, toProps, true, true);\n\n    if (inst && (f_meta_inst = inst[f_meta_data])) {\n        version = f_meta_inst[f_meta_version];\n    }\n\n    if (!(!json || typeof json !== 'object')) {\n        if (f_meta_json = json[f_meta_data]) {\n            f_meta_json[f_meta_version] = version;\n        }\n    }\n\n    return json;\n}\n\nfunction serialize(inst, serializer, includeMetadata, createWithProto, includeStatus) {\n\n    if (!inst || typeof inst !== 'object') {\n        return inst;\n    }\n\n    var count, total, f_meta, keys, key, xs, ys;\n\n    if (isArray(inst)) {\n        xs = inst;\n    } else {\n\n        count = -1;\n        keys = Object.keys(inst);\n        total = keys.length;\n        xs = {};\n\n        if (createWithProto) {\n            xs.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (includeMetadata && (f_meta = inst[f_meta_data])) {\n\n            var $code = f_meta['$code'];\n            var status = f_meta[f_meta_status];\n            var abs_path = f_meta[f_meta_abs_path];\n            var deref_to = f_meta[f_meta_deref_to];\n            var deref_from = f_meta[f_meta_deref_from];\n\n            f_meta = {};\n            $code && (f_meta['$code'] = $code);\n            abs_path && (f_meta[f_meta_abs_path] = abs_path);\n            deref_to && (f_meta[f_meta_deref_to] = deref_to);\n            deref_from && (f_meta[f_meta_deref_from] = deref_from);\n            includeStatus && status && (f_meta[f_meta_status] = status);\n\n            xs[f_meta_data] = f_meta;\n\n            if (createWithProto) {\n                ys = {};\n                ys.__proto__ = xs;\n                xs = ys;\n            }\n        }\n\n        while (++count < total) {\n            if ((key = keys[count]) !== f_meta_data) {\n                xs[key] = serializer(inst[key], serializer, includeMetadata, createWithProto, includeStatus);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/FalcorJSON.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = '`null` is not allowed in branch key positions.';\n\n/**\n * Do not allow null in path.\n */\nmodule.exports = createErrorClass('NullInPathError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NullInPathError.js","module.exports = createErrorClass;\n\nfunction createErrorClass(name, init) {\n    function E(message) {\n        this.message = message;\n        init && init.apply(this, arguments);\n        if (!Error.captureStackTrace) {\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    E.prototype = Object.create(Error.prototype);\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    E.is = function(x) { return x.name === name; };\n    return E;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/createErrorClass.js","module.exports = isObject;\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isObject.js","module.exports = createHardlink;\n\nfunction createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[f_refs_length] || 0;\n    to[f_ref + backRefs] = from;\n    to[f_refs_length] = backRefs + 1;\n\n    // create a hard reference\n    from[f_ref_index] = backRefs;\n    from[f_context] = to;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/createHardlink.js","module.exports = { $type: 'atom' };\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/support/materializedAtom.js","var isObject = require('./../support/isObject');\nmodule.exports = getSize;\n\nfunction getSize(node) {\n    return isObject(node) && node.$size || 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getSize.js","/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type, depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === $ref) {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCachePosition.js","var removeNodeAndDescendants = require('./removeNodeAndDescendants');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = updateNodeAncestors;\n\nfunction updateNodeAncestors(node, offset, lru, version) {\n    var curr = node, next;\n    do {\n        if ((curr.$size = (curr.$size || 0) - offset) > 0) {\n            if (!(next = curr[f_parent])) {\n                curr[f_version] = version;\n            } else if (curr[f_version] !== version) {\n                updateBackReferenceVersions(curr, version);\n            }\n        } else if (next = curr[f_parent]) {\n            removeNodeAndDescendants(curr, next, curr[f_key], lru, version);\n        }\n    } while (curr = next);\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateNodeAncestors.js","var createErrorClass = require('./createErrorClass');\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidKeySetError', function(path, keysOrRanges) {\n    this.mesage = '' +\n        'The KeySet ' + JSON.stringify(keysOrRanges) +\n        ' in path ' + JSON.stringify(path) + ' contains a KeySet. ' +\n        'Keysets can only contain Keys or Ranges';\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidKeySetError.js","var EXPIRES_NEVER = require('./../values/expires-never');\n\nmodule.exports = lruPromote;\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nfunction lruPromote(lru, node) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (node.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = lru[f_head];\n\n    // Nothing is in the cache.\n    if (!head) {\n        lru[f_head] = lru[f_tail] = node;\n        return;\n    }\n\n    if (head === node) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = node[f_prev];\n    var next = node[f_next];\n    if (next) {\n        next[f_prev] = prev;\n    }\n    if (prev) {\n        prev[f_next] = next;\n    }\n    node[f_prev] = undefined;\n\n    // Insert into head position\n    lru[f_head] = node;\n    node[f_next] = head;\n    head[f_prev] = node;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (node === lru[f_tail]) {\n        lru[f_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/promote.js","var Subscription = require('./Subscription');\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' ||\n             typeof parent === 'function' ||\n        typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        }\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next =\nSubscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n}\n\nSubscriber.prototype.error =\nSubscriber.prototype.onError = function onError(error) {\n    var signaled = false;\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            signaled = true;\n            dest.onError(error);\n        } else if (dest.error) {\n            signaled = true;\n            dest.error(error);\n        }\n        this.dispose();\n    }\n    if (!signaled) {\n        throw error;\n    }\n}\n\nSubscriber.prototype.complete =\nSubscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n}\n\nSubscriber.prototype.dispose =\nSubscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscriber.js","module.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function(subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n}\n\nSubscription.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n}\n\nSubscription.prototype.dispose =\nSubscription.prototype.unsubscribe = function () {\n    var subscription, subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) &&\n            subscription.dispose &&\n            subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscription.js","var isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json,\n                     path, depth, seed, results,\n                     requestedPath, requestedLength,\n                     optimizedPath, optimizedLength,\n                     fromReference, modelRoot, expired, expireImmediate,\n                     branchSelector, boxValues, materialized, reportMissing,\n                     treatErrorsAsValues, onValue, onMissing, onMaterialize) {\n\n    var _reportMissing = reportMissing;\n    var reportMaterialized = reportMissing;\n\n    if (type) {\n        if (isExpired(node, expireImmediate)) {\n            if (!node[f_invalidated]) {\n                expireNode(node, expired, modelRoot);\n            }\n        } else {\n            lruPromote(modelRoot, node);\n            if (node.value === undefined) {\n                _reportMissing = false;\n                reportMaterialized = materialized;\n            } else {\n                if (seed) {\n                    if (fromReference) {\n                        requestedPath[depth] = null;\n                    }\n                    return onValue(node, type, depth, seed, results,\n                                   requestedPath, optimizedPath, optimizedLength,\n                                   fromReference, boxValues, materialized, treatErrorsAsValues);\n                }\n                return undefined;\n            }\n        }\n    }\n\n    if (materialized) {\n        seed && (results.hasValue = true);\n    } else if (!reportMaterialized) {\n        return undefined;\n    }\n\n    return onMissing(path, depth, results,\n                     requestedPath, requestedLength, fromReference,\n                     optimizedPath, optimizedLength, _reportMissing,\n                     materialized, json, branchSelector,\n                     boxValues, onMaterialize, modelRoot);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onValueType.js","var getCachePosition = require('./getCachePosition');\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[f_parent] === undefined || node[f_invalidated]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getBoundCacheNode.js","var arr = new Array(5);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar mergeJSONGraphNode = require('../mergeJSONGraphNode');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = setJSONGraphs;\n\nfunction setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, expireImmediate\n            );\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n}\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        var nextOptimizedPath = arr[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, arr[3], arr[2],\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, nodeArg, messageRoot, message, requestedPath, optimizedPathArg,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var node = nodeArg;\n    var reference = node.value;\n    var optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            setNode(\n                root, parent, node, messageRoot, messageParent, message,\n                key, branch, true, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n            node = arr[0];\n            optimizedPath = arr[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return;\n            }\n            parent = arr[1];\n            message = arr[2];\n            messageParent = arr[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n}\n\nfunction setNode(\n    root, parentArg, nodeArg, messageRoot, messageParentArg, messageArg,\n    key, branch, reference, requestedPath, optimizedPathArg, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var type = node.$type;\n    var parent = parentArg;\n    var message = messageArg;\n    var optimizedPath = optimizedPathArg;\n    var messageParent = messageParentArg;\n\n    while (type === $ref) {\n\n        setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = arr[0];\n\n        if (!node || typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        message = arr[2];\n        messageParent = arr[3];\n        optimizedPath = arr[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(\n            parent, node, message, key, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setJSONGraphs.js","var arr = new Array(3);\nvar isArray = Array.isArray;\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar getCachePosition = require('../getCachePosition');\nvar isInternalKey = require('../../support/isInternalKey');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar mergeValueOrInsertBranch = require('../mergeValueOrInsertBranch');\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = setPathMaps;\n\nfunction setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[f_parent] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, modelRoot, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n}\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = arr[0];\n            var nextParent = arr[1];\n            var nextOptimizedPath = arr[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                        version, expired, lru, comparator, errorSelector, expireImmediate\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, nodeArg, requestedPath, optimizedPathArg, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var node = nodeArg;\n    var reference = node.value;\n    var optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[f_context];\n\n        if (node != null) {\n            parent = node[f_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = arr[0];\n                optimizedPath = arr[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return;\n                }\n                parent = arr[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[f_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\nfunction setNode(\n    root, parentArg, nodeArg, key, value,\n    branch, reference, requestedPath, optimizedPathArg, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var type = node.$type;\n    var parent = parentArg;\n    var optimizedPath = optimizedPathArg;\n\n    while (type === $ref) {\n\n        setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = arr[0];\n\n        if (!node || typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        optimizedPath = arr[2];\n        type = node && node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = 'length';\n        }\n        for (var key in pathMap) {\n            if (isInternalKey(key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathMaps.js","/**\n * Determined if the key passed in is an f_ internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nvar f_ = require('./f_');\nvar regexp = new RegExp('^' + f_, 'i', 'g');\n\nmodule.exports = regexp.test.bind(regexp);\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/isInternal.js","module.exports = flatBufferToPaths;\n\nfunction flatBufferToPaths(seed, paths, path) {\n\n    path = path || [];\n    paths = paths || [];\n\n    if (!seed) {\n        return paths;\n    }\n\n    var leaf = [];\n    var keys = seed['$keys'];\n    var keysLen = keys.length;\n    var keysIndex = -1, key, len;\n\n    while (++keysIndex < keysLen) {\n\n        var next = seed[keysIndex];\n        var keyset = keys[keysIndex];\n\n        if (!next || typeof next !== 'object') {\n            leaf.push(keyset);\n        } else {\n            flatBufferToPaths(next, paths, path.concat([keyset]));\n        }\n    }\n\n    if (leaf.length === 1) {\n        paths.push(path.concat(leaf));\n    } else if (leaf.length > 1) {\n        paths.push(path.concat([leaf]));\n    }\n\n    return paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/flatBufferToPaths.js","module.exports = getHashCode;\n\nfunction getHashCode(str) {\n    var hash = 5381, i = str.length;\n    while (i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/getHashCode.js","var isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/iterateKeySet.js","module.exports = require('./getJSON');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/index.js","module.exports = require('./getJSONGraph');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/index.js","module.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key, depth = 0, prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/inlineValue.js","var isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, json, branchSelector,\n                   boxValues, onMaterialize, modelRoot) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        return onMaterialize(json, mPath, missDepth, missTotal, branchSelector, boxValues, modelRoot);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if ('object' !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if ('number' !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMissing.js","var arr = new Array(2);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\nvar getSize = require('../../support/getSize');\nvar createHardlink = require('../createHardlink');\nvar getBoundCacheNode = require('../getBoundCacheNode');\nvar updateNodeAncestors = require('../updateNodeAncestors');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = invalidatePathSets;\n\nfunction invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n    var parent = node[f_parent] || cache;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        invalidateNode(\n            root, parent, node,\n            key, branch, false, version,\n            expired, lru, expireImmediate\n        );\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru, expireImmediate\n                );\n            } else {\n                updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, nodeArg, version, expired, lru, expireImmediate) {\n\n    var node = nodeArg;\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[f_context];\n\n    if (node != null) {\n        parent = node[f_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            invalidateNode(\n                root, parent, node,\n                key, branch, true, version,\n                expired, lru, expireImmediate\n            );\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\nfunction invalidateNode(\n    root, parentArg, nodeArg,\n    key, branch, reference, version,\n    expired, lru, expireImmediate) {\n\n    var node = nodeArg;\n    var parent = parentArg;\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathSets.js","var lruSplice = require('../lru/splice');\nvar isInternalKey = require('../support/isInternalKey');\nvar unlinkBackReferences = require('./unlinkBackReferences');\nvar unlinkForwardReference = require('./unlinkForwardReference');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = removeNodeAndDescendants;\n\nfunction removeNodeAndDescendants(node, parent, key, lru, version) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type === undefined) {\n            for (var key2 in node) {\n                if (!isInternalKey(key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru, version);\n                }\n            }\n        } else {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(updateBackReferenceVersions(node, version));\n        parent[key] = node[f_parent] = undefined;\n        return true;\n    }\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/removeNodeAndDescendants.js","var arr = new Array(3);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar getCachePosition = require('../getCachePosition');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\nvar mergeValueOrInsertBranch = require('../mergeValueOrInsertBranch');\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = setPathValues;\n\nfunction setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[f_parent] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, modelRoot, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n}\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        var nextOptimizedPath = arr[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, nodeArg, requestedPath, optimizedPathArg, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var node = nodeArg;\n    var reference = node.value;\n    var optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[f_context];\n\n        if (node != null) {\n            parent = node[f_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = arr[0];\n                optimizedPath = arr[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return;\n                }\n                parent = arr[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[f_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\nfunction setNode(\n    root, parentArg, nodeArg, key, value,\n    branch, reference, requestedPath, optimizedPathArg, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var type = node.$type;\n    var parent = parentArg;\n    var optimizedPath = optimizedPathArg;\n\n    while (type === $ref) {\n\n        setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = arr[0];\n\n        if (!node || typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        optimizedPath = arr[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathValues.js","module.exports = updateBackReferenceVersions;\n\nfunction updateBackReferenceVersions(nodeArg, version) {\n    var node = nodeArg, stack = [], count = 0, ref, i, n;\n    do {\n        i = -1;\n        ref = node[f_parent];\n        node[f_version] = version;\n        n = node[f_refs_length] || 0;\n        do {\n            if (ref && ref[f_version] !== version) {\n                stack[count++] = ref;\n            }\n            if (++i < n) {\n                ref = node[f_ref + i];\n                continue;\n            }\n            break;\n        } while (true);\n    } while (node = stack[--count]);\n    return nodeArg;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateBackReferenceVersions.js","var isObject = require('./../support/isObject');\nmodule.exports = getTimestamp;\n\nfunction getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getTimestamp.js","/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nmodule.exports = isInternalKey;\n\nvar isInternal = require('../internal/isInternal');\n\nfunction isInternalKey(key) {\n    return key && key[0] === '$' || isInternal(key);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isInternalKey.js","module.exports = 0;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-now.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 35\n// module chunks = 0","var toPaths = require('./toPaths');\nvar toCollapseMap = require('./toCollapseMap');\nvar toCollapseTrees = require('./toCollapseTrees');\n\nmodule.exports = function collapse(paths) {\n    return toPaths(toCollapseTrees(toCollapseMap(paths)));\n};\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/collapse.js","var isArray = Array.isArray;\nvar flatBufferToPaths = require('./flatBufferToPaths');\n\nmodule.exports = toCollapseMap;\n\nfunction toCollapseMap(pathsArg, collapseMapArg) {\n    var paths = pathsArg, collapseMap = collapseMapArg;\n    if (!collapseMap || typeof collapseMap !== 'object') {\n        collapseMap = {};\n    }\n    if (!paths) {\n        return collapseMap;\n    } else if (!isArray(paths) && isArray(paths.$keys)) {\n        paths = flatBufferToPaths(paths);\n    }\n    return paths.reduce(partitionPathsByLength, collapseMap);\n}\n\nfunction partitionPathsByLength(collapseMap, path) {\n    var length = path.length;\n    var paths = collapseMap[length] || (\n                collapseMap[length] = []);\n    paths[paths.length] = path;\n    return collapseMap;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toCollapseMap.js","var toTree = require('./toTree');\n\nmodule.exports = toCollapseTrees;\n\nfunction toCollapseTrees(pathsByLength, treesByPathLengthArg) {\n\n    var pathLengths = Object.keys(pathsByLength);\n    var pathLength, pathLengthsIndex = -1;\n    var pathLengthsCount = pathLengths.length;\n    var treesByPathLength = treesByPathLengthArg;\n\n    if (!treesByPathLength || typeof treesByPathLength !== 'object') {\n        treesByPathLength = {};\n    }\n\n    while (++pathLengthsIndex < pathLengthsCount) {\n        pathLength = pathLengths[pathLengthsIndex];\n        treesByPathLength[pathLength] = toTree(\n            pathsByLength[pathLength], treesByPathLength[pathLength]\n        );\n    }\n\n    return treesByPathLength;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toCollapseTrees.js","var isArray = Array.isArray;\nvar typeOfObject = 'object';\nvar typeOfString = 'string';\nvar typeOfNumber = 'number';\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\nvar getHashCode = require('./getHashCode');\nvar materializedAtom = require('./support/materializedAtom');\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var subs = Object.create(null);\n    var code = '' + getHashCode('' + depth);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = '' + getHashCode(code + key + subCode);\n\n            isSafeNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = '' + getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {'from':1, 'to':6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to '==='.\n        if (to - from <= keyCount) {\n            return { from: from, to: to };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === materializedAtom) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toPaths.js","var isArray = Array.isArray;\nvar walkPathAndBuildOutput = require('./walkPath');\nvar walkFlatBufferAndBuildOutput = require('./walkFlatBuffer');\nvar getBoundCacheNode = require('../../getBoundCacheNode');\nvar InvalidModelError = require('../../../errors/InvalidModelError');\nvar toFlatBuffer = require('@graphistry/falcor-path-utils/lib/toFlatBuffer');\nvar computeFlatBufferHash = require('@graphistry/falcor-path-utils/lib/computeFlatBufferHash');\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, pathsArg, seed, progressive, expireImmediate) {\n\n    var node,\n        paths = pathsArg,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        materialized = seed && model._materialized,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame,\n        results = { args: null, data: seed, hasValue: false,\n                    relative: null, requested: null, missing: null };\n\n    var arr, path, pathsIndex = 0, pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n\n        if (recycleJSON) {\n            isFlatBuffer = true;\n            if ((pathsCount > 1 && expireImmediate) || isArray(paths[0])) {\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n            pathsCount = 1;\n        }\n\n        do {\n            path = paths[pathsIndex];\n            if (isFlatBuffer) {\n                arr = walkFlatBufferAndBuildOutput(cache, node, json, paths[0], 0, seed, results,\n                                                   requestedPath, optimizedPath, optimizedLength,\n                                                   /* fromReference = */ false, referenceContainer,\n                                                   modelRoot, expired, expireImmediate, branchSelector,\n                                                   boxValues, materialized, hasDataSource,\n                                                   treatErrorsAsValues, allowFromWhenceYouCame);\n            } else {\n                requestedLength = path.length;\n                arr = walkPathAndBuildOutput(cache, node, json, path,\n                                          /* depth = */ 0, seed, results,\n                                             requestedPath, requestedLength,\n                                             optimizedPath, optimizedLength,\n                                             /* fromReference = */ false, referenceContainer,\n                                             modelRoot, expired, expireImmediate, branchSelector,\n                                             boxValues, materialized, hasDataSource,\n                                             treatErrorsAsValues, allowFromWhenceYouCame);\n            }\n            json = arr[0];\n            arr[0] = undefined;\n            arr[1] = undefined;\n        } while (++pathsIndex < pathsCount);\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getJSON.js","var arr = new Array(3);\nvar promote = require('../../../lru/promote');\nvar isExpired = require('../../isExpired');\nvar createHardlink = require('../../createHardlink');\nvar CircularReferenceError = require('../../../errors/CircularReferenceError');\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, refArg, modelRoot, expireImmediate) {\n\n    promote(modelRoot, refArg);\n\n    var context,\n        ref = refArg,\n        key, type, depth = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[f_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getReferenceTarget.js","var clone = require('../../clone');\nvar onError = require('./onError');\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results,\n                     requestedPath, optimizedPath, optimizedLength,\n                     fromReference, boxValues, materialized,\n                     treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath,\n                       fromReference, boxValues);\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    return !boxValues ? node.value : clone(node);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onValue.js","var walkPathAndBuildOutput = require('./walkPath');\nvar BoundJSONGraphModelError = require('../../../errors/BoundJSONGraphModelError');\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node, cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        pathsIndex = -1, pathsCount = paths.length,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        results = { args: null, data: seed, paths: null,\n                    relative: null, requested: null, jsonGraph: null };\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n                            /* depth = */ 0, seed, results,\n                               requestedPath, requestedLength,\n                               optimizedPath, optimizedLength,\n              /* fromReference = */ false, modelRoot, expired, expireImmediate,\n                               boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args = results.relative = results.requested;\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getJSONGraph.js","var isArray = Array.isArray;\nvar clone = require('../clone');\nvar FalcorJSON = require('./json/FalcorJSON');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMaterialize;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterialize(jsonArg, path, depth, length,\n                       branchSelector, boxValues, modelRoot) {\n\n    var json = jsonArg, type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (depth === length) {\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta;\n\n    var nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0;\n\n    keyset = path[depth];\n\n    if (!json || 'object' !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[f_meta_data])) {\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n    } else {\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            // insert the materialized branch\n            json[nextKey] = onMaterialize(\n                json[nextKey], path,\n                nextDepth, length,\n                branchSelector,\n                boxValues,\n                modelRoot\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMaterialize.js","var isArray = Array.isArray;\nvar isPathValue = require('../support/isPathValue');\nvar isJSONEnvelope = require('../support/isJSONEnvelope');\nvar isJSONGraphEnvelope = require('../support/isJSONGraphEnvelope');\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = 'PathValues';\n        } else if (isPathValue(arg)) {\n            argType = 'PathValues';\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = 'JSONGraphs';\n        } else if (isJSONEnvelope(arg)) {\n            argType = 'PathMaps';\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/groupCacheArguments.js","module.exports = insertNode;\n\nfunction insertNode(node, parent, key, version, optimizedPath) {\n    node[f_key] = key;\n    node[f_parent] = parent;\n\n    if (version !== undefined) {\n        node[f_version] = version;\n    }\n    if (!node[f_abs_path]) {\n        node[f_abs_path] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/insertNode.js","var arr = new Array(2);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\nvar getSize = require('../../support/getSize');\nvar createHardlink = require('../createHardlink');\nvar getBoundCacheNode = require('../getBoundCacheNode');\nvar isInternalKey = require('../../support/isInternalKey');\nvar updateNodeAncestors = require('../updateNodeAncestors');\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = invalidatePathMaps;\n\nfunction invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathMapIndex = -1;\n    var parent = node[f_parent] || cache;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathMap(\n    pathMap, depth, root, parent, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (!isInternalKey(key)) {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            invalidateNode(\n                root, parent, node,\n                key, child, branch, false, version, expired,\n                lru, comparator, expireImmediate\n            );\n            var nextNode = arr[0];\n            var nextParent = arr[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, expireImmediate\n                    );\n                } else {\n                    updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(\n    value, root, nodeArg, version,\n    expired, lru, comparator, expireImmediate) {\n\n    var node = nodeArg;\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[f_context];\n\n    if (node != null) {\n        parent = node[f_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            invalidateNode(\n                root, parent, node,\n                key, value, branch, true, version,\n                expired, lru, comparator, expireImmediate\n            );\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\nfunction invalidateNode(\n    root, parentArg, nodeArg,\n    key, value, branch, reference, version,\n    expired, lru, comparator, expireImmediate) {\n\n    var node = nodeArg;\n    var parent = parentArg;\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        invalidateReference(\n            value, root, node, version, expired,\n            lru, comparator, expireImmediate\n        );\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathMaps.js","var $now = require('../values/expires-now');\nvar getType = require('../support/getType');\nvar getSize = require('../support/getSize');\nvar getTimestamp = require('../support/getTimestamp');\n\nvar wrapNode = require('./wrapNode');\nvar isExpired = require('./isExpired');\nvar expireNode = require('./expireNode');\nvar insertNode = require('./insertNode');\nvar replaceNode = require('./replaceNode');\nvar reconstructPath = require('./reconstructPath');\nvar updateNodeAncestors = require('./updateNodeAncestors');\nvar removeNodeAndDescendants = require('./removeNodeAndDescendants');\n\nmodule.exports = mergeValueOrInsertBranch;\n\nfunction mergeValueOrInsertBranch(\n    parentArg, nodeArg, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var node = nodeArg;\n    var parent = parentArg;\n    var cType = getType(node, reference);\n\n    if (branch || reference) {\n        if (cType && isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge if it expires immediately\n             */\n            true)) {\n            expireNode(node, expired, lru);\n            cType = node.$expires === $now ? cType : 'expired';\n        }\n        if ((cType && cType !== $ref) || (!node || typeof node !== 'object')) {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var isDistinct = true;\n        var mType = getType(message);\n\n        // If both the cache and message are primitives,\n        // insert the message into the cache.\n        if (!cType && !mType) {\n            isDistinct = true;\n        }\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        else if (comparator) {\n            isDistinct = !(comparator.length < 3 ?\n                comparator(node, message) : comparator(node, message,\n                    optimizedPath.slice(0, optimizedPath.index))\n            );\n        } else {\n            // Comparing either Number or undefined to undefined always results in false.\n            isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n        }\n\n        if (isDistinct) {\n\n            if (errorSelector && mType === $error) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            var sizeOffset = getSize(node) - getSize(message =\n                wrapNode(message, mType, mType ? message.value : message));\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeValueOrInsertBranch.js","/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = reconstructPath;\n\nfunction reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/reconstructPath.js","var transferBackReferences = require('./transferBackReferences');\nvar removeNodeAndDescendants = require('./removeNodeAndDescendants');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = replaceNode;\n\nfunction replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/replaceNode.js","var isArray = Array.isArray;\nvar now = require('../support/now');\nvar clone = require('./../support/clone');\nvar getSize = require('./../support/getSize');\nvar getExpires = require('../support/getExpires');\nvar expiresNow = require('../values/expires-now');\n\nvar atomSize = 50;\n\nmodule.exports = wrapNode;\n\nfunction wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[f_wrapped_value];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[f_prev] = undefined;\n        node[f_next] = undefined;\n        node[f_wrapped_value] = modelCreated || false;\n    } else {\n        node = { $type: $atom, value: value };\n        node[f_prev] = undefined;\n        node[f_next] = undefined;\n        node[f_wrapped_value] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case 'object':\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case 'string':\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === 'number' && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/wrapNode.js","var createErrorClass = require('./createErrorClass');\n\nmodule.exports = createErrorClass('CircularReferenceError', function(referencePath) {\n    this.message = 'Encountered circular reference ' + JSON.stringify(referencePath);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/CircularReferenceError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'An exception was thrown when making a request';\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidSourceError', function(error) {\n    this.message = MESSAGE + ':\\n\\t' + error;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidSourceError.js","module.exports = lruSplice;\n\nfunction lruSplice(lru, node) {\n\n    // Its in the cache.  Splice out.\n    var prev = node[f_prev];\n    var next = node[f_next];\n    if (next) {\n        next[f_prev] = prev;\n    }\n    if (prev) {\n        prev[f_next] = next;\n    }\n    node[f_prev] = node[f_next] = undefined;\n\n    if (node === lru[f_head]) {\n        lru[f_head] = next;\n    }\n    if (node === lru[f_tail]) {\n        lru[f_tail] = prev;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/splice.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar $$observable = require('symbol-observable').default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function() {\n    return this;\n}\n\nSource.prototype.operator = function(destination) {\n    return this.subscribe(destination);\n}\n\n// Unused\n// Source.prototype.lift = function(operator, source) {\n//     source = new Source(source || this);\n//     source.operator = operator;\n//     source._promise = this._promise;\n//     return source;\n// }\n\nSource.prototype.subscribe = function(destination, x, y) {\n    return new Subscription([\n        this.operator.call(\n            this.source, !(destination instanceof Subscriber) ?\n                new Subscriber(destination, x, y) : destination)\n    ]);\n}\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function(resolve, reject) {\n            var values = [], rejected = false;\n            source.subscribe({\n                next: function(value) { values[values.length] = value; },\n                error: function(errors) { (rejected = true) && reject(errors); },\n                complete: function() {\n                    !rejected &&\n                    resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Source.js","var empty = {\n    dispose: function() {},\n    unsubscribe: function() {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/ImmediateScheduler.js","var isObject = require('./../support/isObject');\n\nmodule.exports = isJSONEnvelope;\n\nfunction isJSONEnvelope(envelope) {\n    return isObject(envelope) && ('json' in envelope);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONEnvelope.js","var isArray = Array.isArray;\nvar isObject = require('./../support/isObject');\n\nmodule.exports = isJSONGraphEnvelope;\n\nfunction isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONGraphEnvelope.js","module.exports = Date.now;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/now.js","module.exports = 1;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-never.js","var Model = require('./Model');\nvar FalcorJSON = require('./cache/get/json/FalcorJSON');\n\nfunction falcor(opts) {\n    if (!(this instanceof Model)) {\n        return new Model(opts);\n    }\n    Model.call(this, opts);\n}\n\nfalcor.prototype = Object.create(Model.prototype);\n\nfalcor['Model'] = Model;\nfalcor['FalcorJSON'] = FalcorJSON;\nfalcor['toProps'] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","var isArray = Array.isArray;\nvar getHashCode = require('./getHashCode');\n\nmodule.exports = computeFlatBufferHash;\n\nfunction computeFlatBufferHash(seed) {\n\n    if (seed === undefined) {\n        return undefined;\n    }\n\n    var code = '';\n    var keys = seed['$keys'];\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    while (++keysIndex < keysLength) {\n\n        var key = keys[keysIndex];\n\n        if (key === null) {\n            code = '' + getHashCode('' + code + 'null');\n            continue;\n        } else if (typeof key === 'object') {\n            key = '[' + key.from + '..' + (key.from + key.length - 1) + ']';\n        }\n\n        var next = computeFlatBufferHash(seed[keysIndex]);\n        if (next === undefined) {\n            code = '' + getHashCode('' + code + key);\n        } else {\n            code = '' + getHashCode('' + code + key + next['$code']);\n        }\n    }\n\n    seed['$code'] = code;\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/computeFlatBufferHash.js","var isArray = Array.isArray;\nvar materializedAtom = require('./support/materializedAtom');\n\nmodule.exports = hasIntersection\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/hasIntersection.js","var isArray = Array.isArray;\nvar nullBuffer = { '$keys': [null], '$keysMap': { 'null': 0 } };\nvar flatBufferToPaths = require('./flatBufferToPaths');\n\nmodule.exports = toFlatBuffer;\n\nfunction toFlatBuffer(paths, seed) {\n    return paths.reduce(function(seed, path) {\n        if (isArray(path)) {\n            return pathToFlatBuffer(seed, path, 0, path.length);\n        } else if (isArray(path.$keys)) {\n            return toFlatBuffer(flatBufferToPaths(path), seed);\n        }\n        return seed;\n    }, seed || {});\n}\n\nfunction pathToFlatBuffer(seed, path, depth, length) {\n\n    if (depth === length) {\n        return undefined;\n    }\n\n    seed = seed || {};\n    var keys = seed['$keys'] || (seed['$keys'] = []);\n    var keysMap = seed['$keysMap'] || (seed['$keysMap'] = {});\n    var keysIndex = -1;\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullBuffer;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = nextKey;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyset = { from: nextKey, length: rangeEnd - nextKey + 1 };\n            nextKey = '[' + nextKey + '..' + rangeEnd + ']';\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = keyset;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toFlatBuffer.js","var isArray = Array.isArray;\nvar materializedAtom = require('./support/materializedAtom');\n\nmodule.exports = toTree;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\n\nfunction toTree(paths, seed) {\n    return paths.reduce(function(seed, path) {\n        return pathToTree(seed, path, 0, path.length, null);\n    }, seed || {});\n};\n\nfunction pathToTree(seed, path, depth, length, value) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    seed = seed || {};\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = value;\n            } else {\n                node = seed[nextKey];\n                next = pathToTree(node, path, nextDepth, length, value);\n                if (!next) {\n                    seed[nextKey] = value;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toTree.js","var Call = require('./request/Call');\nvar ModelRoot = require('./ModelRoot');\nvar FalcorJSON = require('./cache/get/json/FalcorJSON');\nvar ModelDataSourceAdapter = require('./ModelDataSourceAdapter');\nvar TimeoutScheduler = require('./schedulers/TimeoutScheduler');\nvar ImmediateScheduler = require('./schedulers/ImmediateScheduler');\nvar collapse = require('@graphistry/falcor-path-utils/lib/collapse');\n\nvar getSize = require('./support/getSize');\nvar isObject = require('./support/isObject');\nvar isJSONEnvelope = require('./support/isJSONEnvelope');\nvar getCachePosition = require('./cache/getCachePosition');\nvar isJSONGraphEnvelope = require('./support/isJSONGraphEnvelope');\n\nvar setCache = require('./cache/set/setPathMaps');\nvar setJSONGraphs = require('./cache/set/setJSONGraphs');\n\nvar getJSON = require('./cache/get/json');\nvar getCache = require('./cache/getCache');\nvar getJSONGraph = require('./cache/get/jsonGraph');\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._treatErrorsAsValues = true;\n        this._seed = {};\n        this._seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get(...args) {\n    var seed = this._seed;\n    if (!seed) {\n        seed = {};\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n    return new Call('get', this, args)._toJSON(seed, []);\n}\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set(...args) {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n    return new Call('set', this, args)._toJSON(seed, []);\n}\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload(...args) {\n    return new Call('get', this, args)._toJSON(null, []);\n}\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call(...args) {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n    return new Call('call', this, args)._toJSON(seed, []);\n}\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate(...args) {\n    return new Call('invalidate', this, args)._toJSON(null, null).then();\n}\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.deref = require('./deref');\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a request\n * from the parent should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update where the model is bound.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = require('./deref/hasValidParentReference');\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return new Call('get', this, [path])\n        ._toJSON({}, [])\n        .lift(function(subscriber) {\n            return this.subscribe({\n                onNext: function(data) {\n                    var depth = -1;\n                    var x = data.json;\n                    var length = path.length;\n                    while (x && !x.$type && ++depth < length) {\n                        x = x[path[depth]];\n                    }\n                    subscriber.onNext(x);\n                },\n                onError: subscriber.onError.bind(subscriber),\n                onCompleted: subscriber.onCompleted.bind(subscriber)\n            })\n        });\n}\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : {path:path,value:value};\n    return new Call('set', this, [value])\n        ._toJSON({}, [])\n        .lift(function(subscriber) {\n            return this.subscribe({\n                onNext: function(data) {\n                    var depth = -1;\n                    var x = data.json;\n                    var length = path.length;\n                    while (x && !x.$type && ++depth < length) {\n                        x = x[path[depth]];\n                    }\n                    subscriber.onNext(x);\n                },\n                onError: subscriber.onError.bind(subscriber),\n                onCompleted: subscriber.onCompleted.bind(subscriber)\n            })\n        });\n}\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n\n    var modelRoot = this._root;\n    var cache = modelRoot.cache;\n\n    if (cacheOrJSONGraphEnvelope !== cache) {\n\n        var options = {\n            _path: [],\n            _boxed: false,\n            _root: modelRoot,\n            _materialized: false,\n            _treatErrorsAsValues: false\n        };\n\n        modelRoot.cache = this._node = {};\n\n        if (typeof cache !== 'undefined') {\n            modelRoot.expired = [];\n            modelRoot[f_head] = undefined;\n            modelRoot[f_tail] = undefined;\n            if (this._recycleJSON) {\n                this._seed = {};\n                this._seed.__proto__ = FalcorJSON.prototype;\n            }\n        }\n\n        var results, rootOnChangeHandler;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setJSONGraphs(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [{ json: cacheOrJSONGraphEnvelope }]);\n        }\n\n        if (results) {\n            // performs promotion without producing output.\n            if (results[0].length) {\n                getJSON(options, results[0], null, false, false);\n            }\n            if (results[2] && (rootOnChangeHandler = modelRoot.onChange)) {\n                rootOnChangeHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    } else if (typeof cache === 'undefined') {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache('genreLists[0...10][0...10].boxshot')));\n */\nModel.prototype.getCache = function _getCache(...paths) {\n\n    if (paths.length === 0) {\n        return getCache(this, this._root.cache);\n    }\n\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    var env = getJSONGraph({\n        _path: [],\n        _root: this._root,\n        _boxed: this._boxed,\n        _materialized: this._materialized,\n        _treatErrorsAsValues: this._treatErrorsAsValues\n    }, paths, seed).data;\n\n    env.paths = collapse(paths);\n\n    return env;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path) {\n    path = path || [];\n    if (Array.isArray(path) === false) {\n        throw new Error('Model#getVersion must be called with an Array path.');\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === 'delete') {\n                delete clone[key];\n            } else if (key === '_path') {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty('_node')) {\n                    delete clone['_node'];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === 'number') {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: 'Steve',\n                surname: 'McGuire'\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints 'Steve'\nproxyModel.getValue('user.name').\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: 'delete'\n    });\n};\n\n/* implement inspect method for node's inspect utility */\nModel.prototype.inspect = function inspect() {\n    return '{ v: ' + this.getVersion() + ' p: [' + this._path.join(', ') + '] }';\n}\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: 'ref',\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[f_abs_path] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = require('./cache/getVersion');\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = require('./cache/set/setPathValues');\nModel.prototype._setPathMaps = require('./cache/set/setPathMaps');\nModel.prototype._setJSONGs = require('./cache/set/setJSONGraphs');\nModel.prototype._setCache = require('./cache/set/setPathMaps');\n\nModel.prototype._invalidatePathValues = require('./cache/invalidate/invalidatePathSets');\nModel.prototype._invalidatePathMaps = require('./cache/invalidate/invalidatePathMaps');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/Model.js","function ModelDataSourceAdapter(model) {\n    this._model = model\n        // .boxValues()\n        ._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [\n        path, args, suffixes\n    ].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelDataSourceAdapter.js","var functionTypeof = 'function';\nvar Requests = require('./request/Queue');\nvar getTimestamp = require('./support/getTimestamp');\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = -1;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nfunction defaultCompare(node, message) {\n    var cType = node && node.$type;\n    var mType = message && message.$type;\n    if (cType) {\n        // If the cache has a type, but the message is a primitive,\n        // the message might be the primitive response from the datasource.\n        // If so, return true, so we don't update the back-reference versions.\n        if (!mType) {\n            return node.value === message;\n        }\n        // If the message is older than the cache node, then isDistinct = false\n        else if (getTimestamp(message) < getTimestamp(node) === true) {\n            return true; // isDistinct = false\n        }\n        // Otherwise they are the same if all the following fields are the same.\n        return !(\n            cType !== mType ||\n            node.value !== message.value ||\n            node.$expires !== message.$expires\n        );\n    }\n    // If cache doesn't have a type but the message\n    // does, they must be different.\n    else if (mType) {\n        return false;\n    }\n    return node === message;\n}\n\nModelRoot.comparator = ModelRoot.prototype.comparator = defaultCompare;\n\nmodule.exports = ModelRoot;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelRoot.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue =  getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/call/index.js","module.exports = {\n    json: require('./json/getJSON'),\n    jsonGraph: require('./jsonGraph/getJSONGraph')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/index.js","var clone = require('../../clone');\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results,\n                 requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onError.js","var arr = new Array(2);\nvar onValue = require('./onValue');\nvar FalcorJSON = require('./FalcorJSON');\nvar isExpired = require('../../isExpired');\nvar onValueType = require('../onValueType');\nvar originalOnMissing = require('../onMissing');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar onMaterialize = require('../onMaterializeFlatBuffer');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar getHashCode = require('@graphistry/falcor-path-utils/lib/getHashCode');\nvar flatBufferToPaths = require('@graphistry/falcor-path-utils/lib/flatBufferToPaths');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, jsonArg, path,\n                                depth, seed, results, requestedPath,\n                                optimizedPath, optimizedLength,\n                                fromReferenceArg, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var json = jsonArg, type, refTarget;\n    var fromReference = fromReferenceArg;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node ||\n        undefined !== (type = node.$type) ||\n        undefined === path) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json,\n                             path, depth, seed, results,\n                             requestedPath, depth,\n                             optimizedPath, optimizedLength,\n                             fromReference, modelRoot, expired, expireImmediate,\n                             branchSelector, boxValues, materialized, hasDataSource,\n                             treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta, f_old_keys, f_new_keys, f_code = '';\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        keys = path['$keys'],\n        nodeAbsPath, jsonAbsPath,\n        nextDepth = depth + 1, rangeEnd,\n        nextJSON, nextReferenceContainer,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[f_abs_path];\n    }\n\n    if (!json || 'object' !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[f_meta_data]) {\n\n        nodeAbsPath = node[f_abs_path];\n        jsonAbsPath = f_meta[f_meta_abs_path];\n\n        if (!branchSelector && !(json instanceof FalcorJSON)) {\n            json.__proto__ = {};\n            json.__proto__[f_meta_data] = f_meta;\n            json.__proto__.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (!arrayEqual(nodeAbsPath, jsonAbsPath)) {\n            f_meta['$code'] = '';\n            f_meta[f_meta_status] = 'pending';\n            f_meta[f_meta_abs_path] = nodeAbsPath;\n            f_meta[f_meta_version] = node[f_version];\n            refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n            refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n            if (f_old_keys = f_meta[f_meta_keys]) {\n                f_meta[f_meta_keys] = Object.create(null);\n                for (nextKey in f_old_keys) {\n                    if (f_old_keys[nextKey]) {\n                        delete json[nextKey];\n                    }\n                }\n            }\n            arr[0] = json;\n            arr[1] = true;\n            return arr;\n        } else if (!(\n            f_meta[f_meta_version]  !== node[f_version]  ||\n            f_meta['$code']         !== path['$code'])) {\n            results.hasValue = true;\n            arr[0] = json;\n            arr[1] = false;\n            return arr;\n        }\n\n        f_old_keys = f_meta[f_meta_keys];\n        f_meta[f_meta_abs_path] = nodeAbsPath;\n        f_meta[f_meta_version] = node[f_version];\n        refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n    }\n\n    f_new_keys = Object.create(null);\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath, nextPathKey,\n        hasMissingPath = false;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = '' + getHashCode('' + f_code + 'null');\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n            nextPathKey = nextKey;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n            nextPathKey = '[' + nextKey + '..' + rangeEnd + ']';\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextPath === undefined) {\n\n                walkPathAndBuildOutput(\n                    root, next, nextJSON, nextPath, nextDepth, seed,\n                    results, requestedPath, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n            else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                    // If the reference is expired, it will be invalidated and\n                    // reported as missing in the next call to walkPath below.\n                    next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                walkPathAndBuildOutput(\n                    root, next, nextJSON, nextPath, nextDepth, seed,\n                    results, requestedPath, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[f_meta_version] = node[f_version];\n                f_meta[f_meta_abs_path] = node[f_abs_path];\n                refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n                json = {};\n                json[f_meta_data] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                } else {\n                    var tmp = json;\n                    json = {};\n                    json.__proto__ = tmp;\n                    tmp = undefined;\n                }\n            }\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && (nextKey in f_old_keys)) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        f_code = '' + getHashCode('' + f_code +\n                                 ( !hasMissingPath ? nextPathKey : '') +\n                                 (  nextPath ? nextPath['$code'] : ''));\n    }\n\n    if (f_meta) {\n        f_meta['$code'] = f_code;\n        f_meta[f_meta_keys] = f_new_keys;\n        f_meta[f_meta_status] = hasMissingPath && 'pending' || 'resolved';\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, json, branchSelector,\n                   boxValues, onMaterialize, modelRoot) {\n\n    if (reportMaterialized) {\n        return onMaterialize(json, path, depth, depth, branchSelector,\n                             boxValues, modelRoot, results, requestedPath, optimizedPath,\n                             optimizedLength, fromReference, reportMissing, onMissing);\n    }\n\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n\n    return paths.forEach(function(restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results,\n                                 requestedPath, requestedLength, fromReference,\n                                 optimizedPath, optimizedLength, reportMissing,\n                                 false, json, branchSelector,\n                                 boxValues, onMaterialize, modelRoot);\n    });\n}\n\nfunction arrayEqual(xs, ys) {\n    if (xs === ys) {\n        return true;\n    }\n    var len = xs.length;\n    if (len !== ys.length) {\n        return false;\n    }\n    while (~--len) {\n        if (xs[len] !== ys[len]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkFlatBuffer.js","var arr = new Array(2);\nvar isArray = Array.isArray;\nvar onValue = require('./onValue');\nvar onMissing = require('../onMissing');\nvar FalcorJSON = require('./FalcorJSON');\nvar onValueType = require('../onValueType');\nvar isExpired = require('../../isExpired');\nvar onMaterialize = require('../onMaterialize');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, jsonArg, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReferenceArg, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var json = jsonArg, type, refTarget;\n    var fromReference = fromReferenceArg;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json,\n                             path, depth, seed, results,\n                             requestedPath, requestedLength,\n                             optimizedPath, optimizedLength,\n                             fromReference, modelRoot, expired, expireImmediate,\n                             branchSelector, boxValues, materialized, hasDataSource,\n                             treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta;\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        nextJSON, nextReferenceContainer,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        arr[0] = json;\n        arr[1] = false;\n        return arr;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[f_abs_path];\n    }\n\n    if (!json || 'object' !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[f_meta_data]) {\n        f_meta[f_meta_version] = node[f_version];\n        f_meta[f_meta_abs_path] = node[f_abs_path];\n        refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    var hasMissingPath = false;\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextDepth === requestedLength) {\n\n                walkPathAndBuildOutput(\n                    root, next, nextJSON, path, nextDepth, seed,\n                    results, requestedPath, requestedLength, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    continue;\n                }\n            }\n            else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                    // If the reference is expired, it will be invalidated and\n                    // reported as missing in the next call to walkPath below.\n                    next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                walkPathAndBuildOutput(\n                    root, next, nextJSON, path, nextDepth, seed,\n                    results, requestedPath, requestedLength, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[f_meta_version] = node[f_version];\n                f_meta[f_meta_abs_path] = node[f_abs_path];\n                refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n                json = {};\n                json[f_meta_data] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                }\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    if (f_meta) {\n        f_meta[f_meta_status] = hasMissingPath && 'pending' || 'resolved';\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkPath.js","var arr = new Array(2);\nvar clone = require('../../clone');\nvar inlineValue = require('./inlineValue');\nvar promote = require('../../../lru/promote');\nvar isExpired = require('../../isExpired');\nvar createHardlink = require('../../createHardlink');\nvar CircularReferenceError = require('../../../errors/CircularReferenceError');\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, refArg, modelRoot, seed, expireImmediate) {\n\n    promote(modelRoot, refArg);\n\n    var context,\n        ref = refArg,\n        key, type, depth = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[f_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getReferenceTarget.js","var clone = require('../../clone');\nvar inlineValue = require('./inlineValue');\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results,\n                          requestedPath, optimizedPath, optimizedLength,\n                          fromReference, boxValues, materialized) {\n\n    var value = node.value;\n\n    // boxValues always clones the node\n    if (boxValues || !(\n        /**\n         * JSON Graph should always clone:\n         * - refs\n         * - errors\n         * - atoms we didn't create\n         * - atoms we created to wrap Objects\n         **/\n        $ref !== type &&\n        $error !== type &&\n        node[f_wrapped_value] &&\n        'object' !== typeof value)) {\n        value = clone(node);\n    }\n\n    results.hasValue = true;\n    inlineValue(value, optimizedPath, optimizedLength, seed);\n    (seed.paths || (seed.paths = [])).push(\n        requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n    );\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/onValue.js","var isArray = Array.isArray;\nvar clone = require('../../clone');\nvar onValue = require('./onValue');\nvar inlineValue = require('./inlineValue');\nvar isExpired = require('../../isExpired');\nvar onValueType = require('../onValueType');\nvar onMaterialize = require('../onMaterialize');\nvar originalOnMissing = require('../onMissing');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReferenceArg, modelRoot, expired, expireImmediate,\n                                boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n    var fromReference = fromReferenceArg;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type, seed,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired, expireImmediate,\n                           undefined, boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            keyset = keysOrRanges[keysetIndex];\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(root, next, modelRoot, seed, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(\n                root, next, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate,\n                boxValues, materialized, hasDataSource, treatErrorsAsValues\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, seed, branchSelector,\n                   boxValues, onMaterialize, modelRoot) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push(\n            (isLeaf = 0 === requestedLength - depth) &&\n                                 // depth + 1 if fromReference === true\n                requestedPath.slice(0, depth + !!fromReference) ||\n                requestedPath.slice(0, depth).concat(path\n                    .slice(depth, requestedLength + !!fromReference))\n        );\n\n        json = inlineValue(isLeaf && clone(materializedAtom) || undefined,\n                           optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results,\n                             requestedPath, requestedLength, fromReference,\n                             optimizedPath, optimizedLength, reportMissing,\n                             !isLeaf && reportMaterialized, json,\n                             branchSelector, true, onMaterialize, modelRoot);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/walkPath.js","var clone = require('../clone');\nvar onValueType = require('./onValueType');\nvar FalcorJSON = require('./json/FalcorJSON');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMaterializeFlatBuffer;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterializeFlatBuffer(jsonArg, path, depth, length,\n                                 branchSelector, boxValues, modelRoot, results,\n                                 requestedPath, optimizedPath, optimizedLength,\n                                 fromReference, reportMissing, onMissing) {\n\n    var json = jsonArg, type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === path) {\n        onValueType(undefined, undefined, json,\n                    path, depth, undefined, results,\n                    requestedPath, depth, optimizedPath,\n                    optimizedLength, fromReference, modelRoot, undefined,\n                    false, branchSelector, boxValues, false, reportMissing,\n                    false, undefined, onMissing, undefined);\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta, f_old_keys, f_new_keys;\n\n    var nextKey,\n        keyset, keyIsRange,\n        keys = path['$keys'],\n        nextDepth = depth + 1, rangeEnd,\n        nextOptimizedLength = optimizedLength + 1;\n\n    if (!json || 'object' !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[f_meta_data] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[f_meta_data])) {\n        json[f_meta_data] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n    } else {\n        f_old_keys = f_meta[f_meta_keys];\n        f_meta['$code'] = '';\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n    }\n\n    f_new_keys = Object.create(null);\n\n    var nextPath;\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && (nextKey in f_old_keys)) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // insert the materialized branch\n            json[nextKey] = onMaterializeFlatBuffer(\n                json[nextKey], nextPath, nextDepth,\n                nextDepth, branchSelector, boxValues, modelRoot, results,\n                requestedPath, optimizedPath, nextOptimizedLength,\n                fromReference, reportMissing, onMissing\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n    }\n\n    f_meta[f_meta_keys] = f_new_keys;\n    if (f_old_keys) {\n        for (nextKey in f_old_keys) {\n            if (f_old_keys[nextKey]) {\n                delete json[nextKey];\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMaterializeFlatBuffer.js","var clone = require('./clone');\nvar isInternal = require('../internal/isInternal');\n\nmodule.exports = getCache;\n\nfunction getCache(model, cache) {\n    return getCacheInternal(cache, {}, model._boxed, model._materialized);\n}\n\nfunction getCacheInternal(node, jsonArg, boxValues, materialized) {\n\n    var json = jsonArg, type, value;\n\n    if (!node || typeof node !== 'object') {\n        return node;\n    } else if (type = node.$type) {\n\n        if (undefined === (value = node.value)) {\n            if (materialized) {\n                value = { $type: $atom };\n            } else if (node[f_wrapped_value]) {\n                value = clone(node);\n            }\n        }\n        // boxValues always clones the node\n        else if (boxValues || !(\n            /**\n             * getCache should always clone:\n             * - refs\n             * - errors\n             * - atoms we didn't create\n             * - atoms we created to wrap Objects\n             **/\n            $ref !== type &&\n            $error !== type &&\n            node[f_wrapped_value] &&\n            typeof value !== 'object')) {\n            value = clone(node);\n        }\n        return value;\n    }\n\n    var keys = Object.keys(node);\n    var keysLen = keys.length, keyIndex = -1;\n\n    while (++keyIndex < keysLen) {\n        var key = keys[keyIndex];\n        if (key !== '$size' && !isInternal(key) && undefined !== (value =\n            getCacheInternal(node[key], json && json[key], boxValues, materialized))) {\n            if (json === undefined) {\n                json = {};\n            }\n            json[key] = value;\n        }\n    }\n\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCache.js","var getBoundCacheNode = require('./getBoundCacheNode');\n\nmodule.exports = getVersion;\n\nfunction getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[f_version];\n    return (version == null) ? -1 : version;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getVersion.js","var groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n    invalidatePathMaps: require('./invalidatePathMaps'),\n    invalidatePathValues: require('./invalidatePathSets')\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    if (invalidateArgumentGroups(model, groupCacheArguments(args), expireImmediate)) {\n        var rootChangeHandler = model._root.onChange;\n        rootChangeHandler && rootChangeHandler.call(model._root.topLevelModel);\n    }\n    return {};\n}\n\nfunction invalidateArgumentGroups(model, xs, expireImmediate) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            if (inputType === 'PathValues') {\n                groupedArgs = groupedArgs.map(pluckPaths);\n            }\n            var operation = module.exports['invalidate' + inputType];\n            if (operation(model, groupedArgs, expireImmediate)) {\n                changed = true;\n            }\n        }\n    }\n    return changed;\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/index.js","var wrapNode = require('./wrapNode');\nvar isExpired = require('./isExpired');\nvar insertNode = require('./insertNode');\nvar expireNode = require('./expireNode');\nvar replaceNode = require('./replaceNode');\nvar getSize = require('../support/getSize');\nvar reconstructPath = require('./reconstructPath');\nvar getTimestamp = require('../support/getTimestamp');\nvar updateNodeAncestors = require('./updateNodeAncestors');\n\nmodule.exports = mergeJSONGraphNode;\n\nfunction mergeJSONGraphNode(\n    parentArg, nodeArg, messageArg, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n    var node = nodeArg;\n    var parent = parentArg;\n    var message = messageArg;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // The message and cache are both undefined, return undefined.\n        if (message === undefined) {\n            return message;\n        }\n        // There should not be undefined values. Those should always be\n        // wrapped in an $atom\n        else if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n        // Is the cache node a branch? If so, return the cache branch.\n        else if ((\n            cIsObject = !(!node || typeof node !== 'object')) && (\n            cType = node.$type) === undefined) {\n            // Has the branch been introduced to the cache yet? If not,\n            // give it a parent, key, and absolute path.\n            if (node[f_parent] === undefined) {\n                insertNode(node, parent, key, version, optimizedPath);\n            }\n            return node;\n        }\n    } else if (cIsObject = !(!node || typeof node !== 'object')) {\n        cType = node.$type;\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty,\n        // leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node, expireImmediate)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node[f_parent] != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node, expireImmediate) &&\n                        !isExpired(message, expireImmediate) &&\n                        mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch,\n    // merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(\n                node, message, parent, key, lru, version),\n            parent, key, undefined, optimizedPath\n        );\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n\n        if (mType === $error && errorSelector) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n        }\n\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n        if (mType && node === message) {\n            if (!node[f_parent]) {\n                node = wrapNode(node, cType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If both the cache and message are primitives, we branch-merged\n            // one of the message's ancestors. Insert the value into the cache.\n            if (!cType && !mType) {\n                isDistinct = true;\n            }\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            else if (!cIsObject || !isExpired(node, expireImmediate)) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                if (comparator) {\n                    isDistinct = !(comparator.length < 3 ?\n                        comparator(node, message) : comparator(node, message,\n                            optimizedPath.slice(0, optimizedPath.index))\n                    );\n                } else {\n                    // Comparing either Number or undefined to undefined always results in false.\n                    isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                }\n            }\n            if (isDistinct) {\n                sizeOffset = getSize(node) - getSize(message =\n                    wrapNode(message, mType, mType ? message.value : message));\n                node = replaceNode(node, message, parent, key, lru, version);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n            expireNode(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode(message, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeJSONGraphNode.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\nvar groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: require('./setPathMaps'),\n    setPathValues: require('./setPathValues'),\n    setJSONGraphs: require('./setJSONGraphs')\n};\n\nfunction json(model, _args, data, progressive, expireImmediate) {\n\n    var set, get, jsong,\n        changed, relative, optimized,\n        missing, fragments, requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length) {\n\n        if (!(changed = set.changed) || progressive) {\n            get = getJSON(model, relative, data, progressive, expireImmediate);\n        }\n\n        if (changed) {\n\n            jsong = getJSONGraph({\n                _root: model._root,\n                _boxed: model._boxed, _materialized: true,\n                _treatErrorsAsValues: model._treatErrorsAsValues\n            }, set.optimized, {}, progressive, expireImmediate);\n\n            fragments = jsong.data;\n            missing = fragments.paths;\n            requested = jsong.requested;\n\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler.call(model._root.topLevelModel);\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: get && get.error,\n        errors: get && get.errors,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive, expireImmediate) {\n\n    var set, jsong,\n        changed, relative, optimized,\n        missing, fragments, requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length && (\n         progressive || (changed = set.changed))) {\n\n        jsong = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed, _materialized: true,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, set.optimized, data, progressive, expireImmediate);\n\n        fragments = jsong.data;\n        missing = fragments.paths;\n        requested = jsong.requested;\n\n        if (changed) {\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler.call(model._root.topLevelModel);\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: jsong && jsong.error,\n        hasValue: jsong && jsong.hasValue\n    };\n}\n\nfunction setGroupsIntoCache(model, xs, expireImmediate_) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n\n    var expireImmediate = expireImmediate_ && !Boolean(model._source);\n    var comparator = Boolean(model._source) ? null : modelRoot.comparator;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports['set' + inputType];\n            var results = operation(model, groupedArgs, errorSelector, comparator, expireImmediate);\n            changed = changed || results[2];\n            optimizedPaths.push.apply(optimizedPaths, results[1]);\n            if (inputType === 'PathValues') {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === 'JSONGraphs') {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, results[0]);\n            }\n        }\n    }\n\n    return {\n        changed: changed,\n        requested: requestedPaths,\n        optimized: optimizedPaths\n    };\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\nfunction arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/index.js","module.exports = transferBackReferences;\n\nfunction transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[f_refs_length] || 0,\n        destNodeRefsLength = destNode[f_refs_length] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[f_ref + i];\n        if (ref !== undefined) {\n            ref[f_context] = destNode;\n            destNode[f_ref + (destNodeRefsLength + i)] = ref;\n            fromNode[f_ref + i] = undefined;\n        }\n    }\n    destNode[f_refs_length] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[f_refs_length] = undefined;\n    return destNode;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/transferBackReferences.js","module.exports = unlinkBackReferences;\n\nfunction unlinkBackReferences(node) {\n    var i = -1, n = node[f_refs_length] || 0;\n    while (++i < n) {\n        var ref = node[f_ref + i];\n        if (ref != null) {\n            ref[f_context] = ref[f_ref_index] = node[f_ref + i] = void 0;\n        }\n    }\n    node[f_refs_length] = void 0;\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkBackReferences.js","module.exports = unlinkForwardReference;\n\nfunction unlinkForwardReference(reference) {\n    var destination = reference[f_context];\n    if (destination) {\n        var i = (reference[f_ref_index] || 0) - 1,\n            n = (destination[f_refs_length] || 0) - 1;\n        while (++i <= n) {\n            destination[f_ref + i] = destination[f_ref + (i + 1)];\n        }\n        destination[f_refs_length] = n;\n        reference[f_ref_index] = reference[f_context] = destination = void 0;\n    }\n    return reference;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkForwardReference.js","module.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[f_parent] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[f_invalidated]) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/hasValidParentReference.js","var CONTAINER_DOES_NOT_EXIST = 'e';\nvar FalcorJSON = require('../cache/get/json/FalcorJSON');\nvar getCachePosition = require('../cache/getCachePosition');\nvar InvalidDerefInputError = require('../errors/InvalidDerefInputError');\n\nmodule.exports = deref;\n\nfunction deref(json) {\n\n    var seed, f_meta;\n\n    if (!json || 'object' !== typeof json || !(\n        f_meta = json[f_meta_data]) || 'object' !== typeof f_meta) {\n        return null;\n    }\n\n    var cacheRoot = this._root.cache;\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = f_meta[f_meta_abs_path];\n    var referenceContainer, currentRefPath, i, len;\n\n    if (!absolutePath) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: undefined,\n            _seed: seed\n        });\n    } else if (absolutePath.length === 0) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: cacheRoot,\n            _path: absolutePath,\n            _referenceContainer: true,\n            _seed: seed\n        });\n    }\n\n    var originalRefPath = f_meta[f_meta_deref_to];\n    var originalAbsPath = f_meta[f_meta_deref_from];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n            validContainer = true;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n            for (i = 0; i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    cacheNode = undefined;\n                    validContainer = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n        referenceContainer = true;\n    }\n\n    if (recycleJSON) {\n        seed = { json: json };\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    return this._clone({\n        _seed: seed,\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/index.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'It is not legal to use the JSON Graph ' +\n    'format from a bound Model. JSON Graph format' +\n    ' can only be used from a root model.';\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nmodule.exports = createErrorClass('BoundJSONGraphModelError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/BoundJSONGraphModelError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'Deref can only be used with a non-primitive object from get, set, or call.';\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidDerefInputError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidDerefInputError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'The boundPath of the model is not valid since a value or error was found before the path end.';\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidModelError', function(boundPath, shortedPath) {\n    this.message = MESSAGE;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidModelError.js","var createErrorClass = require('./createErrorClass');\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nmodule.exports = createErrorClass('MaxRetryExceededError', function(maxRetryCount, absolute, relative, optimized) {\n    this.message = '' +\n        'Exceeded the max retry count (' + maxRetryCount + ') for these paths: \\n' +\n        (absolute &&\n        'absolute: [\\n\\t' + printPaths(absolute) + '\\n]\\n' || '') +\n        (relative &&\n        'relative: [\\n\\t' + printPaths(relative) + '\\n]\\n' || '') +\n        (optimized &&\n        'optimized: [\\n\\t' + printPaths(optimized) + '\\n]\\n' || '');\n});\n\nfunction printPaths(paths) {\n    return paths.map(function(path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/MaxRetryExceededError.js","module.exports = String.fromCharCode(30) + 'f_';\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/f_.js","var updateNodeAncestors = require('../cache/updateNodeAncestors');\n\nmodule.exports = collect;\n\nfunction collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== 'number') {\n        ratio = 0.75;\n    }\n\n    var node, size, targetSize = max * ratio;\n\n    while (node = expired.pop()) {\n        total -= (size = node.$size || 0);\n        updateNodeAncestors(node, size, lru, version);\n    }\n\n    if (total >= max) {\n        var prev = lru[f_tail];\n        while ((total >= targetSize) && (node = prev)) {\n            prev = prev[f_prev];\n            total -= (size = node.$size || 0);\n            updateNodeAncestors(node, size, lru, version);\n        }\n\n        lru[f_tail] = node;\n        if (node == null) {\n            lru[f_head] = undefined;\n        } else {\n            node[f_next] = undefined;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/collect.js","var Source = require('./Source');\nvar Subscriber = require('./Subscriber');\nvar lruCollect = require('../lru/collect');\nvar FalcorJSON = require('../cache/get/json/FalcorJSON');\nvar collapse = require('@graphistry/falcor-path-utils/lib/collapse');\nvar InvalidSourceError = require('../errors/InvalidSourceError');\nvar MaxRetryExceededError = require('../errors/MaxRetryExceededError');\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function(operator, source) {\n    source = new Call(source || this);\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    source.operator = operator;\n    operator.data = operator.data || this.operator.data;\n    operator.errors = operator.errors || this.operator.errors;\n    operator.operation = operator.operation || this.operator.operation;\n    operator.progressive = operator.progressive || this.operator.progressive;\n    operator.maxRetryCount = operator.maxRetryCount || this.operator.maxRetryCount;\n    return source;\n}\n\nCall.prototype.operator = function(subscriber) {\n    return this._subscribe(subscriber);\n}\n\nCall.prototype._subscribe = function(subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n}\n\nCall.prototype._toJSON = function(dataArg, errors) {\n    var data = dataArg;\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(\n        data, errors || this.operator.errors, 'json',\n        this.operator.progressive, this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype._toJSONG = function(dataArg, errors) {\n    var data = dataArg;\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(\n        data, errors || this.operator.errors, 'jsonGraph',\n        this.operator.progressive, this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.retry = function(maxRetryCount) {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        this.operator.progresive,\n        maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.progressively = function() {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        true,\n        this.operator.maxRetryCount\n    ), this.source);\n}\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function(source, destination) {\n    return source.subscribe(new CallSubscriber(\n        destination, this.data, this.errors, this.operation, this.progressive\n    ));\n}\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.missing = null;\n    this.request = null;\n    this.started = false;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.errored = false;\n    this.relative = null;\n    this.hasValue = false;\n    this.fragments = null;\n    this.requested = null;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: require('../cache/get'),\n    set: require('../cache/set'),\n    call: require('../cache/call'),\n    invalidate: require('../cache/invalidate')\n};\n\nCallSubscriber.prototype.next =\nCallSubscriber.prototype.onNext = function(seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    } else if (!this.destination) {\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n    var seedIsImmutable = progressive && data;\n\n    if (model._recycleJSON && this.type === 'get') {\n        seedIsImmutable = false;\n    }\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type]\n            [operation](model, args, data,\n                        progressive || !model._source,\n                        this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            return tryOnError(this, results.error);\n        }\n\n        errors && results.errors &&\n            errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n}\n\nCallSubscriber.prototype.error =\nCallSubscriber.prototype.onError = function(error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n}\n\nCallSubscriber.prototype.complete =\nCallSubscriber.prototype.onCompleted = function(error) {\n\n    if (!this.destination) {\n        return;\n    }\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && (\n            (data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return tryOnError(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return tryOnError(this, new MaxRetryExceededError(\n            this.retryCount,\n            this.requested,\n            this.relative,\n            this.missing\n        ));\n    }\n\n    this.request = this.model._root.requests[this.type](\n        this.model, this.missing, this.relative, this.fragments\n    ).subscribe(this);\n}\n\nCallSubscriber.prototype.dispose =\nCallSubscriber.prototype.unsubscribe = function() {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 &&\n                                 version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot,\n                           modelRoot.expired,\n                           cache.$size || 0,\n                           modelRoot.maxSize,\n                           modelRoot.collectRatio,\n                           modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n}\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch(e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction tryOnError(self, error) {\n    try {\n        throw error;\n    } catch (err) {\n        Subscriber.prototype.onError.call(self, err);\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue, nodeValue,\n        key, keys = Object.keys(node),\n        index = -1, length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === f_meta_data) {\n            dest[f_meta_data] = node[f_meta_data];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (!nodeValue || typeof nodeValue !== 'object') {\n                    if (destValue === undefined) {\n                        dest[key] = nodeValue;\n                    }\n                } else if (destValue === undefined) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Call.js","var Source = require('./Source');\nvar Request = require('./Request');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar ImmediateScheduler = require('../schedulers/ImmediateScheduler');\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = env.jsonGraph;\n        request.requested.push(requested);\n        request.optimized.push(optimized);\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, callArgs) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = callArgs;\n        request.boundPath = model._path;\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(\n        this, model._source, model._scheduler, requested, optimized\n    );\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function(destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests  = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] =\n            new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Queue.js","var isArray = Array.isArray;\nvar Subject = require('./Subject');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar InvalidSourceError = require('../errors/InvalidSourceError');\n\nvar setJSONGraphs = require('../cache/set/setJSONGraphs');\nvar setPathValues = require('../cache/set/setPathValues');\nvar invalidatePaths = require('../cache/invalidate/invalidatePathSets');\n\nvar toPaths = require('@graphistry/falcor-path-utils/lib/toPaths');\nvar toCollapseMap = require('@graphistry/falcor-path-utils/lib/toCollapseMap');\nvar toCollapseTrees = require('@graphistry/falcor-path-utils/lib/toCollapseTrees');\nvar hasIntersection = require('@graphistry/falcor-path-utils/lib/hasIntersection');\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.trees = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.paths = null;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next =\nRequest.prototype.onNext = function(env) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    this.responded = true;\n    /*\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n    */\n\n    var changed = false;\n    var jsonGraph = env.jsonGraph;\n    var boundPath = this.boundPath;\n    var modelRoot = queue.modelRoot;\n    var invalidated = env.invalidated;\n    var paths = env.paths || this.paths;\n    var requested = this.requested.slice(0);\n    var observers = this.observers.slice(0);\n    var rootChangeHandler = modelRoot.onChange;\n\n    // Run invalidations first.\n    if (invalidated && invalidated.length) {\n        changed = invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n    }\n\n    if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n        var results = setJSONGraphs(\n            { _root: modelRoot },\n            [{ paths: paths, jsonGraph: jsonGraph }],\n            modelRoot.errorSelector, modelRoot.comparator, false\n        );\n        paths = results[0];\n        changed = changed || results[2];\n    }\n\n    if (changed && rootChangeHandler) {\n        rootChangeHandler.call(modelRoot.topLevelModel);\n    }\n\n    observers.forEach(function(observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] ||\n                filterPathsBoundTo(boundPath, paths)\n        });\n    });\n}\n\nRequest.prototype.error =\nRequest.prototype.onError = function(error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    error = error || {};\n\n    // Converts errors to object we can insert into the cache.\n    error = !(error instanceof Error) ?\n        // if it's $type error, use it raw\n        error.$type === $error && error ||\n        // Otherwise make it an error\n        { $type: $error, value: error } :\n        // If it's instanceof Error, pluck error.message\n        { $type: $error, value: { message: error.message }};\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(\n        this.requested.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ))\n    .map(function(path) { return { path: path, value: error }; });\n\n    if (errorPathValues.length) {\n        setPathValues(\n            { _root: modelRoot, _path: [] },\n            errorPathValues,\n            modelRoot.errorSelector,\n            modelRoot.comparator,\n            false\n        );\n    }\n\n    Subject.prototype.onError.call(this, error);\n}\n\nRequest.prototype.complete =\nRequest.prototype.onCompleted = function() {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n}\n\nRequest.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.trees.splice(index, 1);\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n}\n\nRequest.prototype.dispose =\nRequest.prototype.unsubscribe = function () {\n    this.trees = [];\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.boundPath = null;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n}\n\nRequest.prototype.connect = function() {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n}\n\nRequest.prototype.batch = function(requested, optimized,\n                                   requestedComplements,\n                                   optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.trees,\n                              requested, optimized,\n                              requestedComplements,\n                              optimizedComplements,\n                              requestedIntersection,\n                              optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            this.trees.push(toCollapseTrees(toCollapseMap(\n                optimizedIntersection\n            )));\n            return this;\n        }\n        return null;\n    }\n    this.trees.push({});\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    return this;\n}\n\nfunction flush() {\n\n    var obs, paths = this.paths = toPaths(toCollapseTrees(\n        this.optimized.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ));\n\n    this.trees = this.optimized.map(function(paths) {\n        return toCollapseTrees(toCollapseMap(paths));\n    });\n\n    this.active = true;\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = {};\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\nfunction findIntersections(trees,\n                           requested, optimized,\n                           requestedComplements,\n                           optimizedComplements,\n                           requestedIntersection,\n                           optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = -1;\n    var reqComplementsIdx = -1;\n    var intersectionIndex = -1;\n    var reqIntersectionIdx = -1;\n    var treesLength = trees.length;\n    var optTotal = optimized.length;\n    var reqTotal = requested.length - 1;\n\n    toNextPath:\n    while (++index < optTotal) {\n\n        var treesIndex = -1;\n        var path = optimized[index];\n        var pathLen = path.length;\n\n        while (++treesIndex < treesLength) {\n            var tree = trees[treesIndex];\n            var subTree = tree[pathLen];\n            if (subTree && hasIntersection(subTree, path, 0, pathLen)) {\n                optimizedIntersection[++intersectionIndex] = path;\n                if (reqIntersectionIdx < reqTotal) {\n                    requestedIntersection[++reqIntersectionIdx] = requested[\n                        index < reqTotal ? index : reqTotal\n                    ];\n                }\n                continue toNextPath;\n            }\n        }\n\n        optimizedComplements[++complementIndex] = path;\n        if (reqComplementsIdx < reqTotal) {\n            requestedComplements[++reqComplementsIdx] = requested[\n                index < reqTotal ? index : reqTotal\n            ];\n        }\n    }\n\n    return ~intersectionIndex;\n}\n\nfunction filterPathsBoundTo(boundPath, paths) {\n\n    var boundLength;\n\n    if (!boundPath || (boundLength = boundPath.length) === 0) {\n        return paths;\n    }\n\n    var filtered = [], filteredIndex = -1, keyIndex;\n    var path, pathsIndex = -1, pathsCount = paths.length;\n\n    outer: while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        if (path.length > boundLength) {\n            keyIndex = 0;\n            do {\n                if (path[keyIndex] !== boundPath[keyIndex]) {\n                    continue outer;\n                }\n            } while (++keyIndex < boundLength);\n            filtered[++filteredIndex] = path.slice(boundLength);\n        }\n    }\n\n    return filtered;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Request.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\n// Unused\n// Subject.prototype.onNext = function(value) {\n//     this.observers.slice(0).forEach(function(observer) {\n//         observer.onNext(value);\n//     });\n// }\n\nSubject.prototype.onError = function(error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onError(error);\n    });\n}\n\nSubject.prototype.onCompleted = function() {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onCompleted();\n    });\n}\n\nSubject.prototype.subscribe = function(subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n}\n\nSubject.prototype.dispose =\nSubject.prototype.unsubscribe = function () {\n    this.observers = [];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subject.js","function TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose =\nTimerDisposable.prototype.unsubscribe = function() {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/TimeoutScheduler.js","var isArray = Array.isArray;\nvar isInternal = require('../internal/isInternal');\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (isInternal(key)) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/clone.js","var isObject = require('./isObject');\nmodule.exports = getSize;\n\nfunction getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getExpires.js","var isObject = require('./../support/isObject');\n\nmodule.exports = getType;\n\nfunction getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return 'branch';\n    }\n    return type;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getType.js","var isArray = Array.isArray;\nvar isObject = require('./../support/isObject');\n\nmodule.exports = isPathValue;\n\nfunction isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === 'string'\n        ));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isPathValue.js","module.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/index.js\n// module id = 103\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/index.js\n// module id = 104\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/ponyfill.js\n// module id = 105\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 106\n// module chunks = 0"],"sourceRoot":""}