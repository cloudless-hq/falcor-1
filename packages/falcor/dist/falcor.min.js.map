{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///falcor.min.js","webpack:///webpack/bootstrap 230706e40c862c749bcd","webpack:///./lib/types/ref.js","webpack:///./lib/cache/isExpired.js","webpack:///./lib/support/isObject.js","webpack:///./lib/cache/expireNode.js","webpack:///.-path-utils/lib/support/materializedAtom.js","webpack:///./lib/cache/createHardlink.js","webpack:///./lib/errors/NullInPathError.js","webpack:///./lib/support/getSize.js","webpack:///./lib/cache/clone.js","webpack:///./lib/cache/getCachePosition.js","webpack:///./lib/cache/updateNodeAncestors.js","webpack:///./lib/lru/promote.js","webpack:///./lib/request/Subscriber.js","webpack:///./lib/request/Subscription.js","webpack:///./lib/types/error.js","webpack:///./lib/cache/getBoundCacheNode.js","webpack:///./lib/cache/set/setJSONGraphs.js","webpack:///./lib/cache/set/setPathMaps.js","webpack:///.-path-utils/lib/flatBufferToPaths.js","webpack:///.-path-utils/lib/getHashCode.js","webpack:///.-path-utils/lib/iterateKeySet.js","webpack:///./lib/cache/get/json/FalcorJSON.js","webpack:///./lib/cache/get/json/index.js","webpack:///./lib/cache/get/jsonGraph/index.js","webpack:///./lib/cache/get/jsonGraph/inlineValue.js","webpack:///./lib/cache/get/onMissing.js","webpack:///./lib/cache/get/onValueType.js","webpack:///./lib/cache/invalidate/invalidatePathSets.js","webpack:///./lib/cache/removeNode.js","webpack:///./lib/cache/removeNodeAndDescendants.js","webpack:///./lib/cache/set/setPathValues.js","webpack:///./lib/errors/InvalidKeySetError.js","webpack:///./lib/values/expires-now.js","webpack:///(webpack)/buildin/global.js","webpack:///.-path-utils/lib/toCollapseMap.js","webpack:///.-path-utils/lib/toCollapseTrees.js","webpack:///.-path-utils/lib/toPaths.js","webpack:///.-path-utils/lib/toTree.js","webpack:///./lib/cache/get/json/getJSON.js","webpack:///./lib/cache/get/json/getReferenceTarget.js","webpack:///./lib/cache/get/json/onValue.js","webpack:///./lib/cache/get/jsonGraph/getJSONGraph.js","webpack:///./lib/cache/insertNode.js","webpack:///./lib/cache/invalidate/invalidatePathMaps.js","webpack:///./lib/cache/mergeValueOrInsertBranch.js","webpack:///./lib/cache/reconstructPath.js","webpack:///./lib/cache/replaceNode.js","webpack:///./lib/cache/updateBackReferenceVersions.js","webpack:///./lib/cache/wrapNode.js","webpack:///./lib/errors/CircularReferenceError.js","webpack:///./lib/errors/InvalidSourceError.js","webpack:///./lib/lru/collect.js","webpack:///./lib/lru/splice.js","webpack:///./lib/request/Source.js","webpack:///./lib/schedulers/ImmediateScheduler.js","webpack:///./lib/support/getTimestamp.js","webpack:///./lib/support/isJSONEnvelope.js","webpack:///./lib/support/isJSONGraphEnvelope.js","webpack:///./lib/support/now.js","webpack:///./lib/values/expires-never.js","webpack:///./lib/index.js","webpack:///.-path-utils/lib/collapse.js","webpack:///.-path-utils/lib/computeFlatBufferHash.js","webpack:///.-path-utils/lib/hasIntersection.js","webpack:///.-path-utils/lib/toFlatBuffer.js","webpack:///./lib/Model.js","webpack:///./lib/ModelDataSourceAdapter.js","webpack:///./lib/ModelRoot.js","webpack:///./lib/cache/call/index.js","webpack:///./lib/cache/get/index.js","webpack:///./lib/cache/get/json/onError.js","webpack:///./lib/cache/get/json/walkFlatBuffer.js","webpack:///./lib/cache/get/json/walkPath.js","webpack:///./lib/cache/get/jsonGraph/getReferenceTarget.js","webpack:///./lib/cache/get/jsonGraph/onValue.js","webpack:///./lib/cache/get/jsonGraph/walkPath.js","webpack:///./lib/cache/getCache.js","webpack:///./lib/cache/getVersion.js","webpack:///./lib/cache/groupCacheArguments.js","webpack:///./lib/cache/invalidate/index.js","webpack:///./lib/cache/mergeJSONGraphNode.js","webpack:///./lib/cache/set/index.js","webpack:///./lib/cache/transferBackReferences.js","webpack:///./lib/cache/unlinkBackReferences.js","webpack:///./lib/cache/unlinkForwardReference.js","webpack:///./lib/deref/hasValidParentReference.js","webpack:///./lib/deref/index.js","webpack:///./lib/errors/BoundJSONGraphModelError.js","webpack:///./lib/errors/InvalidDerefInputError.js","webpack:///./lib/errors/InvalidModelError.js","webpack:///./lib/errors/MaxRetryExceededError.js","webpack:///./lib/request/Call.js","webpack:///./lib/request/Queue.js","webpack:///./lib/request/Request.js","webpack:///./lib/request/Subject.js","webpack:///./lib/schedulers/TimeoutScheduler.js","webpack:///./lib/support/array-flat-map.js","webpack:///./lib/support/clone.js","webpack:///./lib/support/getExpires.js","webpack:///./lib/support/getType.js","webpack:///./lib/support/hasOwn.js","webpack:///./lib/support/isInternalKey.js","webpack:///./lib/support/isPathValue.js","webpack:///./lib/types/atom.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/lib/index.js","webpack:///./~/symbol-observable/lib/ponyfill.js","webpack:///(webpack)/buildin/module.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","o","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","now","$now","$never","module.exports","node","expireImmediate","exp","undefined","objTypeof","splice","expired","lru","$type","from","to","backRefs","NullInPathError","err","Error","MESSAGE","NAME","stack","message","isObject","clone","key","keys","json","index","length","getCachePosition","cache","path","type","depth","maxDepth","$ref","removeNode","updateBackReferenceVersions","nodeArg","offset","version","child","EXPIRES_NEVER","head","prev","next","Subscriber","destination","parent","onCompleted","Subscription","error","onError","onNext","complete","Subscriber.prototype.onNext","dest","Subscriber.prototype.onError","dispose","Subscriber.prototype.onCompleted","Subscriber.prototype.unsubscribe","subscriptions","Subscription.prototype.add","subscription","push","Subscription.prototype.remove","indexOf","Subscription.prototype.unsubscribe","getBoundCacheNode","model","setJSONGraphPathSet","messageRoot","messageParent","requestedPaths","optimizedPaths","requestedPath","optimizedPath","comparator","errorSelector","note","branch","keySet","iterateKeySet","optimizedIndex","results","setNode","nextNode","nextParent","nextOptimizedPath","reference","isExpired","expireNode","container","count","createHardlink","arr","mergeJSONGraphNode","Array","jsonGraphEnvelopes","modelRoot","initialVersion","jsonGraphEnvelopeIndex","jsonGraphEnvelopeCount","jsonGraphEnvelope","paths","jsonGraph","pathIndex","pathCount","newVersion","rootChangeHandler","setPathMap","pathMap","itr","isArray","keyIndex","keyCount","mergeValueOrInsertBranch","pathMapEnvelopes","bound","pathMapIndex","pathMapCount","pathMapEnvelope","flatBufferToPaths","flatBuf","leaf","keysLen","keysIndex","rest","keyset","getHashCode","str","hash","initializeRange","memo","nextValue","el","global","FalcorJSON","f_meta","toJSON","inst","typeofString","arguments","serialize","toProps","serializer","argsLen","typeofObject","total","xs","$code","fm_abs_path","fm_deref_to","fm_deref_from","$__hash","$__version","arrayProtoMethods","falcorJSONProto","methodName","method","writable","inlineJSONGraphValue","seed","curr","pathToTree","materializedAtom","onMissing","requestedLength","fromReference","optimizedLength","reportMissing","reportMaterialized","createMaterializedBranch","restPathIndex","restPath","restPathCount","isEmptyKeySet","rangeEnd","mPath","lastKeyIsNull","isRequestedPath","missingPaths","missTotal","missingPath","missDepth","Number","lruPromote","onValueType","branchSelector","boxValues","materialized","treatErrorsAsValues","onValue","invalidatePathSet","invalidateNode","removeNodeAndDescendants","updateNodeAncestors","getSize","lruSplice","unlinkBackReferences","unlinkForwardReference","key2","setPathSet","pathValues","pathValueIndex","pathValueCount","pathValue","InvalidKeySetError","keysOrRanges","JSON","InvalidKeySetError.is","e","g","Function","eval","window","toCollapseMap","collapseMap","acc","len","toTree","toCollapseTrees","collapseTrees","collapseKey","collapsePathMap","pathmap","subs","code","codes","codesIndex","codesCount","pathsets","pathsetsCount","subPath","subCode","subKeys","subKeysIndex","subKeysCount","pathsetClone","getSortedKeys","isSafeNumber","sets","parseInt","subSets","firstSubKey","subSetsIndex","subSetsCount","pathset","pathsetIndex","pathsetCount","sortListAscending","a","b","map","sort","val","num","typeOfString","MIN_SAFE_INTEGER_DIGITS","safeNumberRegEx","MAX_SAFE_INTEGER_DIGITS","typeOfNumber","MAX_SAFE_INTEGER","abs","Math","lengths","allPaths","allPathsLength","typeOfObject","pathsIndex","pathsCount","keysetIndex","keysetCount","isSparseRange","collapseIndex","seedKeySet","keysetLength","nextDepth","keyIsRange","iteratingKeyset","nextKey","walkPathAndBuildOutput","walkFlatBufferAndBuildOutput","InvalidModelError","toFlatBuffer","computeFlatBufferHash","getJSON","progressive","referenceContainer","boundPath","isFlatBuffer","data","recycleJSON","hasDataSource","Boolean","allowFromWhenceYouCame","requested","boundRequested","promote","CircularReferenceError","getReferenceTarget","ref","context","copy","$error","onJSONValue","BoundJSONGraphModelError","getJSONGraph","invalidatePathMap","getType","getTimestamp","wrapNode","insertNode","replaceNode","reconstructPath","mType","isDistinct","sizeOffset","currentPath","transferBackReferences","replacement","expiresNow","$atom","getExpires","typeArg","size","modelCreated","atomSize","expires","referencePath","InvalidSourceError","innerError","InvalidSourceError.is","totalArg","max","ratioArg","ratio","shouldUpdate","targetSize","Source","subscribe","source","$$observable","default","Source.prototype.operator","Source.prototype.lift","operator","Source.prototype.subscribe","x","y","Source.prototype.then","_promise","resolve","reject","values","rejected","errors","then","ImmediateScheduler","empty","unsubscribe","ImmediateScheduler.prototype.schedule","action","envelope","Date","falcor","opts","Model","toPaths","keysLength","hasIntersection","tree","pathToFlatBuffer","keysMap","nullBuffer","options","_node","_path","_source","_root","ModelRoot","_recycleJSON","_scheduler","_seed","_treatErrorsAsValues","_boxed","_materialized","_allowFromWhenceYouCame","setCache","Call","ModelDataSourceAdapter","TimeoutScheduler","lruCollect","isJSONEnvelope","isJSONGraphEnvelope","setJSONGraphs","getCache","Model.prototype.get","_toJSON","Model.prototype.set","Model.prototype.preload","Model.prototype.call","Model.prototype.invalidate","Model.prototype.getValue","lift","subscriber","Model.prototype.setValue","set","Model.prototype.setCache","cacheOrJSONGraphEnvelope","out","Model.prototype.getCache","result","Model.prototype.getVersion","concat","_getVersion","Model.prototype._clone","Model.prototype.batch","schedulerOrDelay","scheduler","scheudle","_clone","Model.prototype.unbatch","Model.prototype.treatErrorsAsValues","Model.prototype.asDataSource","Model.prototype._materialize","Model.prototype._dematerialize","Model.prototype.boxValues","Model.prototype.unboxValues","Model.prototype.withoutDataSource","Model.prototype.toJSON","getPath","Model.prototype.getPath","slice","Model.prototype._fromWhenceYouCame","allow","Model.prototype._optimizePath","abs_path","_model","ModelDataSourceAdapter.prototype.get","pathSets","apply","_toJSONG","ModelDataSourceAdapter.prototype.set","jsongResponse","ModelDataSourceAdapter.prototype.call","args","suffixes","syncRefCount","maxRetryCount","topLevelModel","requests","Requests","collectRatio","maxSize","functionTypeof","onChange","onChangesCompleted","hasOwn","ModelRoot.prototype.errorSelector","ModelRoot.prototype.comparator","cacheNode","messageNode","_args","hasValue","missing","thisPaths","relative","fragments","errorPath","errorValue","cacheRoot","refTarget","f_old_keys","f_new_keys","f_code","nextJSON","nextReferenceContainer","nextOptimizedLength","optimizedLengthNext","refContainerAbsPath","refContainerRefPath","nextPath","nextPathKey","hasMissingPath","rPath","wrapMaterializedBranchSelector","createDefaultMaterializedBranch","originalOnMissing","_depth","inlineValue","onJSONGraphValue","isLeaf","_copyCache","fromKey","k","isInternalKey","cacheNext","outNext","isUserCreatedcacheNext","clonedValue","boxedValue","isPathValue","groupCacheArguments","groups","argIndex","argCount","group","groupType","arg","argType","inputType","invalidate","invalidatePathSets","cType","cIsObject","mIsObject","cTimestamp","mTimestamp","setGroupsIntoCache","groupIndex","groupCount","selector","groupedArgs","resultPaths","operation","pluckPaths","arrayFlatMap","optimized","jsong","setPathMaps","setPathValues","fromNode","destNode","fromNodeRefsLength","destNodeRefsLength","hasValidParentReference","_referenceContainer","InvalidDerefInputError","boundJSONArg","currentRefPath","jsonMetadata","absolutePath","originalRefPath","originalAbsPath","validContainer","CONTAINER_DOES_NOT_EXIST","shortedPath","MaxRetryExceededError","absolute","printPaths","MaxRetryExceededError.is","CallOperator","CallSubscriber","retryCount","completed","tryOnNext","collapse","mergeInto","destValue","nodeValue","Call.prototype.lift","Call.prototype.operator","_subscribe","Call.prototype._subscribe","Call.prototype._toJSON","Call.prototype._toJSONG","Call.prototype.retry","progresive","Call.prototype.progressively","CallOperator.prototype.call","CallSubscriber.prototype.onNext","started","seedIsImmutable","operations","CallSubscriber.prototype.onError","errored","CallSubscriber.prototype.onCompleted","request","CallSubscriber.prototype.unsubscribe","rootOnChangesCompletedHandler","Queue","Dedupe","queue","dataSource","Request","isolateSet","env","batch","isolateCall","batchAndDedupeGet","Dedupe.prototype.subscribe","requestsIndex","requestsCount","Subject","responded","active","disposable","flush","obs","reduce","invalidatePaths","Request.prototype.onNext","invalidated","observers","forEach","observer","Request.prototype.onError","errorPathValues","Request.prototype.onCompleted","Request.prototype.remove","Request.prototype.unsubscribe","Request.prototype.connect","scheduledDisposable","schedule","Request.prototype.batch","requestedComplements","optimizedComplements","requestedIntersection","optimizedIntersection","complementIndex","intersectionIndex","intersectionFound","pathLen","subTree","Subject.prototype.onNext","Subject.prototype.onError","Subject.prototype.onCompleted","Subject.prototype.subscribe","Subject.prototype.unsubscribe","delay","TimerDisposable","id","disposed","TimeoutScheduler.prototype.schedule","setTimeout","TimerDisposable.prototype.unsubscribe","clearTimeout","array","array2","array3","j","anyType","obj","prop","_ponyfill","_ponyfill2","self","symbolObservablePonyfill","_Symbol","Symbol","observable","webpackPolyfill","deprecate","module.deprecate","children"],"mappings":"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","file":"falcor.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * \n * Copyright 2015 Netflix, Inc\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 108);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\nmodule.exports = \"ref\";\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(58);\nvar $now = __webpack_require__(32);\nvar $never = __webpack_require__(59);\n\nmodule.exports = function isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\nvar objTypeof = \"object\";\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar splice = __webpack_require__(52);\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[\"\\u001ef_invalidated\"]) {\n        node[\"\\u001ef_invalidated\"] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = { $type: 'atom' };\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[\"\\u001ef_refs_length\"] || 0;\n    to[\"\\u001ef_ref\" + backRefs] = from;\n    to[\"\\u001ef_refs_length\"] = backRefs + 1;\n\n    // create a hard reference\n    from[\"\\u001ef_ref_index\"] = backRefs;\n    from[\"\\u001ef_context\"] = to;\n};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nvar NAME = \"NullInPathError\";\nvar MESSAGE = \"`null` is not allowed in branch key positions.\";\n\n/**\n * Does not allow null in path\n */\nfunction NullInPathError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nNullInPathError.prototype = Object.create(Error.prototype);\nNullInPathError.prototype.name = NAME;\nNullInPathError.message = MESSAGE;\n\nmodule.exports = NullInPathError;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(2);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key,\n        keys = Object.keys(node),\n        json = {},\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (key.charAt(0) === \"\\u001e\") {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(0);\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type,\n        depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === $ref) {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(28);\nvar updateBackReferenceVersions = __webpack_require__(47);\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child[\"\\u001ef_parent\"];\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child[\"\\u001ef_key\"], lru);\n        } else if (child[\"\\u001ef_version\"] !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EXPIRES_NEVER = __webpack_require__(59);\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root[\"\\u001ef_head\"];\n\n    // Nothing is in the cache.\n    if (!head) {\n        root[\"\\u001ef_head\"] = root[\"\\u001ef_tail\"] = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[\"\\u001ef_prev\"];\n    var next = object[\"\\u001ef_next\"];\n    if (next) {\n        next[\"\\u001ef_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\\u001ef_next\"] = next;\n    }\n    object[\"\\u001ef_prev\"] = undefined;\n\n    // Insert into head position\n    root[\"\\u001ef_head\"] = object;\n    object[\"\\u001ef_next\"] = head;\n    head[\"\\u001ef_prev\"] = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root[\"\\u001ef_tail\"]) {\n        root[\"\\u001ef_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscription = __webpack_require__(13);\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' || typeof parent === 'function' || typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        };\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next = Subscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n};\n\nSubscriber.prototype.error = Subscriber.prototype.onError = function onError(error) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            dest.onError(error);\n        } else if (dest.error) {\n            dest.error(error);\n        }\n        this.dispose();\n    } else {\n        this.dispose();\n        throw error;\n    }\n};\n\nSubscriber.prototype.complete = Subscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n};\n\nSubscriber.prototype.dispose = Subscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\nmodule.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function (subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n};\n\nSubscription.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n};\n\nSubscription.prototype.dispose = Subscription.prototype.unsubscribe = function () {\n    var subscription,\n        subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) && subscription.dispose && subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = \"error\";\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getCachePosition = __webpack_require__(9);\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[\"\\u001ef_parent\"] === undefined || node[\"\\u001ef_invalidated\"]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(5);\nvar $ref = __webpack_require__(0);\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar createHardlink = __webpack_require__(5);\nvar mergeJSONGraphNode = __webpack_require__(80);\nvar NullInPathError = __webpack_require__(6);\nvar iterateKeySet = __webpack_require__(20);\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var initialVersion = cache[\"\\u001ef_version\"];\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    var newVersion = cache[\"\\u001ef_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, results[3], results[2], requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            node = results[0];\n            optimizedPath = results[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[\"\\u001ef_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, messageRoot, messageParent, message, key, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isArray = Array.isArray;\nvar $ref = __webpack_require__(0);\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar createHardlink = __webpack_require__(5);\nvar getCachePosition = __webpack_require__(9);\nvar NullInPathError = __webpack_require__(6);\nvar mergeValueOrInsertBranch = __webpack_require__(44);\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n    var parent = node[\"\\u001ef_parent\"] || cache;\n    var initialVersion = cache[\"\\u001ef_version\"];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[\"\\u001ef_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[\"\\u001ef_context\"];\n\n        if (node != null) {\n            parent = node[\"\\u001ef_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\\u001ef_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (type === void 0) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === \"\\u001e\" || key[0] === \"$\") {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports = flatBufferToPaths;\n\nfunction flatBufferToPaths(flatBuf, paths, path) {\n\n    path = path || [];\n    paths = paths || [];\n\n    var leaf = [];\n    var keys = flatBuf['$keys'];\n    var keysLen = keys.length;\n    var keysIndex = -1,\n        key,\n        len;\n\n    while (++keysIndex < keysLen) {\n\n        var rest = flatBuf[keysIndex];\n        var keyset = keys[keysIndex];\n\n        if (!rest) {\n            leaf.push(keyset);\n        } else {\n            flatBufferToPaths(rest, paths, path.concat([keyset]));\n        }\n    }\n\n    if (leaf.length === 1) {\n        paths.push(path.concat(leaf));\n    } else if (leaf.length > 1) {\n        paths.push(path.concat([leaf]));\n    }\n\n    return paths;\n}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = getHashCode;\n\nfunction getHashCode(str) {\n    var hash = 5381,\n        i = str.length;\n    while (i) {\n        hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset,\n                length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                    ++note.arrayOffset;\n                    nextValue = el;\n                }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n            if (!note.loaded) {\n                initializeRange(keySet, note);\n            }\n            if (note.rangeOffset > note.to) {\n                note.done = true;\n                return undefined;\n            }\n\n            return note.rangeOffset++;\n        }\n\n        // Primitive value\n        else {\n                note.done = true;\n                return keySet;\n            }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to || typeof key.length === 'number' && memo.from + key.length - 1 || 0;\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {function FalcorJSON(f_meta) {\n    this[\"\\u001ef_metadata\"] = f_meta || {};\n}\n\nFalcorJSON.prototype = Object.create(Object.prototype, Object.assign({\n    toJSON: { value: toJSON },\n    toProps: { value: toProps },\n    serialize: { value: serialize },\n    $__hash: {\n        enumerable: false,\n        get() {\n            var f_meta = this[\"\\u001ef_metadata\"];\n            return f_meta && f_meta[\"$code\"] || '';\n        }\n    },\n    $__version: {\n        enumerable: false,\n        get() {\n            var f_meta = this[\"\\u001ef_metadata\"];\n            return f_meta && f_meta[\"version\"] || 0;\n        }\n    }\n}, arrayProtoMethods().reduce((falcorJSONProto, methodName) => {\n    var method = Array.prototype[methodName];\n    falcorJSONProto[methodName] = {\n        writable: true, enumerable: false, value() {\n            return method.apply(this, arguments);\n        }\n    };\n    return falcorJSONProto;\n}, {})));\n\nfunction arrayProtoMethods() {\n    return ['concat', 'copyWithin', 'entries', 'every', 'fill', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'keys', 'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight', 'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'unshift', 'values'];\n}\n\nvar isArray = Array.isArray;\nvar typeofObject = 'object';\nvar typeofString = 'string';\n\nfunction toJSON(inst) {\n    if (typeof inst === typeofString) {\n        if (arguments.length !== 1) {\n            return inst;\n        }\n        inst = this;\n    } else if (!inst) {\n        inst = this;\n    } else if (inst === global) {\n        return undefined;\n    }\n    var json = serialize(inst, toJSON);\n    if (json[\"\\u001ef_metadata\"]) {\n        delete json[\"\\u001ef_metadata\"];\n    }\n    return json;\n}\n\nfunction toProps(inst, serializer) {\n    var argsLen = arguments.length;\n    inst = argsLen === 0 ? this : inst;\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    } else if (inst === global) {\n        return {};\n    }\n    var json = serialize(inst, argsLen > 0 && serializer || toProps);\n    var f_meta = json[\"\\u001ef_metadata\"];\n    if (f_meta) {\n        delete json[\"\\u001ef_metadata\"];\n        f_meta[\"version\"] = inst[\"\\u001ef_metadata\"][\"version\"];\n        json.__proto__ = new FalcorJSON(f_meta);\n    }\n    return json;\n}\n\nfunction serialize(inst, serializer) {\n\n    var argsLen = arguments.length;\n    inst = argsLen === 0 ? this : inst;\n\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    } else if (inst === global) {\n        return {};\n    }\n\n    var count, total, f_meta, keys, key, xs;\n\n    serializer = argsLen > 0 && serializer || serialize;\n\n    if (isArray(inst)) {\n        count = -1;\n        total = inst.length;\n        xs = new Array(total);\n        while (++count < total) {\n            xs[count] = inst[count];\n        }\n    } else {\n        xs = {};\n        count = -1;\n        f_meta = inst[\"\\u001ef_metadata\"];\n        keys = Object.keys(inst);\n        total = keys.length;\n        if (f_meta) {\n            var $code = f_meta[\"$code\"],\n                fm_abs_path = f_meta[\"abs_path\"],\n                fm_deref_to = f_meta[\"deref_to\"],\n                fm_deref_from = f_meta[\"deref_from\"];\n            xs[\"\\u001ef_metadata\"] = f_meta = {};\n            $code && (f_meta[\"$code\"] = $code);\n            fm_abs_path && (f_meta[\"abs_path\"] = fm_abs_path);\n            fm_deref_to && (f_meta[\"deref_to\"] = fm_deref_to);\n            fm_deref_from && (f_meta[\"deref_from\"] = fm_deref_from);\n        }\n        while (++count < total) {\n            key = keys[count];\n            if (key !== \"\\u001ef_metadata\") {\n                xs[key] = serializer(inst[key], serializer);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33)))\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(38);\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(41);\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nmodule.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key,\n        depth = 0,\n        prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar pathToTree = __webpack_require__(37).pathToTree;\nvar materializedAtom = __webpack_require__(4);\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, createMaterializedBranch) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        if (restPathCount === 0) {\n            return materializedAtom;\n        }\n        return pathToTree(json, mPath, missDepth, missTotal, materializedAtom, createMaterializedBranch);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if (\"object\" !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if (\"number\" !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar lruPromote = __webpack_require__(11);\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, reportMissing, treatErrorsAsValues, onValue, onMissing) {\n\n    var reportMaterialized = materialized;\n\n    if (!node || !type) {\n        if (materialized) {\n            reportMaterialized = true;\n            seed && (results.hasValue = true);\n        }\n        return onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, branchSelector);\n    } else if (isExpired(node, expireImmediate)) {\n        if (!node[\"\\u001ef_invalidated\"]) {\n            expireNode(node, expired, modelRoot);\n        }\n        return onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, branchSelector);\n    }\n\n    lruPromote(modelRoot, node);\n\n    if (seed) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n        }\n        return onValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues);\n    }\n\n    return undefined;\n}\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar $ref = __webpack_require__(0);\n\nvar getBoundCacheNode = __webpack_require__(15);\n\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar lruPromote = __webpack_require__(11);\nvar getSize = __webpack_require__(7);\nvar createHardlink = __webpack_require__(5);\nvar iterateKeySet = __webpack_require__(20);\nvar updateNodeAncestors = __webpack_require__(10);\nvar removeNodeAndDescendants = __webpack_require__(29);\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node[\"\\u001ef_parent\"] || cache;\n    var initialVersion = cache[\"\\u001ef_version\"];\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(path, 0, cache, parent, node, version, expired, lru, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    var newVersion = cache[\"\\u001ef_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(path, depth, root, parent, node, version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        arr = invalidateNode(root, parent, node, key, branch, false, version, expired, lru, expireImmediate);\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru, expireImmediate);\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\\u001ef_context\"];\n\n    if (node != null) {\n        parent = node[\"\\u001ef_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(root, parent, node, key, branch, true, version, expired, lru, expireImmediate);\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[\"\\u001ef_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(root, parent, node, key, branch, reference, version, expired, lru, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        arr = invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[\"\\u001ef_key\"];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(0);\nvar lruSplice = __webpack_require__(52);\nvar unlinkBackReferences = __webpack_require__(83);\nvar unlinkForwardReference = __webpack_require__(84);\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node[\"\\u001ef_parent\"] = void 0;\n        return true;\n    }\n    return false;\n};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(28);\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (key2[0] !== \"\\u001e\" && key2[0] !== \"$\") {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar $ref = __webpack_require__(0);\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar createHardlink = __webpack_require__(5);\nvar getCachePosition = __webpack_require__(9);\nvar NullInPathError = __webpack_require__(6);\nvar iterateKeySet = __webpack_require__(20);\nvar mergeValueOrInsertBranch = __webpack_require__(44);\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n    var parent = node[\"\\u001ef_parent\"] || cache;\n    var initialVersion = cache[\"\\u001ef_version\"];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[\"\\u001ef_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[\"\\u001ef_context\"];\n\n        if (node != null) {\n            parent = node[\"\\u001ef_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\\u001ef_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\\u001ef_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidKeySetError\";\nvar MESSAGE = \"Keysets can only contain Keys or Ranges\";\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidKeySetError(path, keysOrRanges) {\n    var err = Error.call(this, \"The KeySet \" + JSON.stringify(keysOrRanges) + \" in path \" + JSON.stringify(path) + \" contains a KeySet. \" + MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidKeySetError.prototype = Object.create(Error.prototype);\nInvalidKeySetError.prototype.name = NAME;\nInvalidKeySetError.is = function (e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidKeySetError;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\nmodule.exports = 0;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar flatBufferToPaths = __webpack_require__(18);\n\nmodule.exports = toCollapseMap;\n\nfunction toCollapseMap(paths, collapseMap) {\n    if (!paths) {\n        return collapseMap;\n    } else if (!isArray(paths)) {\n        if (isArray(paths.$keys)) {\n            paths = flatBufferToPaths(paths);\n        }\n    }\n    return paths.reduce(function (acc, path) {\n        var len = path.length;\n        if (!acc[len]) {\n            acc[len] = [];\n        }\n        acc[len].push(path);\n        return acc;\n    }, collapseMap || {});\n}\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toTree = __webpack_require__(37);\n\nmodule.exports = toCollapseTrees;\n\nfunction toCollapseTrees(collapseMap, collapseTrees) {\n    return Object.keys(collapseMap).reduce(function (collapseTrees, collapseKey) {\n        collapseTrees[collapseKey] = toTree(collapseMap[collapseKey], collapseTrees[collapseKey]);\n        return collapseTrees;\n    }, collapseTrees || {});\n}\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeOfObject = \"object\";\nvar typeOfString = \"string\";\nvar typeOfNumber = \"number\";\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\nvar getHashCode = __webpack_require__(19);\nvar materializedAtom = __webpack_require__(4);\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var subs = Object.create(null);\n    var code = '' + getHashCode('' + depth);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode, subKeys, subKeysIndex, subKeysCount, subSets, subSetsIndex, subSetsCount, pathset, pathsetIndex, pathsetCount, firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if (subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = '' + getHashCode(code + key + subCode);\n\n            isSafeNumber(key) && subPath.keys.push(parseInt(key, 10)) || subPath.keys.push(key);\n        }\n\n        while (++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = '' + getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/) {\n                isSparseRange = false;\n                break;\n            }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === materializedAtom) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\n// function getHashCode(key) {\n//     var code = 5381;\n//     var index = -1;\n//     var count = key.length;\n//     while (++index < count) {\n//         code = (code << 5) + code + key.charCodeAt(index);\n//     }\n//     return String(code);\n// }\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar materializedAtom = __webpack_require__(4);\n\nmodule.exports = toTree;\nmodule.exports.pathToTree = pathToTree;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\n\nfunction toTree(paths, seed) {\n    return paths.reduce(function (seed, path) {\n        return pathToTree(seed, path, 0, path.length, null);\n    }, seed || {});\n};\n\nfunction pathToTree(seed, path, depth, length, value, branch) {\n\n    if (depth === length) {\n        return true; //seed || value;\n    }\n\n    var seedKeySet,\n        keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var node,\n        next,\n        nextKey,\n        nextDepth = depth + 1,\n        keyIsRange,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return materializedAtom;\n    }\n\n    seedKeySet = keyset;\n    seed = seed ? seed : branch ? branch(path, depth, seed) : {};\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = value;\n            } else {\n                node = seed[path[depth] = nextKey];\n                next = pathToTree(node, path, nextDepth, length, value);\n                // next = pathToTree(node ||\n                //     branch && branch(path, depth, seed) || {},\n                //     path, nextDepth, length, value);\n                if (!next) {\n                    seed[nextKey] = value;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    path[depth] = seedKeySet;\n\n    return seed;\n}\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar walkPathAndBuildOutput = __webpack_require__(72);\nvar walkFlatBufferAndBuildOutput = __webpack_require__(71);\nvar getBoundCacheNode = __webpack_require__(15);\nvar InvalidModelError = __webpack_require__(89);\nvar toFlatBuffer = __webpack_require__(64);\nvar computeFlatBufferHash = __webpack_require__(62);\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        results = { data: seed },\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    var arr,\n        path,\n        pathsIndex = 0,\n        pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n        if (recycleJSON) {\n            pathsCount = 1;\n            isFlatBuffer = true;\n            if (!paths[0].$keys || paths.length > 1) {\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n            do {\n                path = paths[pathsIndex];\n                arr = walkFlatBufferAndBuildOutput(cache, node, json, path, 0, seed, results, requestedPath, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n                json = arr[0];\n                arr[0] = undefined;\n                arr[1] = undefined;\n            } while (++pathsIndex < pathsCount);\n        } else {\n            do {\n                path = paths[pathsIndex];\n                requestedLength = path.length;\n                json = walkPathAndBuildOutput(cache, node, json, path,\n                /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            } while (++pathsIndex < pathsCount);\n        }\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args; //requested;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar $ref = __webpack_require__(0);\nvar promote = __webpack_require__(11);\nvar isExpired = __webpack_require__(1);\nvar createHardlink = __webpack_require__(5);\nvar CircularReferenceError = __webpack_require__(49);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        followedRefsCount = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\\u001ef_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (false) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\"Followed \" + followedRefsCount + \" references. \" + \"This might indicate the presence of an indirect \" + \"circular reference chain.\");\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = typeof console.warn === \"function\" && console.warn || typeof console.log === \"function\" && console.log;\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(8);\nvar onError = __webpack_require__(70);\nvar $error = __webpack_require__(14);\nvar materializedAtom = __webpack_require__(4);\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath, fromReference, boxValues);\n    }\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            debugger;\n            results.hasValue = true;\n            return materializedAtom;\n        }\n        return undefined;\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    if (boxValues) {\n        return clone(node);\n    }\n\n    return value;\n}\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar walkPathAndBuildOutput = __webpack_require__(75);\nvar BoundJSONGraphModelError = __webpack_require__(87);\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        results = { data: seed },\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n        /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n        /* fromReference = */false, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args = results.relative = results.requested;\n\n    return results;\n}\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node[\"\\u001ef_key\"] = key;\n    node[\"\\u001ef_parent\"] = parent;\n\n    if (version !== undefined) {\n        node[\"\\u001ef_version\"] = version;\n    }\n    if (!node[\"\\u001ef_abs_path\"]) {\n        node[\"\\u001ef_abs_path\"] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(0);\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar lruPromote = __webpack_require__(11);\nvar getSize = __webpack_require__(7);\nvar createHardlink = __webpack_require__(5);\nvar getBoundCacheNode = __webpack_require__(15);\nvar updateNodeAncestors = __webpack_require__(10);\nvar removeNodeAndDescendants = __webpack_require__(29);\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node[\"\\u001ef_parent\"] || cache;\n    var initialVersion = cache[\"\\u001ef_version\"];\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, expireImmediate);\n    }\n\n    var newVersion = cache[\"\\u001ef_version\"];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (key[0] !== \"\\u001e\" && key[0] !== \"$\") {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            var results = invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, expireImmediate);\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, expireImmediate);\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\\u001ef_context\"];\n\n    if (node != null) {\n        parent = node[\"\\u001ef_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, expireImmediate);\n            node = results[0];\n            if (!node || typeof node !== 'object') {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container[\"\\u001ef_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(root, parent, node, key, value, branch, reference, version, expired, lru, comparator, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate);\n\n        node = results[0];\n\n        if (!node && typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[\"\\u001ef_key\"];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(0);\nvar $error = __webpack_require__(14);\nvar $now = __webpack_require__(32);\nvar getType = __webpack_require__(99);\nvar getSize = __webpack_require__(7);\nvar getTimestamp = __webpack_require__(55);\n\nvar wrapNode = __webpack_require__(48);\nvar isExpired = __webpack_require__(1);\nvar expireNode = __webpack_require__(3);\nvar insertNode = __webpack_require__(42);\nvar replaceNode = __webpack_require__(46);\nvar reconstructPath = __webpack_require__(45);\nvar updateNodeAncestors = __webpack_require__(10);\n\nmodule.exports = function mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node,\n        /* expireImmediate:\n         * force true so the node is marked as\n         * expired but keep using it for the merge if it expires immediately\n         */\n        true)) {\n            expireNode(node, expired, lru);\n            type = node.$expires === $now ? type : 'expired';\n        }\n        if (type && type !== $ref || !node || typeof node !== 'object') {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && comparator) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (errorSelector && mType === $error) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize(node) - getSize(message);\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n  var path = currentPath.slice(0, currentPath.depth);\n  path[path.length] = key;\n\n  return path;\n};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar transferBackReferences = __webpack_require__(82);\nvar removeNodeAndDescendants = __webpack_require__(29);\nvar updateBackReferenceVersions = __webpack_require__(47);\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        if (node && node[\"\\u001ef_version\"] !== version) {\n            node[\"\\u001ef_version\"] = version;\n            stack[count++] = node[\"\\u001ef_parent\"];\n            var i = -1;\n            var n = node[\"\\u001ef_refs_length\"] || 0;\n            while (++i < n) {\n                stack[count++] = node[\"\\u001ef_ref\" + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar now = __webpack_require__(58);\nvar expiresNow = __webpack_require__(32);\n\nvar $atom = __webpack_require__(103);\nvar clone = __webpack_require__(97);\nvar getSize = __webpack_require__(7);\nvar getExpires = __webpack_require__(98);\n\nvar atomSize = 50;\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[\"\\u001ef_wrapped_value\"];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[\"\\u001ef_prev\"] = undefined;\n        node[\"\\u001ef_next\"] = undefined;\n        node[\"\\u001ef_wrapped_value\"] = modelCreated || false;\n    } else {\n        node = { $type: $atom, value: value };\n        node[\"\\u001ef_prev\"] = undefined;\n        node[\"\\u001ef_next\"] = undefined;\n        node[\"\\u001ef_wrapped_value\"] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + expires * -1;\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\nvar NAME = \"CircularReferenceError\";\n\n/**\n * Does not allow null in path\n */\nfunction CircularReferenceError(referencePath) {\n    var err = Error.call(this, \"Encountered circular reference \" + JSON.stringify(referencePath));\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nCircularReferenceError.prototype = Object.create(Error.prototype);\nCircularReferenceError.prototype.name = NAME;\n\nmodule.exports = CircularReferenceError;\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidSourceError\";\nvar MESSAGE = \"An exception was thrown when making a request.\";\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidSourceError(error) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.innerError = error;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidSourceError.prototype = Object.create(Error.prototype);\nInvalidSourceError.prototype.name = NAME;\nInvalidSourceError.is = function (e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidSourceError;\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(28);\nvar updateNodeAncestors = __webpack_require__(10);\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node[\"\\u001ef_parent\"]) {\n            // eslint-disable-line no-cond-assign\n            removeNode(node, parent, node[\"\\u001ef_key\"], lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru[\"\\u001ef_tail\"];\n        node = prev;\n        while (total >= targetSize && node) {\n            prev = prev[\"\\u001ef_prev\"];\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru[\"\\u001ef_tail\"] = lru[\"\\u001ef_prev\"] = node;\n        if (node == null) {\n            lru[\"\\u001ef_head\"] = lru[\"\\u001ef_next\"] = undefined;\n        } else {\n            node[\"\\u001ef_next\"] = undefined;\n        }\n    }\n};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object[\"\\u001ef_prev\"];\n    var next = object[\"\\u001ef_next\"];\n    if (next) {\n        next[\"\\u001ef_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\\u001ef_next\"] = next;\n    }\n    object[\"\\u001ef_prev\"] = object[\"\\u001ef_next\"] = undefined;\n\n    if (object === root[\"\\u001ef_head\"]) {\n        root[\"\\u001ef_head\"] = next;\n    }\n    if (object === root[\"\\u001ef_tail\"]) {\n        root[\"\\u001ef_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var Subscriber = __webpack_require__(12);\nvar Subscription = __webpack_require__(13);\nvar $$observable = __webpack_require__(104).default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function () {\n    return this;\n};\n\nSource.prototype.operator = function (destination) {\n    return this.subscribe(destination);\n};\n\nSource.prototype.lift = function (operator, source) {\n    source = new Source(source || this);\n    source.operator = operator;\n    return source;\n};\n\nSource.prototype.subscribe = function (destination, x, y) {\n    return new Subscription([this.operator.call(this.source, !(destination instanceof Subscriber) ? new Subscriber(destination, x, y) : destination)]);\n};\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function (resolve, reject) {\n            var values = [],\n                rejected = false;\n            source.subscribe({\n                next: function (value) {\n                    values[values.length] = value;\n                },\n                error: function (errors) {\n                    (rejected = true) && reject(errors);\n                },\n                complete: function () {\n                    !rejected && resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33)))\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\nvar empty = {\n    dispose: function () {},\n    unsubscribe: function () {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(2);\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(2);\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && \"json\" in envelope;\n};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(2);\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));\n};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\nmodule.exports = Date.now;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\nmodule.exports = 1;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar Model = __webpack_require__(65);\nvar FalcorJSON = __webpack_require__(21);\n\nfunction falcor(opts) {\n    return new Model(opts);\n}\n\nfalcor[\"Model\"] = Model;\nfalcor[\"FalcorJSON\"] = FalcorJSON;\nfalcor[\"toProps\"] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toPaths = __webpack_require__(36);\nvar toCollapseMap = __webpack_require__(34);\nvar toCollapseTrees = __webpack_require__(35);\n\nmodule.exports = function collapse(paths) {\n    return toPaths(toCollapseTrees(toCollapseMap(paths)));\n};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar getHashCode = __webpack_require__(19);\n\nmodule.exports = computeFlatBufferHash;\n\nfunction computeFlatBufferHash(seed) {\n\n    if (seed === undefined) {\n        return undefined;\n    }\n\n    var code = '';\n    var keys = seed['$keys'];\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    while (++keysIndex < keysLength) {\n\n        var key = keys[keysIndex];\n\n        if (key === null) {\n            code = '' + getHashCode('' + code + 'null');\n            continue;\n        } else if (typeof key === 'object') {\n            key = '{from:' + key.from + ',length:' + key.length + '}';\n        }\n\n        var next = computeFlatBufferHash(seed[keysIndex]);\n        if (next === undefined) {\n            code = '' + getHashCode('' + code + key);\n        } else {\n            code = '' + getHashCode('' + code + key + next['$code']);\n        }\n    }\n\n    seed['$code'] = code;\n\n    return seed;\n}\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar materializedAtom = __webpack_require__(4);\n\nmodule.exports = hasIntersection;\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var next,\n        nextKey,\n        nextDepth = depth + 1,\n        keyIsRange,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar nullBuffer = { '$keys': [null], '$keysMap': { 'null': 0 } };\nvar flatBufferToPaths = __webpack_require__(18);\n\nmodule.exports = toFlatBuffer;\n\n/*\nvar inspect = require('util').inspect;\nvar computeFlatBufferHash = require('./computeFlatBufferHash');\nvar flatBuf = computeFlatBufferHash(toFlatBuffer([\n    ['genreLists', 'length'],\n    ['genreLists', { from: 1, length: 9 }, ['name', 'rating']],\n    ['genreLists', { from: 1, length: 9 }, 'color', null],\n    ['genreLists', { from: 1, length: 9 }, 'titles', 'length'],\n    ['genreLists', { from: 1, length: 9 }, 'titles', { from: 9, length: 2 }, ['name', 'rating', 'box-shot']],\n]));\n\nconsole.log(inspect(flatBuf, { depth: null }));\n*/\n\nfunction toFlatBuffer(paths, seed) {\n    return paths.reduce(function (seed, path) {\n        if (isArray(path)) {\n            return pathToFlatBuffer(seed, path, 0, path.length);\n        }\n        return toFlatBuffer(flatBufferToPaths(path), seed);\n    }, seed || {});\n}\n\nfunction pathToFlatBuffer(seed, path, depth, length) {\n\n    if (depth === length) {\n        return undefined;\n    }\n\n    seed = seed || {};\n    var keys = seed['$keys'] || (seed['$keys'] = []);\n    var keysMap = seed['$keysMap'] || (seed['$keysMap'] = {});\n    var keysIndex = -1;\n\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var node,\n        next,\n        nextKey,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullBuffer;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = nextKey;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyset = { from: nextKey, length: rangeEnd - nextKey + 1 };\n                    nextKey = '{from:' + nextKey + ',length:' + (rangeEnd - nextKey + 1) + '}';\n                    if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                        keysIndex = keys.length;\n                    }\n                    keys[keysIndex] = keyset;\n                    keysMap[nextKey] = keysIndex;\n                    next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n                    if (next !== undefined) {\n                        seed[keysIndex] = next;\n                    }\n                }\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Call = __webpack_require__(91);\nvar ModelRoot = __webpack_require__(67);\nvar ModelDataSourceAdapter = __webpack_require__(66);\nvar TimeoutScheduler = __webpack_require__(95);\nvar ImmediateScheduler = __webpack_require__(54);\n\nvar lruCollect = __webpack_require__(51);\nvar getSize = __webpack_require__(7);\nvar isObject = __webpack_require__(2);\nvar isJSONEnvelope = __webpack_require__(56);\nvar getCachePosition = __webpack_require__(9);\nvar isJSONGraphEnvelope = __webpack_require__(57);\n\nvar setCache = __webpack_require__(17);\nvar setJSONGraphs = __webpack_require__(16);\n\nvar getJSON = __webpack_require__(22);\nvar getCache = __webpack_require__(76);\nvar getJSONGraph = __webpack_require__(23);\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n/**\n* This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n* @callback Model~errorSelector\n* @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n* @returns {Object} the JSONGraph Error object to store in the Model cache.\n*/\n\n/**\n* This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n* @callback Model~comparator\n* @param {Object} existingValue - the current value in the Model cache.\n* @param {Object} newValue - the value about to be set into the Model cache.\n* @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n*/\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._seed = {};\n        this._treatErrorsAsValues = true;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get() {\n    return new Call('get', this, Array.prototype.slice.call(arguments, 0))._toJSON(this._seed || {}, []);\n};\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set() {\n    return new Call('set', this, Array.prototype.slice.call(arguments, 0))._toJSON({}, []);\n};\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    return new Call('get', this, Array.prototype.slice.call(arguments, 0))._toJSON(null, []);\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call() {\n    return new Call('call', this, Array.prototype.slice.call(arguments, 0))._toJSON({}, []);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    return new Call('invalidate', this, Array.prototype.slice.call(arguments, 0))._toJSON(null, null).then();\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = __webpack_require__(86);\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = __webpack_require__(85);\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return this.get(path).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : { path: path, value: value };\n    return this.set(value).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._seed = null;\n        this._node = this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            lruCollect(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        var out;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (out) {\n            getJSON(this, out, null, false, true);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache() {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n    var result = {};\n    var path = this._path;\n    this._path = [];\n    getJSONGraph(this, paths, result);\n    this._path = path;\n    return result.jsonGraph;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path = []) {\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === \"delete\") {\n                delete clone[key];\n            } else if (key === \"_path\") {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty(\"_node\")) {\n                    delete clone[\"_node\"];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === \"number\") {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[\"\\u001ef_abs_path\"] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = __webpack_require__(77);\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = __webpack_require__(30);\nModel.prototype._setPathMaps = __webpack_require__(17);\nModel.prototype._setJSONGs = __webpack_require__(16);\nModel.prototype._setCache = __webpack_require__(17);\n\nModel.prototype._invalidatePathValues = __webpack_require__(27);\nModel.prototype._invalidatePathMaps = __webpack_require__(43);\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\nfunction ModelDataSourceAdapter(model) {\n    this._model = model._materialize().treatErrorsAsValues();\n    // this._model = model._materialize().boxValues().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [path, args, suffixes].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar functionTypeof = 'function';\nvar hasOwn = __webpack_require__(100);\nvar Requests = __webpack_require__(92);\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = 0;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\n\nModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value && cacheNode.$type === messageNode.$type && cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(22);\nvar getJSONGraph = __webpack_require__(23);\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    args = [].concat(_args[1] || []);\n    suffixes = [].concat(_args[2] || []);\n    thisPaths = [].concat(_args[3] || []);\n    path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        args: null,\n        data: data,\n        missing: [],\n        relative: [],\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    args = [].concat(_args[1] || []);\n    suffixes = [].concat(_args[2] || []);\n    thisPaths = [].concat(_args[3] || []);\n    path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        args: null,\n        data: data,\n        missing: [],\n        relative: [],\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n    json: __webpack_require__(38),\n    jsonGraph: __webpack_require__(41)\n};\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(8);\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results, requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar onValue = __webpack_require__(40);\nvar $ref = __webpack_require__(0);\nvar FalcorJSON = __webpack_require__(21);\nvar onValueType = __webpack_require__(26);\nvar isExpired = __webpack_require__(1);\nvar originalOnMissing = __webpack_require__(25);\nvar getReferenceTarget = __webpack_require__(39);\nvar NullInPathError = __webpack_require__(6);\nvar InvalidKeySetError = __webpack_require__(31);\nvar getHashCode = __webpack_require__(19);\nvar flatBufferToPaths = __webpack_require__(18);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, json, path, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node || undefined !== (type = node.$type) || undefined === path) {\n        arr[1] = false;\n        arr[0] = onValueType(node, type, json, path, depth, seed, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing);\n        return arr;\n    }\n\n    var f_meta,\n        f_old_keys,\n        f_new_keys,\n        f_code = \"\";\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        keys = path[\"$keys\"],\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextJSON,\n        nextReferenceContainer,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\\u001ef_abs_path\"];\n    }\n\n    if (json) {\n        if (typeof json !== 'object') {\n            json = undefined;\n        } else if (f_meta = json[\"\\u001ef_metadata\"]) {\n            if (!branchSelector && !(json instanceof FalcorJSON)) {\n                json = { [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype };\n            } else if (f_meta[\"version\"] === node[\"\\u001ef_version\"] && f_meta[\"$code\"] === path[\"$code\"] && f_meta[\"abs_path\"] === node[\"\\u001ef_abs_path\"]) {\n                results.hasValue = true;\n                arr[0] = json;\n                arr[1] = false;\n                return arr;\n            }\n            f_old_keys = f_meta[\"keys\"];\n            f_meta[\"version\"] = node[\"\\u001ef_version\"];\n            f_meta[\"abs_path\"] = node[\"\\u001ef_abs_path\"];\n            f_meta[\"deref_to\"] = refContainerRefPath;\n            f_meta[\"deref_from\"] = refContainerAbsPath;\n        }\n    }\n\n    f_new_keys = {};\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath,\n        nextPathKey,\n        hasMissingPath = false,\n        nextMeta,\n        nextMetaPath;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n        nextMeta = undefined;\n        nextMetaPath = undefined;\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = \"\" + getHashCode(\"\" + f_code + \"null\");\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (\"object\" !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n                nextPathKey = nextKey;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                    nextPathKey = \"{from:\" + nextKey + \",length:\" + (rangeEnd - nextKey + 1) + \"}\";\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextPath !== undefined &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextReferenceContainer = refTarget[2];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n            }\n\n            // Continue following the path\n\n            arr = walkPathAndBuildOutput(cacheRoot, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n            nextJSON = arr[0];\n            hasMissingPath = hasMissingPath || arr[1];\n\n            if (!seed) {\n                continue;\n            }\n\n            // Inspect the return value from the step and determine whether to\n            // create or write into the JSON branch at this level.\n            //\n            // 1. If the next node was a leaf value, nextJSON is the value.\n            // 2. If the next node was a missing path, nextJSON is undefined.\n            // 3. If the next node was a branch, then nextJSON will either be an\n            //    Object or undefined. If nextJSON is undefined, all paths under\n            //    this step resolved to missing paths. If it's an Object, then\n            //    at least one path resolved to a successful leaf value.\n            //\n            // This check defers creating branches until we see at least one\n            // cache hit. Otherwise, don't waste the cycles creating a branch\n            // if everything underneath is a cache miss.\n\n            if (undefined !== nextJSON) {\n                // The json value will initially be undefined. If we're here,\n                // then at least one leaf value was encountered, so create a\n                // branch to contain it.\n                if (f_meta === undefined) {\n                    f_meta = {};\n                    f_meta[\"version\"] = node[\"\\u001ef_version\"];\n                    f_meta[\"abs_path\"] = node[\"\\u001ef_abs_path\"];\n                    f_meta[\"deref_to\"] = refContainerRefPath;\n                    f_meta[\"deref_from\"] = refContainerAbsPath;\n                    // Empower developers to instrument branch node creation by\n                    // providing a custom function. If they do, delegate branch\n                    // node creation to them.\n                    json = branchSelector && branchSelector({\n                        [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype }) || {\n                        [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype };\n                }\n\n                f_new_keys[nextKey] = true;\n                if (f_old_keys && f_old_keys.hasOwnProperty(nextKey)) {\n                    f_old_keys[nextKey] = false;\n                }\n                // Set the reported branch or leaf into this branch.\n                json[nextKey] = nextJSON;\n            } else {\n                hasMissingPath = true;\n                if (json && json.hasOwnProperty(nextKey)) {\n                    delete json[nextKey];\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        if (!hasMissingPath) {\n            if (undefined === nextPath) {\n                f_code = \"\" + getHashCode(\"\" + f_code + nextPathKey);\n            } else {\n                f_code = \"\" + getHashCode(\"\" + f_code + nextPathKey + nextPath[\"$code\"]);\n            }\n        }\n    }\n\n    if (hasMissingPath) {\n        f_code = \"__incomplete__\";\n    }\n\n    if (f_meta) {\n        f_meta[\"$code\"] = f_code;\n        f_meta[\"keys\"] = f_new_keys;\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, branchSelector) {\n\n    var suffix;\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n    var createMaterializedBranch = !branchSelector ? createDefaultMaterializedBranch : wrapMaterializedBranchSelector(branchSelector);\n\n    return paths.reduce(function (json, restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, createMaterializedBranch);\n    }, json);\n}\n\nfunction wrapMaterializedBranchSelector(branchSelector) {\n    return function (path, _depth, node) {\n        return branchSelector(node = createDefaultMaterializedBranch(path, _depth, node)) || node;\n    };\n}\n\nfunction createDefaultMaterializedBranch(path, _depth, node) {\n    f_meta = {};\n    f_meta[\"version\"] = 0;\n    f_meta[\"abs_path\"] = path.slice(0, _depth);\n    return { [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype };\n}\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar onValue = __webpack_require__(40);\nvar $ref = __webpack_require__(0);\nvar FalcorJSON = __webpack_require__(21);\nvar onValueType = __webpack_require__(26);\nvar isExpired = __webpack_require__(1);\nvar originalOnMissing = __webpack_require__(25);\nvar getReferenceTarget = __webpack_require__(39);\nvar NullInPathError = __webpack_require__(6);\nvar InvalidKeySetError = __webpack_require__(31);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var f_meta;\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        nextJSON,\n        nextReferenceContainer,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return json;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\\u001ef_abs_path\"];\n    }\n\n    if (json) {\n        if (typeof json !== 'object') {\n            json = undefined;\n        } else if (f_meta = json[\"\\u001ef_metadata\"]) {\n            f_meta[\"version\"] = node[\"\\u001ef_version\"];\n            f_meta[\"abs_path\"] = node[\"\\u001ef_abs_path\"];\n            f_meta[\"deref_to\"] = refContainerRefPath;\n            f_meta[\"deref_from\"] = refContainerAbsPath;\n        }\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextReferenceContainer = refTarget[2];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n            }\n\n            // Continue following the path\n\n            nextJSON = walkPathAndBuildOutput(cacheRoot, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n            // Inspect the return value from the step and determine whether to\n            // create or write into the JSON branch at this level.\n            //\n            // 1. If the next node was a leaf value, nextJSON is the value.\n            // 2. If the next node was a missing path, nextJSON is undefined.\n            // 3. If the next node was a branch, then nextJSON will either be an\n            //    Object or undefined. If nextJSON is undefined, all paths under\n            //    this step resolved to missing paths. If it's an Object, then\n            //    at least one path resolved to a successful leaf value.\n            //\n            // This check defers creating branches until we see at least one\n            // cache hit. Otherwise, don't waste the cycles creating a branch\n            // if everything underneath is a cache miss.\n\n            if (undefined !== nextJSON) {\n                // The json value will initially be undefined. If we're here,\n                // then at least one leaf value was encountered, so create a\n                // branch to contain it.\n                if (f_meta === undefined) {\n                    f_meta = {};\n                    f_meta[\"version\"] = node[\"\\u001ef_version\"];\n                    f_meta[\"abs_path\"] = node[\"\\u001ef_abs_path\"];\n                    f_meta[\"deref_to\"] = refContainerRefPath;\n                    f_meta[\"deref_from\"] = refContainerAbsPath;\n                    // Empower developers to instrument branch node creation by\n                    // providing a custom function. If they do, delegate branch\n                    // node creation to them.\n                    json = branchSelector && branchSelector({\n                        [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype }) || {\n                        [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype };\n                }\n\n                // Set the reported branch or leaf into this branch.\n                json[nextKey] = nextJSON;\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, branchSelector) {\n\n    var createMaterializedBranch = !branchSelector ? createDefaultMaterializedBranch : wrapMaterializedBranchSelector(branchSelector);\n\n    return originalOnMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized, createMaterializedBranch);\n}\n\nfunction wrapMaterializedBranchSelector(branchSelector) {\n    return function (path, _depth, node) {\n        return branchSelector(node = createDefaultMaterializedBranch(path, _depth, node)) || node;\n    };\n}\n\nfunction createDefaultMaterializedBranch(path, _depth, node) {\n    f_meta = {};\n    f_meta[\"version\"] = 0;\n    f_meta[\"abs_path\"] = path.slice(0, _depth);\n    return { [\"\\u001ef_metadata\"]: f_meta, __proto__: FalcorJSON.prototype };\n}\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar clone = __webpack_require__(8);\nvar $ref = __webpack_require__(0);\nvar inlineValue = __webpack_require__(24);\nvar promote = __webpack_require__(11);\nvar isExpired = __webpack_require__(1);\nvar createHardlink = __webpack_require__(5);\nvar CircularReferenceError = __webpack_require__(49);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, boxValues, materialized, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        followedRefsCount = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\\u001ef_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (false) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\"Followed \" + followedRefsCount + \" references. \" + \"This might indicate the presence of an indirect \" + \"circular reference chain.\");\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = typeof console.warn === \"function\" && console.warn || typeof console.log === \"function\" && console.log;\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(8);\nvar $ref = __webpack_require__(0);\nvar $error = __webpack_require__(14);\nvar inlineValue = __webpack_require__(24);\nvar materializedAtom = __webpack_require__(4);\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized) {\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            value = materializedAtom;\n        } else {\n            return undefined;\n        }\n    }\n    // boxValues always clones the node\n    else if (boxValues ||\n        /*\n         * JSON Graph should always clone errors, refs, atoms we didn't\n         * create, and atoms we created to wrap Object values.\n         */\n        $ref === type || $error === type || !node[\"\\u001ef_wrapped_value\"] || \"object\" === typeof value) {\n            value = clone(node);\n        }\n\n    if (seed) {\n        results.hasValue = true;\n        inlineValue(value, optimizedPath, optimizedLength, seed);\n        (seed.paths || (seed.paths = [])).push(requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n        );\n    }\n\n    return value;\n}\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar clone = __webpack_require__(8);\nvar $ref = __webpack_require__(0);\nvar onValue = __webpack_require__(74);\nvar inlineValue = __webpack_require__(24);\nvar onValueType = __webpack_require__(26);\nvar isExpired = __webpack_require__(1);\nvar originalOnMissing = __webpack_require__(25);\nvar getReferenceTarget = __webpack_require__(73);\nvar NullInPathError = __webpack_require__(6);\nvar InvalidKeySetError = __webpack_require__(31);\nvar materializedAtom = __webpack_require__(4);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, seed, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, undefined, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                keyset = keysOrRanges[keysetIndex];\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, seed, boxValues, materialized, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(cacheRoot, next, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, seed, reportMaterialized, branchSelector) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push((isLeaf = 0 === requestedLength - depth) &&\n        // depth + 1 if fromReference === true\n        requestedPath.slice(0, depth + !!fromReference) || requestedPath.slice(0, depth).concat(path.slice(depth, requestedLength + !!fromReference)));\n\n        json = inlineValue(isLeaf && materializedAtom || undefined, optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, json, reportMaterialized);\n}\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternalKey = __webpack_require__(101);\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    // only copy objects\n    if (!node || typeof node !== \"object\") {\n        return;\n    }\n\n    Object.keys(node).filter(function (k) {\n        // Its not an internal key and the node has a value.  In the cache\n        // there are 3 possibilities for values.\n        // 1: A branch node.\n        // 2: A $type-value node.\n        // 3: undefined\n        // We will strip out 3\n        return !isInternalKey(k) && node[k] !== undefined;\n    }).forEach(function (key) {\n        var cacheNext = node[key];\n        var outNext = out[key];\n\n        if (!outNext) {\n            outNext = out[key] = {};\n        }\n\n        // Paste the node into the out cache.\n        if (cacheNext.$type) {\n            var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n            var isUserCreatedcacheNext = !cacheNext[\"\\u001ef_wrapped_value\"];\n            var value;\n            if (isObject || isUserCreatedcacheNext) {\n                value = cloneBoxedValue(cacheNext);\n            } else {\n                value = cacheNext.value;\n            }\n\n            out[key] = value;\n            return;\n        }\n\n        _copyCache(cacheNext, outNext, key);\n    });\n}\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getBoundCacheNode = __webpack_require__(15);\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[\"\\u001ef_version\"];\n    return version == null ? -1 : version;\n};\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isPathValue = __webpack_require__(102);\nvar isJSONEnvelope = __webpack_require__(56);\nvar isJSONGraphEnvelope = __webpack_require__(57);\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = \"JSONGraphs\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar invalidatePathSets = __webpack_require__(27);\nvar invalidatePathMaps = __webpack_require__(43);\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    invalidatePathSets(model, args, expireImmediate);\n    return {};\n}\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(0);\nvar $error = __webpack_require__(14);\nvar getSize = __webpack_require__(7);\nvar getTimestamp = __webpack_require__(55);\n\nvar wrapNode = __webpack_require__(48);\nvar isExpired = __webpack_require__(1);\nvar insertNode = __webpack_require__(42);\nvar expireNode = __webpack_require__(3);\nvar replaceNode = __webpack_require__(46);\nvar reconstructPath = __webpack_require__(45);\nvar updateNodeAncestors = __webpack_require__(10);\n\nmodule.exports = function mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n\n    var cType, mType, cIsObject, mIsObject, cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n\n        // The message and cache are both undefined, return undefined.\n        else if (message === undefined) {\n                return message;\n            } else {\n                cIsObject = !(!node || typeof node !== 'object');\n                if (cIsObject) {\n                    // Is the cache node a branch? If so, return the cache branch.\n                    cType = node.$type;\n                    if (cType == null) {\n                        // Has the branch been introduced to the cache yet? If not,\n                        // give it a parent, key, and absolute path.\n                        if (node[\"\\u001ef_parent\"] == null) {\n                            insertNode(node, parent, key, version, optimizedPath);\n                        }\n                        return node;\n                    }\n                }\n            }\n    } else {\n        cIsObject = !(!node || typeof node !== 'object');\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || mIsObject && !mType) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n            // If the cache is a reference, but the message is empty, leave the cache alone...\n            if (message == null) {\n                // ...unless the cache is an expired reference. In that case, expire\n                // the cache node and return undefined.\n                if (isExpired(node, expireImmediate)) {\n                    expireNode(node, expired, lru);\n                    return void 0;\n                }\n                return node;\n            }\n            mIsObject = !(!message || typeof message !== 'object');\n            if (mIsObject) {\n                mType = message.$type;\n                // If the cache and the message are both references,\n                // check if we need to replace the cache reference.\n                if (mType === $ref) {\n                    if (node === message) {\n                        // If the cache and message are the same reference,\n                        // we performed a whole-branch merge of one of the\n                        // grandparents. If we've previously graphed this\n                        // reference, break early. Otherwise, continue to\n                        // leaf insertion below.\n                        if (node[\"\\u001ef_parent\"] != null) {\n                            return node;\n                        }\n                    } else {\n\n                        cTimestamp = node.$timestamp;\n                        mTimestamp = message.$timestamp;\n\n                        // - If either the cache or message reference is expired,\n                        //   replace the cache reference with the message.\n                        // - If neither of the references are expired, compare their\n                        //   timestamps. If either of them don't have a timestamp,\n                        //   or the message's timestamp is newer, replace the cache\n                        //   reference with the message reference.\n                        // - If the message reference is older than the cache\n                        //   reference, short-circuit.\n                        if (!isExpired(node, expireImmediate) && !isExpired(message, expireImmediate) && mTimestamp < cTimestamp) {\n                            return void 0;\n                        }\n                    }\n                }\n            }\n        }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n            // If the cache and the message are the same value, we branch-merged one\n            // of the message's ancestors. If this is the first time we've seen this\n            // leaf, give the message a $size and $type, attach its graph pointers,\n            // and update the cache sizes and versions.\n\n            if (mType === $error && errorSelector) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            if (mType && node === message) {\n                if (node[\"\\u001ef_parent\"] == null) {\n                    node = wrapNode(node, cType, node.value);\n                    parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                    node = insertNode(node, parent, key, version, optimizedPath);\n                }\n            }\n            // If the cache and message are different, the cache value is expired,\n            // or the message is a primitive, replace the cache with the message value.\n            // If the message is a sentinel, clone and maintain its type.\n            // If the message is a primitive value, wrap it in an atom.\n            else {\n                    var isDistinct = true;\n                    // If the cache is a branch, but the message is a leaf, replace the\n                    // cache branch with the message leaf.\n                    if (cType && !isExpired(node, expireImmediate) || !cIsObject) {\n                        // Compare the current cache value with the new value. If either of\n                        // them don't have a timestamp, or the message's timestamp is newer,\n                        // replace the cache value with the message value. If a comparator\n                        // is specified, the comparator takes precedence over timestamps.\n                        //\n                        // Comparing either Number or undefined to undefined always results in false.\n                        isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                        // If at least one of the cache/message are sentinels, compare them.\n                        if (isDistinct && (cType || mType) && comparator) {\n                            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                        }\n                    }\n                    if (isDistinct) {\n                        message = wrapNode(message, mType, mType ? message.value : message);\n                        sizeOffset = getSize(node) - getSize(message);\n                        node = replaceNode(node, message, parent, key, lru, version);\n                        parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                    }\n                }\n\n            // Promote the message edge in the LRU.\n            if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n                expireNode(node, expired, lru);\n            }\n        } else if (node == null) {\n            node = insertNode(message, parent, key, undefined, optimizedPath);\n        }\n\n    return node;\n};\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(22);\nvar getJSONGraph = __webpack_require__(23);\nvar arrayFlatMap = __webpack_require__(96);\nvar groupCacheArguments = __webpack_require__(78);\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: __webpack_require__(17),\n    setPathValues: __webpack_require__(30),\n    setJSONGraphs: __webpack_require__(16)\n};\n\nfunction json(model, args, data, progressive, expireImmediate) {\n    args = groupCacheArguments(args);\n    var set = setGroupsIntoCache(model, args /*, expireImmediate */);\n    var get = progressive && getJSON(model, set.relative, data, progressive, expireImmediate);\n    var jsong = getJSONGraph({\n        _root: model._root, _boxed: model._boxed, _materialized: true,\n        _treatErrorsAsValues: model._treatErrorsAsValues\n    }, set.optimized, {}, progressive, expireImmediate);\n    return {\n        args: args,\n        data: data,\n        fragments: jsong.data,\n        missing: set.optimized,\n        relative: set.relative,\n        error: get && get.error,\n        errors: get && get.errors,\n        requested: jsong.requested,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, args, data, progressive, expireImmediate) {\n    args = groupCacheArguments(args);\n    var set = setGroupsIntoCache(model, args /*, expireImmediate */);\n    var jsong = getJSONGraph({\n        _root: model._root,\n        _boxed: model._boxed, _materialized: true,\n        _treatErrorsAsValues: model._treatErrorsAsValues\n    }, set.optimized, data, progressive, expireImmediate);\n    return {\n        args: args,\n        data: data,\n        error: jsong.error,\n        fragments: jsong.data,\n        missing: set.optimized,\n        relative: set.relative,\n        hasValue: jsong.hasValue,\n        requested: jsong.requested\n    };\n}\n\nfunction setGroupsIntoCache(model, xs /*, expireImmediate */) {\n\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var selector = modelRoot.errorSelector;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports[\"set\" + inputType];\n            var resultPaths = operation(model, groupedArgs, selector, null, false);\n            optimizedPaths.push.apply(optimizedPaths, resultPaths[1]);\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === \"JSONGraphs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, resultPaths[0]);\n            }\n        }\n    }\n\n    return { optimized: optimizedPaths, relative: requestedPaths };\n};\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[\"\\u001ef_refs_length\"] || 0,\n        destNodeRefsLength = destNode[\"\\u001ef_refs_length\"] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[\"\\u001ef_ref\" + i];\n        if (ref !== void 0) {\n            ref[\"\\u001ef_context\"] = destNode;\n            destNode[\"\\u001ef_ref\" + (destNodeRefsLength + i)] = ref;\n            fromNode[\"\\u001ef_ref\" + i] = void 0;\n        }\n    }\n    destNode[\"\\u001ef_refs_length\"] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[\"\\u001ef_refs_length\"] = void 0;\n    return destNode;\n};\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function unlinkBackReferences(node) {\n    var i = -1,\n        n = node[\"\\u001ef_refs_length\"] || 0;\n    while (++i < n) {\n        var ref = node[\"\\u001ef_ref\" + i];\n        if (ref != null) {\n            ref[\"\\u001ef_context\"] = ref[\"\\u001ef_ref_index\"] = node[\"\\u001ef_ref\" + i] = void 0;\n        }\n    }\n    node[\"\\u001ef_refs_length\"] = void 0;\n    return node;\n};\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function unlinkForwardReference(reference) {\n    var destination = reference[\"\\u001ef_context\"];\n    if (destination) {\n        var i = (reference[\"\\u001ef_ref_index\"] || 0) - 1,\n            n = (destination[\"\\u001ef_refs_length\"] || 0) - 1;\n        while (++i <= n) {\n            destination[\"\\u001ef_ref\" + i] = destination[\"\\u001ef_ref\" + (i + 1)];\n        }\n        destination[\"\\u001ef_refs_length\"] = n;\n        reference[\"\\u001ef_ref_index\"] = reference[\"\\u001ef_context\"] = destination = void 0;\n    }\n    return reference;\n};\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[\"\\u001ef_parent\"] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[\"\\u001ef_invalidated\"]) {\n        return false;\n    }\n\n    return true;\n}\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar CONTAINER_DOES_NOT_EXIST = \"e\";\nvar $ref = __webpack_require__(0);\nvar getCachePosition = __webpack_require__(9);\nvar InvalidDerefInputError = __webpack_require__(88);\n\nmodule.exports = function deref(boundJSONArg) {\n\n    if (!boundJSONArg || typeof boundJSONArg !== 'object') {\n        throw new InvalidDerefInputError();\n    }\n\n    var referenceContainer, currentRefPath, i, len;\n    var jsonMetadata = boundJSONArg && boundJSONArg[\"\\u001ef_metadata\"];\n\n    if (!jsonMetadata || typeof jsonMetadata !== 'object') {\n        return this._clone({\n            _node: undefined\n        });\n    }\n\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = jsonMetadata[\"abs_path\"];\n\n    if (!absolutePath) {\n        return this._clone({\n            _node: undefined,\n            _seed: recycleJSON && { json: boundJSONArg } || undefined\n        });\n    } else if (absolutePath.length === 0) {\n        return this._clone({\n            _path: absolutePath,\n            _node: this._root.cache,\n            _referenceContainer: true,\n            _seed: recycleJSON && { json: boundJSONArg } || undefined\n        });\n    }\n\n    var originalRefPath = jsonMetadata[\"deref_to\"];\n    var originalAbsPath = jsonMetadata[\"deref_from\"];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheRoot = this._root.cache;\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n            i = 0;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n\n            validContainer = true;\n            for (; validContainer && i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    validContainer = false;\n                }\n            }\n            if (validContainer === false) {\n                cacheNode = undefined;\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n            referenceContainer = true;\n        }\n\n    return this._clone({\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer,\n        _seed: recycleJSON && { json: boundJSONArg } || undefined\n    });\n};\n\n/***/ },\n/* 87 */\n/***/ function(module, exports) {\n\nvar NAME = \"BoundJSONGraphModelError\";\nvar MESSAGE = \"It is not legal to use the JSON Graph \" + \"format from a bound Model. JSON Graph format\" + \" can only be used from a root model.\";\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = this.name;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nBoundJSONGraphModelError.prototype = Object.create(Error.prototype);\nBoundJSONGraphModelError.prototype.name = NAME;\nBoundJSONGraphModelError.message = MESSAGE;\n\nmodule.exports = BoundJSONGraphModelError;\n\n/***/ },\n/* 88 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidDerefInputError\";\nvar MESSAGE = \"Deref can only be used with a non-primitive object from get, set, or call.\";\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidDerefInputError() {\n  var err = Error.call(this, MESSAGE);\n  err.name = NAME;\n  this.stack = err.stack;\n  this.message = err.message;\n  return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidDerefInputError.prototype = Object.create(Error.prototype);\nInvalidDerefInputError.prototype.name = NAME;\nInvalidDerefInputError.message = MESSAGE;\n\nmodule.exports = InvalidDerefInputError;\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidModelError\";\nvar MESSAGE = \"The boundPath of the model is not valid since a value or error was found before the path end.\";\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidModelError(boundPath, shortedPath) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidModelError.prototype = Object.create(Error.prototype);\nInvalidModelError.prototype.name = NAME;\nInvalidModelError.message = MESSAGE;\n\nmodule.exports = InvalidModelError;\n\n/***/ },\n/* 90 */\n/***/ function(module, exports) {\n\nvar NAME = \"MaxRetryExceededError\";\nvar MESSAGE = \"The allowed number of retries have been exceeded.\";\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nfunction MaxRetryExceededError(maxRetryCount, absolute, relative, optimized) {\n    var err = Error.call(this, \"Exceeded the max retry count (\" + maxRetryCount + \") for these paths: \\n\" + (absolute && \"absolute: [\\n\\t\" + printPaths(absolute) + \"\\n]\\n\" || \"\") + (relative && \"relative: [\\n\\t\" + printPaths(relative) + \"\\n]\\n\" || \"\") + (optimized && \"optimized: [\\n\\t\" + printPaths(optimized) + \"\\n]\\n\" || \"\"));\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nMaxRetryExceededError.prototype = Object.create(Error.prototype);\nMaxRetryExceededError.prototype.name = NAME;\nMaxRetryExceededError.is = function (e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = MaxRetryExceededError;\n\nfunction printPaths(paths) {\n    return paths.map(function (path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(53);\nvar Subscriber = __webpack_require__(12);\nvar lruCollect = __webpack_require__(51);\nvar collapse = __webpack_require__(61);\nvar InvalidSourceError = __webpack_require__(50);\nvar MaxRetryExceededError = __webpack_require__(90);\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function (operator, source) {\n    source = new Call(source || this);\n    source.operator = operator;\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    return source;\n};\n\nCall.prototype.operator = function (subscriber) {\n    return this._subscribe(subscriber);\n};\n\nCall.prototype._subscribe = function (subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n};\n\nCall.prototype._toJSON = function (data, errors) {\n    return this.lift(new CallOperator(this.operator.data || data, this.operator.errors || errors, 'json', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype._toJSONG = function (data, errors) {\n    return this.lift(new CallOperator(this.operator.data || data, this.operator.errors || errors, 'jsonGraph', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype.retry = function (maxRetryCount) {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, this.operator.progresive, maxRetryCount), this.source);\n};\n\nCall.prototype.progressively = function () {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, true, this.operator.maxRetryCount), this.source);\n};\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    if (data === undefined) {\n        data = {};\n    }\n    if (errors === undefined) {\n        errors = [];\n    }\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function (source, destination) {\n    return source.subscribe(new CallSubscriber(destination, this.data, this.errors, this.operation, this.progressive));\n};\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.hasValue = false;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: __webpack_require__(69),\n    set: __webpack_require__(81),\n    call: __webpack_require__(68),\n    invalidate: __webpack_require__(79)\n};\n\nCallSubscriber.prototype.next = CallSubscriber.prototype.onNext = function (seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n\n    var seedIsImmutable = progressive && data && !model._recycleJSON;\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type][operation](model, args, data, progressive || !model._source, this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            throw results.error;\n        }\n\n        errors && results.errors && errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args; // || this.args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n};\n\nCallSubscriber.prototype.error = CallSubscriber.prototype.onError = function (error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n};\n\nCallSubscriber.prototype.complete = CallSubscriber.prototype.onCompleted = function (error) {\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && ((data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return Subscriber.prototype.onError.call(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return Subscriber.prototype.onError.call(this, new MaxRetryExceededError(this.retryCount, this.requested, this.relative, this.missing));\n    }\n\n    this.request = this.model._root.requests[this.type](this.model, this.missing, this.relative, this.fragments).subscribe(this);\n};\n\nCallSubscriber.prototype.dispose = CallSubscriber.prototype.unsubscribe = function () {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 && version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot, modelRoot.expired, cache.$size || 0, modelRoot.maxSize, modelRoot.collectRatio, modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n};\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch (e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue,\n        nodeValue,\n        key,\n        keys = Object.keys(node),\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === \"\\u001ef_metadata\") {\n            dest[\"\\u001ef_metadata\"] = node[\"\\u001ef_metadata\"];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (destValue === undefined || \"object\" !== typeof nodeValue) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(53);\nvar Request = __webpack_require__(93);\nvar Subscriber = __webpack_require__(12);\nvar Subscription = __webpack_require__(13);\nvar ImmediateScheduler = __webpack_require__(54);\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler()).batch(requested, optimized || env.paths, env.jsonGraph);\n\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request.connect());\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler()).batch(null, null, env);\n\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request.connect());\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(this, model._source, model._scheduler, requested, optimized);\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function (destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] = new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n};\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subject = __webpack_require__(94);\nvar $error = __webpack_require__(14);\nvar Subscriber = __webpack_require__(12);\nvar Subscription = __webpack_require__(13);\nvar InvalidSourceError = __webpack_require__(50);\n\nvar toPaths = __webpack_require__(36);\nvar toCollapseMap = __webpack_require__(34);\nvar toCollapseTrees = __webpack_require__(35);\nvar hasIntersection = __webpack_require__(63);\n\nvar setJSONGraphs = __webpack_require__(16);\nvar setPathValues = __webpack_require__(30);\nvar invalidatePaths = __webpack_require__(27);\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.tree = {};\n    this.paths = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next = Request.prototype.onNext = function (env) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    this.responded = true;\n\n    var jsonGraph = env.jsonGraph;\n    var requested = this.requested;\n    var modelRoot = queue.modelRoot;\n    var invalidated = env.invalidated;\n    var paths = env.paths || this.paths;\n\n    // Run invalidations first.\n    if (invalidated && invalidated.length) {\n        invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n    }\n\n    if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n        setJSONGraphs({ _root: modelRoot }, [{ paths: paths, jsonGraph: jsonGraph }], modelRoot.errorSelector, modelRoot.comparator, false);\n    }\n\n    this.observers.slice(0).forEach(function (observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] || paths\n        });\n    });\n};\n\nRequest.prototype.error = Request.prototype.onError = function (error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    this.responded = true;\n\n    error = error || {};\n\n    // Converts errors to objects, a more friendly storage\n    // of errors.\n    error = !(error instanceof Error) ?\n    // if it's $type error, use it raw\n    error.$type === $error && error ||\n    // Otherwise make it an error\n    { $type: $error, value: error } :\n    // If it's instanceof Error, pluck error.message\n    { $type: $error, value: { message: error.message } };\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(this.requested.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {}))).map(function (path) {\n        return { path: path, value: error };\n    });\n\n    if (errorPathValues.length) {\n        setPathValues({ _root: modelRoot, _path: [] }, errorPathValues, modelRoot.errorSelector, modelRoot.comparator, false);\n    }\n\n    Subject.prototype.onError.call(this, error);\n};\n\nRequest.prototype.complete = Request.prototype.onCompleted = function () {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n};\n\nRequest.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n};\n\nRequest.prototype.dispose = Request.prototype.unsubscribe = function () {\n    this.tree = {};\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n};\n\nRequest.prototype.connect = function () {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n};\n\nRequest.prototype.batch = function (requested, optimized, requestedComplements, optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.tree, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            return this;\n        }\n        return null;\n    }\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    this.data = requestedComplements;\n    return this;\n};\n\nfunction flush() {\n\n    this.active = true;\n\n    var obs,\n        paths = this.paths = toPaths(this.tree = toCollapseTrees(this.optimized.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {})));\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = null;\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\n\nfunction findIntersections(tree, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = 0;\n    var intersectionIndex = 0;\n    var total = optimized.length;\n    var intersectionFound = false;\n\n    while (++index < total) {\n        // If this does not intersect then add it to the output.\n        var path = optimized[index];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n\n        // If there is no subtree to look into or there is no intersection.\n        if (!subTree || !hasIntersection(subTree, path, 0, pathLen)) {\n            if (intersectionFound) {\n                requestedComplements[complementIndex] = requested[index];\n                optimizedComplements[complementIndex++] = path;\n            }\n        } else {\n            // If there has been no intersection yet and index is larger than 0\n            // (meaning we have had only complements), then we need to update\n            // our complements to match the current reality.\n            if (!intersectionFound) {\n                while (complementIndex < index) {\n                    requestedComplements[complementIndex] = requested[complementIndex];\n                    optimizedComplements[complementIndex] = optimized[complementIndex++];\n                }\n            }\n\n            intersectionFound = true;\n            requestedIntersection[intersectionIndex] = requested[index];\n            optimizedIntersection[intersectionIndex++] = optimized[index];\n        }\n    }\n\n    return intersectionFound;\n}\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscriber = __webpack_require__(12);\nvar Subscription = __webpack_require__(13);\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\nSubject.prototype.onNext = function (value) {\n    this.observers.slice(0).forEach(function (observer) {\n        observer.onNext(value);\n    });\n};\n\nSubject.prototype.onError = function (error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onError(error);\n    });\n};\n\nSubject.prototype.onCompleted = function () {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onCompleted();\n    });\n};\n\nSubject.prototype.subscribe = function (subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n};\n\nSubject.prototype.dispose = Subject.prototype.unsubscribe = function () {\n    this.observers = [];\n};\n\n/***/ },\n/* 95 */\n/***/ function(module, exports) {\n\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose = TimerDisposable.prototype.unsubscribe = function () {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\nmodule.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (key.charAt(0) === \"\\u001e\") {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(2);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(2);\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(2);\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (obj, prop) {\n  return isObject(obj) && hasOwn.call(obj, prop);\n};\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nmodule.exports = function isInternalKey(x) {\n  return x === \"$size\" || x === \"\\u001ef_wrapped_value\" || x.charAt(0) === \"\\u001e\";\n};\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(2);\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (isArray(pathValue.path) || typeof pathValue.path === \"string\");\n};\n\n/***/ },\n/* 103 */\n/***/ function(module, exports) {\n\nmodule.exports = \"atom\";\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(105);\n\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = __webpack_require__(106);\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33), __webpack_require__(107)(module)))\n\n/***/ },\n/* 106 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n/***/ },\n/* 107 */\n/***/ function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(60);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// falcor.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 108);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 230706e40c862c749bcd","module.exports = \"ref\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/types/ref.js","var now = require(\"../support/now\");\nvar $now = require(\"../values/expires-now\");\nvar $never = require(\"../values/expires-never\");\n\nmodule.exports = function isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/isExpired.js","var objTypeof = \"object\";\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isObject.js","var splice = require(\"./../lru/splice\");\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[ƒ_invalidated]) {\n        node[ƒ_invalidated] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/expireNode.js","module.exports = { $type: 'atom' };\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/support/materializedAtom.js","module.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[ƒ_refs_length] || 0;\n    to[ƒ_ref + backRefs] = from;\n    to[ƒ_refs_length] = backRefs + 1;\n\n    // create a hard reference\n    from[ƒ_ref_index] = backRefs;\n    from[ƒ_context] = to;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/createHardlink.js","var NAME = \"NullInPathError\";\nvar MESSAGE = \"`null` is not allowed in branch key positions.\";\n\n/**\n * Does not allow null in path\n */\nfunction NullInPathError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nNullInPathError.prototype = Object.create(Error.prototype);\nNullInPathError.prototype.name = NAME;\nNullInPathError.message = MESSAGE;\n\nmodule.exports = NullInPathError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NullInPathError.js","var isObject = require(\"./../support/isObject\");\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getSize.js","module.exports = clone;\n\nfunction clone(node) {\n\n    var key, keys = Object.keys(node),\n        json = {}, index = -1, length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (key.charAt(0) === ƒ_) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/clone.js","var $ref = require(\"./../types/ref\");\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type, depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === $ref) {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCachePosition.js","var removeNode = require(\"./removeNode\");\nvar updateBackReferenceVersions = require(\"./updateBackReferenceVersions\");\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child[ƒ_parent];\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child[ƒ_key], lru);\n        } else if (child[ƒ_version] !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateNodeAncestors.js","var EXPIRES_NEVER = require(\"./../values/expires-never\");\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root[ƒ_head];\n\n    // Nothing is in the cache.\n    if (!head) {\n        root[ƒ_head] = root[ƒ_tail] = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[ƒ_prev];\n    var next = object[ƒ_next];\n    if (next) {\n        next[ƒ_prev] = prev;\n    }\n    if (prev) {\n        prev[ƒ_next] = next;\n    }\n    object[ƒ_prev] = undefined;\n\n    // Insert into head position\n    root[ƒ_head] = object;\n    object[ƒ_next] = head;\n    head[ƒ_prev] = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root[ƒ_tail]) {\n        root[ƒ_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/promote.js","var Subscription = require('./Subscription');\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' ||\n             typeof parent === 'function' ||\n        typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        }\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next =\nSubscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n}\n\nSubscriber.prototype.error =\nSubscriber.prototype.onError = function onError(error) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            dest.onError(error);\n        } else if (dest.error) {\n            dest.error(error);\n        }\n        this.dispose();\n    } else {\n        this.dispose();\n        throw error;\n    }\n}\n\nSubscriber.prototype.complete =\nSubscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n}\n\nSubscriber.prototype.dispose =\nSubscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscriber.js","module.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function(subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n}\n\nSubscription.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n}\n\nSubscription.prototype.dispose =\nSubscription.prototype.unsubscribe = function () {\n    var subscription, subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) &&\n            subscription.dispose &&\n            subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscription.js","module.exports = \"error\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/types/error.js","var getCachePosition = require(\"./getCachePosition\");\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[ƒ_parent] === undefined || node[ƒ_invalidated]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getBoundCacheNode.js","var arr = new Array(5);\nvar $ref = require(\"../../types/ref\");\nvar isExpired = require(\"../isExpired\");\nvar expireNode = require(\"../expireNode\");\nvar createHardlink = require(\"../createHardlink\");\nvar mergeJSONGraphNode = require(\"../mergeJSONGraphNode\");\nvar NullInPathError = require(\"../../errors/NullInPathError\");\nvar iterateKeySet = require(\"@graphistry/falcor-path-utils/lib/iterateKeySet\");\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var initialVersion = cache[ƒ_version];\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, expireImmediate\n            );\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    var newVersion = cache[ƒ_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(\n                root, parent, node, messageRoot, messageParent, message,\n                key, branch, true, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n            node = results[0];\n            optimizedPath = results[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[ƒ_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[ƒ_key];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(\n            parent, node, message, key, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setJSONGraphs.js","var arr = new Array(3);\nvar isArray = Array.isArray;\nvar $ref = require(\"../../types/ref\");\nvar isExpired = require(\"../isExpired\");\nvar expireNode = require(\"../expireNode\");\nvar createHardlink = require(\"../createHardlink\");\nvar getCachePosition = require(\"../getCachePosition\");\nvar NullInPathError = require(\"../../errors/NullInPathError\");\nvar mergeValueOrInsertBranch = require(\"../mergeValueOrInsertBranch\");\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n    var parent = node[ƒ_parent] || cache;\n    var initialVersion = cache[ƒ_version];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[ƒ_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                        version, expired, lru, comparator, errorSelector, expireImmediate\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[ƒ_context];\n\n        if (node != null) {\n            parent = node[ƒ_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[ƒ_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (type === void 0) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[ƒ_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === ƒ_ || key[0] === \"$\") {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathMaps.js","module.exports = flatBufferToPaths;\n\nfunction flatBufferToPaths(flatBuf, paths, path) {\n\n    path = path || [];\n    paths = paths || [];\n\n    var leaf = [];\n    var keys = flatBuf['$keys'];\n    var keysLen = keys.length;\n    var keysIndex = -1, key, len;\n\n    while (++keysIndex < keysLen) {\n\n        var rest = flatBuf[keysIndex];\n        var keyset = keys[keysIndex];\n\n        if (!rest) {\n            leaf.push(keyset);\n        } else {\n            flatBufferToPaths(rest, paths, path.concat([keyset]));\n        }\n    }\n\n    if (leaf.length === 1) {\n        paths.push(path.concat(leaf));\n    } else if (leaf.length > 1) {\n        paths.push(path.concat([leaf]));\n    }\n\n    return paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/flatBufferToPaths.js","module.exports = getHashCode;\n\nfunction getHashCode(str) {\n    var hash = 5381, i = str.length;\n    while (i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/getHashCode.js","var isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/iterateKeySet.js","function FalcorJSON(f_meta) {\n    this[ƒ_meta] = f_meta || {};\n}\n\nFalcorJSON.prototype = Object.create(Object.prototype, Object.assign({\n        toJSON: { value: toJSON },\n        toProps: { value: toProps },\n        serialize: { value: serialize },\n        $__hash: {\n            enumerable: false,\n            get() {\n                var f_meta = this[ƒ_meta];\n                return f_meta && f_meta[\"$code\"] || '';\n            }\n        },\n        $__version: {\n            enumerable: false,\n            get() {\n                var f_meta = this[ƒ_meta];\n                return f_meta && f_meta[ƒm_version] || 0;\n            }\n        }\n    },\n    arrayProtoMethods().reduce((falcorJSONProto, methodName) => {\n        var method = Array.prototype[methodName];\n        falcorJSONProto[methodName] = {\n            writable: true, enumerable: false, value() {\n                return method.apply(this, arguments);\n            }\n        };\n        return falcorJSONProto;\n    }, {}))\n);\n\nfunction arrayProtoMethods() {\n    return [\n        'concat', 'copyWithin', 'entries', 'every', 'fill', 'filter', 'find',\n        'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'keys',\n        'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight',\n        'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'unshift', 'values'\n    ];\n}\n\nvar isArray = Array.isArray;\nvar typeofObject = 'object';\nvar typeofString = 'string';\n\nfunction toJSON(inst) {\n    if (typeof inst === typeofString) {\n        if (arguments.length !== 1) {\n            return inst;\n        }\n        inst = this;\n    } else if (!inst) {\n        inst = this;\n    } else if (inst === global) {\n        return undefined;\n    }\n    var json = serialize(inst, toJSON);\n    if (json[ƒ_meta]) {\n        delete json[ƒ_meta];\n    }\n    return json;\n}\n\nfunction toProps(inst, serializer) {\n    var argsLen = arguments.length;\n    inst = argsLen === 0 ? this : inst;\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    } else if (inst === global) {\n        return {};\n    }\n    var json = serialize(inst, argsLen > 0 && serializer || toProps);\n    var f_meta = json[ƒ_meta];\n    if (f_meta) {\n        delete json[ƒ_meta];\n        f_meta[ƒm_version] = inst[ƒ_meta][ƒm_version];\n        json.__proto__ = new FalcorJSON(f_meta);\n    }\n    return json;\n}\n\nfunction serialize(inst, serializer) {\n\n    var argsLen = arguments.length;\n    inst = argsLen === 0 ? this : inst;\n\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    } else if (inst === global) {\n        return {};\n    }\n\n    var count, total, f_meta, keys, key, xs;\n\n    serializer = argsLen > 0 && serializer || serialize;\n\n    if (isArray(inst)) {\n        count = -1;\n        total = inst.length;\n        xs = new Array(total);\n        while (++count < total) {\n            xs[count] = inst[count];\n        }\n    } else {\n        xs = {};\n        count = -1;\n        f_meta = inst[ƒ_meta];\n        keys = Object.keys(inst);\n        total = keys.length;\n        if (f_meta) {\n            var $code = f_meta[\"$code\"],\n                fm_abs_path = f_meta[ƒm_abs_path],\n                fm_deref_to = f_meta[ƒm_deref_to],\n                fm_deref_from = f_meta[ƒm_deref_from];\n            xs[ƒ_meta] = f_meta = {};\n            $code && (f_meta[\"$code\"] = $code);\n            fm_abs_path && (f_meta[ƒm_abs_path] = fm_abs_path);\n            fm_deref_to && (f_meta[ƒm_deref_to] = fm_deref_to);\n            fm_deref_from && (f_meta[ƒm_deref_from] = fm_deref_from);\n        }\n        while (++count < total) {\n            key = keys[count]\n            if (key !== ƒ_meta) {\n                xs[key] = serializer(inst[key], serializer);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/FalcorJSON.js","module.exports = require('./getJSON');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/index.js","module.exports = require('./getJSONGraph');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/index.js","module.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key, depth = 0, prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/inlineValue.js","var isArray = Array.isArray;\nvar pathToTree = require('@graphistry/falcor-path-utils/lib/toTree').pathToTree;\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   json, reportMaterialized, createMaterializedBranch) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        if (restPathCount === 0) {\n            return materializedAtom;\n        }\n        return pathToTree(json, mPath, missDepth, missTotal,\n                          materializedAtom, createMaterializedBranch);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if (\"object\" !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if (\"number\" !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMissing.js","var isExpired = require(\"../isExpired\");\nvar expireNode = require(\"../expireNode\");\nvar lruPromote = require(\"../../lru/promote\");\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json,\n                     path, depth, seed, results,\n                     requestedPath, requestedLength,\n                     optimizedPath, optimizedLength,\n                     fromReference, modelRoot, expired, expireImmediate,\n                     branchSelector, boxValues, materialized, reportMissing,\n                     treatErrorsAsValues, onValue, onMissing) {\n\n    var reportMaterialized = materialized;\n\n    if (!node || !type) {\n        if (materialized) {\n            reportMaterialized = true;\n            seed && (results.hasValue = true);\n        }\n        return onMissing(path, depth, results,\n                         requestedPath, requestedLength, fromReference,\n                         optimizedPath, optimizedLength, reportMissing,\n                         json, reportMaterialized, branchSelector);\n    } else if (isExpired(node, expireImmediate)) {\n        if (!node[ƒ_invalidated]) {\n            expireNode(node, expired, modelRoot);\n        }\n        return onMissing(path, depth, results,\n                         requestedPath, requestedLength, fromReference,\n                         optimizedPath, optimizedLength, reportMissing,\n                         json, reportMaterialized, branchSelector);\n    }\n\n    lruPromote(modelRoot, node);\n\n    if (seed) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n        }\n        return onValue(node, type, depth, seed, results,\n                       requestedPath, optimizedPath, optimizedLength,\n                       fromReference, boxValues, materialized, treatErrorsAsValues);\n    }\n\n    return undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onValueType.js","var arr = new Array(2);\nvar $ref = require(\"../../types/ref\");\n\nvar getBoundCacheNode = require(\"../getBoundCacheNode\");\n\nvar isExpired = require(\"../isExpired\");\nvar expireNode = require(\"../expireNode\");\nvar lruPromote = require(\"../../lru/promote\");\nvar getSize = require(\"../../support/getSize\");\nvar createHardlink = require(\"../createHardlink\");\nvar iterateKeySet = require(\"@graphistry/falcor-path-utils/lib/iterateKeySet\");\nvar updateNodeAncestors = require(\"../updateNodeAncestors\");\nvar removeNodeAndDescendants = require(\"../removeNodeAndDescendants\");\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node[ƒ_parent] || cache;\n    var initialVersion = cache[ƒ_version];\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    var newVersion = cache[ƒ_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        arr = invalidateNode(\n            root, parent, node,\n            key, branch, false, version,\n            expired, lru, expireImmediate\n        );\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru, expireImmediate\n                );\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[ƒ_context];\n\n    if (node != null) {\n        parent = node[ƒ_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(\n                root, parent, node,\n                key, branch, true, version,\n                expired, lru, expireImmediate\n            );\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[ƒ_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, branch, reference, version,\n    expired, lru, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        arr = invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[ƒ_key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathSets.js","var $ref = require(\"../types/ref\");\nvar lruSplice = require(\"../lru/splice\");\nvar unlinkBackReferences = require(\"./unlinkBackReferences\");\nvar unlinkForwardReference = require(\"./unlinkForwardReference\");\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node[ƒ_parent] = void 0;\n        return true;\n    }\n    return false;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/removeNode.js","var removeNode = require(\"./removeNode\");\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (key2[0] !== ƒ_ && key2[0] !== \"$\") {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/removeNodeAndDescendants.js","var arr = new Array(3);\nvar $ref = require(\"../../types/ref\");\nvar isExpired = require(\"../isExpired\");\nvar expireNode = require(\"../expireNode\");\nvar createHardlink = require(\"../createHardlink\");\nvar getCachePosition = require(\"../getCachePosition\");\nvar NullInPathError = require(\"../../errors/NullInPathError\");\nvar iterateKeySet = require(\"@graphistry/falcor-path-utils/lib/iterateKeySet\");\nvar mergeValueOrInsertBranch = require(\"../mergeValueOrInsertBranch\");\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n    var parent = node[ƒ_parent] || cache;\n    var initialVersion = cache[ƒ_version];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache[ƒ_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[ƒ_context];\n\n        if (node != null) {\n            parent = node[ƒ_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[ƒ_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[ƒ_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathValues.js","var NAME = \"InvalidKeySetError\";\nvar MESSAGE = \"Keysets can only contain Keys or Ranges\";\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidKeySetError(path, keysOrRanges) {\n    var err = Error.call(this,\n        \"The KeySet \" + JSON.stringify(keysOrRanges) +\n        \" in path \" + JSON.stringify(path) + \" contains a KeySet. \" + MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidKeySetError.prototype = Object.create(Error.prototype);\nInvalidKeySetError.prototype.name = NAME;\nInvalidKeySetError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidKeySetError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidKeySetError.js","module.exports = 0;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-now.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 33\n// module chunks = 0","var isArray = Array.isArray;\nvar flatBufferToPaths = require('./flatBufferToPaths');\n\nmodule.exports = toCollapseMap;\n\nfunction toCollapseMap(paths, collapseMap) {\n    if (!paths) { return collapseMap; }\n    else if (!isArray(paths)) {\n        if (isArray(paths.$keys)) {\n            paths = flatBufferToPaths(paths);\n        }\n    }\n    return paths.reduce(function(acc, path) {\n        var len = path.length;\n        if (!acc[len]) {\n            acc[len] = [];\n        }\n        acc[len].push(path);\n        return acc;\n    }, collapseMap || {});\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toCollapseMap.js","var toTree = require('./toTree');\n\nmodule.exports = toCollapseTrees;\n\nfunction toCollapseTrees(collapseMap, collapseTrees) {\n    return Object.keys(collapseMap).reduce(function(collapseTrees, collapseKey) {\n        collapseTrees[collapseKey] = toTree(\n            collapseMap[collapseKey],\n            collapseTrees[collapseKey]\n        );\n        return collapseTrees;\n    }, collapseTrees || {});\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toCollapseTrees.js","var isArray = Array.isArray;\nvar typeOfObject = \"object\";\nvar typeOfString = \"string\";\nvar typeOfNumber = \"number\";\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\nvar getHashCode = require('./getHashCode');\nvar materializedAtom = require('./support/materializedAtom');\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var subs = Object.create(null);\n    var code = '' + getHashCode('' + depth);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = '' + getHashCode(code + key + subCode);\n\n            isSafeNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = '' + getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === materializedAtom) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\n// function getHashCode(key) {\n//     var code = 5381;\n//     var index = -1;\n//     var count = key.length;\n//     while (++index < count) {\n//         code = (code << 5) + code + key.charCodeAt(index);\n//     }\n//     return String(code);\n// }\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toPaths.js","var isArray = Array.isArray;\nvar materializedAtom = require('./support/materializedAtom');\n\nmodule.exports = toTree;\nmodule.exports.pathToTree = pathToTree;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\n\nfunction toTree(paths, seed) {\n    return paths.reduce(function(seed, path) {\n        return pathToTree(seed, path, 0, path.length, null);\n    }, seed || {});\n};\n\nfunction pathToTree(seed, path, depth, length, value, branch) {\n\n    if (depth === length) {\n        return true;//seed || value;\n    }\n\n    var seedKeySet, keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return materializedAtom;\n    }\n\n    seedKeySet = keyset;\n    seed = seed ? seed : branch ? branch(path, depth, seed) : {};\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = value;\n            } else {\n                node = seed[path[depth] = nextKey];\n                next = pathToTree(node, path, nextDepth, length, value);\n                // next = pathToTree(node ||\n                //     branch && branch(path, depth, seed) || {},\n                //     path, nextDepth, length, value);\n                if (!next) {\n                    seed[nextKey] = value;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    path[depth] = seedKeySet;\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toTree.js","var isArray = Array.isArray;\nvar walkPathAndBuildOutput = require(\"./walkPath\");\nvar walkFlatBufferAndBuildOutput = require(\"./walkFlatBuffer\");\nvar getBoundCacheNode = require(\"../../getBoundCacheNode\");\nvar InvalidModelError = require(\"../../../errors/InvalidModelError\");\nvar toFlatBuffer = require(\"@graphistry/falcor-path-utils/lib/toFlatBuffer\");\nvar computeFlatBufferHash = require(\"@graphistry/falcor-path-utils/lib/computeFlatBufferHash\");\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        results = { data: seed },\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    var arr, path, pathsIndex = 0, pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n        if (recycleJSON) {\n            pathsCount = 1;\n            isFlatBuffer = true;\n            if (!paths[0].$keys || paths.length > 1) {\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n            do {\n                path = paths[pathsIndex];\n                arr = walkFlatBufferAndBuildOutput(cache, node, json, path, 0, seed, results,\n                                                   requestedPath, optimizedPath, optimizedLength,\n                                                   /* fromReference = */ false, referenceContainer,\n                                                   modelRoot, expired, expireImmediate, branchSelector,\n                                                   boxValues, materialized, hasDataSource,\n                                                   treatErrorsAsValues, allowFromWhenceYouCame);\n                json = arr[0];\n                arr[0] = undefined;\n                arr[1] = undefined;\n            } while (++pathsIndex < pathsCount)\n        } else {\n            do {\n                path = paths[pathsIndex];\n                requestedLength = path.length;\n                json = walkPathAndBuildOutput(cache, node, json, path,\n                                           /* depth = */ 0, seed, results,\n                                              requestedPath, requestedLength,\n                                              optimizedPath, optimizedLength,\n                                              /* fromReference = */ false, referenceContainer,\n                                              modelRoot, expired, expireImmediate, branchSelector,\n                                              boxValues, materialized, hasDataSource,\n                                              treatErrorsAsValues, allowFromWhenceYouCame);\n            } while (++pathsIndex < pathsCount)\n        }\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;//requested;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getJSON.js","var arr = new Array(3);\nvar $ref = require(\"../../../types/ref\");\nvar promote = require(\"../../../lru/promote\");\nvar isExpired = require(\"../../isExpired\");\nvar createHardlink = require(\"../../createHardlink\");\nvar CircularReferenceError = require(\"../../../errors/CircularReferenceError\");\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        followedRefsCount = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[ƒ_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (DEBUG) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\n                                \"Followed \" + followedRefsCount + \" references. \" +\n                                \"This might indicate the presence of an indirect \" +\n                                \"circular reference chain.\"\n                            );\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = ((\n                                    typeof console.warn === \"function\" && console.warn) || (\n                                    typeof console.log === \"function\" && console.log));\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getReferenceTarget.js","var clone = require(\"../../clone\");\nvar onError = require(\"./onError\");\nvar $error = require(\"../../../types/error\");\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results,\n                     requestedPath, optimizedPath, optimizedLength,\n                     fromReference, boxValues, materialized,\n                     treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath,\n                       fromReference, boxValues);\n    }\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            debugger\n            results.hasValue = true;\n            return materializedAtom;\n        }\n        return undefined;\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    if (boxValues) {\n        return clone(node);\n    }\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onValue.js","var walkPathAndBuildOutput = require(\"./walkPath\");\nvar BoundJSONGraphModelError = require(\"../../../errors/BoundJSONGraphModelError\");\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node, cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n\n        results = { data: seed },\n        pathsIndex = -1, pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n                            /* depth = */ 0, seed, results,\n                               requestedPath, requestedLength,\n                               optimizedPath, optimizedLength,\n              /* fromReference = */ false, modelRoot, expired, expireImmediate,\n                               boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args =\n    results.relative = results.requested;\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getJSONGraph.js","module.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node[ƒ_key] = key;\n    node[ƒ_parent] = parent;\n\n    if (version !== undefined) {\n        node[ƒ_version] = version;\n    }\n    if (!node[ƒ_abs_path]) {\n        node[ƒ_abs_path] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/insertNode.js","var $ref = require(\"../../types/ref\");\nvar isExpired = require(\"../isExpired\");\nvar expireNode = require(\"../expireNode\");\nvar lruPromote = require(\"../../lru/promote\");\nvar getSize = require(\"../../support/getSize\");\nvar createHardlink = require(\"../createHardlink\");\nvar getBoundCacheNode = require(\"../getBoundCacheNode\");\nvar updateNodeAncestors = require(\"../updateNodeAncestors\");\nvar removeNodeAndDescendants = require(\"../removeNodeAndDescendants\");\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node[ƒ_parent] || cache;\n    var initialVersion = cache[ƒ_version];\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, expireImmediate\n        );\n    }\n\n    var newVersion = cache[ƒ_version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (rootChangeHandler && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(\n    pathMap, depth, root, parent, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (key[0] !== ƒ_ && key[0] !== \"$\") {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            var results = invalidateNode(\n                root, parent, node,\n                key, child, branch, false, version, expired,\n                lru, comparator, expireImmediate\n            );\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, expireImmediate\n                    );\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(\n    value, root, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[ƒ_context];\n\n    if (node != null) {\n        parent = node[ƒ_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, value, branch, true, version,\n                expired, lru, comparator, expireImmediate\n            );\n            node = results[0];\n            if (!node || typeof node !== 'object') {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container[ƒ_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, value, branch, reference, version,\n    expired, lru, comparator, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(\n            value, root, node, version, expired,\n            lru, comparator, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node && typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[ƒ_key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathMaps.js","var $ref = require(\"../types/ref\");\nvar $error = require(\"../types/error\");\nvar $now = require(\"../values/expires-now\");\nvar getType = require(\"../support/getType\");\nvar getSize = require(\"../support/getSize\");\nvar getTimestamp = require(\"../support/getTimestamp\");\n\nvar wrapNode = require(\"./wrapNode\");\nvar isExpired = require(\"./isExpired\");\nvar expireNode = require(\"./expireNode\");\nvar insertNode = require(\"./insertNode\");\nvar replaceNode = require(\"./replaceNode\");\nvar reconstructPath = require(\"./reconstructPath\");\nvar updateNodeAncestors = require(\"./updateNodeAncestors\");\n\nmodule.exports = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge if it expires immediately\n             */\n            true)) {\n            expireNode(node, expired, lru);\n            type = node.$expires === $now ? type : 'expired';\n        }\n        if ((type && type !== $ref) || (!node || typeof node !== 'object')) {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && comparator) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (errorSelector && mType === $error) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize(node) - getSize(message);\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeValueOrInsertBranch.js","/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/reconstructPath.js","var transferBackReferences = require(\"./transferBackReferences\");\nvar removeNodeAndDescendants = require(\"./removeNodeAndDescendants\");\nvar updateBackReferenceVersions = require(\"./updateBackReferenceVersions\");\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/replaceNode.js","module.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        if (node && node[ƒ_version] !== version) {\n            node[ƒ_version] = version;\n            stack[count++] = node[ƒ_parent];\n            var i = -1;\n            var n = node[ƒ_refs_length] || 0;\n            while (++i < n) {\n                stack[count++] = node[ƒ_ref + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateBackReferenceVersions.js","var isArray = Array.isArray;\nvar now = require(\"../support/now\");\nvar expiresNow = require(\"../values/expires-now\");\n\nvar $atom = require(\"../types/atom\");\nvar clone = require(\"./../support/clone\");\nvar getSize = require(\"./../support/getSize\");\nvar getExpires = require(\"../support/getExpires\");\n\nvar atomSize = 50;\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[ƒ_wrapped_value];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[ƒ_prev] = undefined;\n        node[ƒ_next] = undefined;\n        node[ƒ_wrapped_value] = modelCreated || false;\n    } else {\n        node = { $type: $atom, value: value };\n        node[ƒ_prev] = undefined;\n        node[ƒ_next] = undefined;\n        node[ƒ_wrapped_value] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/wrapNode.js","var NAME = \"CircularReferenceError\";\n\n/**\n * Does not allow null in path\n */\nfunction CircularReferenceError(referencePath) {\n    var err = Error.call(this, \"Encountered circular reference \" +\n        JSON.stringify(referencePath));\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nCircularReferenceError.prototype = Object.create(Error.prototype);\nCircularReferenceError.prototype.name = NAME;\n\nmodule.exports = CircularReferenceError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/CircularReferenceError.js","var NAME = \"InvalidSourceError\";\nvar MESSAGE = \"An exception was thrown when making a request.\";\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidSourceError(error) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.innerError = error;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidSourceError.prototype = Object.create(Error.prototype);\nInvalidSourceError.prototype.name = NAME;\nInvalidSourceError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidSourceError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidSourceError.js","var removeNode = require(\"../cache/removeNode\");\nvar updateNodeAncestors = require(\"../cache/updateNodeAncestors\");\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node[ƒ_parent]) {  // eslint-disable-line no-cond-assign\n            removeNode(node, parent, node[ƒ_key], lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru[ƒ_tail];\n        node = prev;\n        while ((total >= targetSize) && node) {\n            prev = prev[ƒ_prev];\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru[ƒ_tail] = lru[ƒ_prev] = node;\n        if (node == null) {\n            lru[ƒ_head] = lru[ƒ_next] = undefined;\n        } else {\n            node[ƒ_next] = undefined;\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/collect.js","module.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object[ƒ_prev];\n    var next = object[ƒ_next];\n    if (next) {\n        next[ƒ_prev] = prev;\n    }\n    if (prev) {\n        prev[ƒ_next] = next;\n    }\n    object[ƒ_prev] = object[ƒ_next] = undefined;\n\n    if (object === root[ƒ_head]) {\n        root[ƒ_head] = next;\n    }\n    if (object === root[ƒ_tail]) {\n        root[ƒ_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/splice.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar $$observable = require('symbol-observable').default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function() {\n    return this;\n}\n\nSource.prototype.operator = function(destination) {\n    return this.subscribe(destination);\n}\n\nSource.prototype.lift = function(operator, source) {\n    source = new Source(source || this);\n    source.operator = operator;\n    return source;\n}\n\nSource.prototype.subscribe = function(destination, x, y) {\n    return new Subscription([\n        this.operator.call(\n            this.source, !(destination instanceof Subscriber) ?\n                new Subscriber(destination, x, y) : destination)\n    ]);\n}\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function(resolve, reject) {\n            var values = [], rejected = false;\n            source.subscribe({\n                next: function(value) { values[values.length] = value; },\n                error: function(errors) { (rejected = true) && reject(errors); },\n                complete: function() {\n                    !rejected &&\n                    resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Source.js","var empty = {\n    dispose: function() {},\n    unsubscribe: function() {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/ImmediateScheduler.js","var isObject = require(\"./../support/isObject\");\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getTimestamp.js","var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && (\"json\" in envelope);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONEnvelope.js","var isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONGraphEnvelope.js","module.exports = Date.now;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/now.js","module.exports = 1;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-never.js","\"use strict\";\n\nvar Model = require(\"./Model\");\nvar FalcorJSON = require(\"./cache/get/json/FalcorJSON\");\n\nfunction falcor(opts) {\n    return new Model(opts);\n}\n\nfalcor[\"Model\"] = Model;\nfalcor[\"FalcorJSON\"] = FalcorJSON;\nfalcor[\"toProps\"] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","var toPaths = require('./toPaths');\nvar toCollapseMap = require('./toCollapseMap');\nvar toCollapseTrees = require('./toCollapseTrees');\n\nmodule.exports = function collapse(paths) {\n    return toPaths(toCollapseTrees(toCollapseMap(paths)));\n};\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/collapse.js","var isArray = Array.isArray;\nvar getHashCode = require('./getHashCode');\n\nmodule.exports = computeFlatBufferHash;\n\nfunction computeFlatBufferHash(seed) {\n\n    if (seed === undefined) {\n        return undefined;\n    }\n\n    var code = '';\n    var keys = seed['$keys'];\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    while (++keysIndex < keysLength) {\n\n        var key = keys[keysIndex];\n\n        if (key === null) {\n            code = '' + getHashCode('' + code + 'null');\n            continue;\n        } else if (typeof key === 'object') {\n            key = '{from:' + key.from + ',length:' + key.length + '}';\n        }\n\n        var next = computeFlatBufferHash(seed[keysIndex]);\n        if (next === undefined) {\n            code = '' + getHashCode('' + code + key);\n        } else {\n            code = '' + getHashCode('' + code + key + next['$code']);\n        }\n    }\n\n    seed['$code'] = code;\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/computeFlatBufferHash.js","var isArray = Array.isArray;\nvar materializedAtom = require('./support/materializedAtom');\n\nmodule.exports = hasIntersection\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === materializedAtom;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/hasIntersection.js","var isArray = Array.isArray;\nvar nullBuffer = { '$keys': [null], '$keysMap': { 'null': 0 } };\nvar flatBufferToPaths = require('./flatBufferToPaths');\n\nmodule.exports = toFlatBuffer;\n\n/*\nvar inspect = require('util').inspect;\nvar computeFlatBufferHash = require('./computeFlatBufferHash');\nvar flatBuf = computeFlatBufferHash(toFlatBuffer([\n    ['genreLists', 'length'],\n    ['genreLists', { from: 1, length: 9 }, ['name', 'rating']],\n    ['genreLists', { from: 1, length: 9 }, 'color', null],\n    ['genreLists', { from: 1, length: 9 }, 'titles', 'length'],\n    ['genreLists', { from: 1, length: 9 }, 'titles', { from: 9, length: 2 }, ['name', 'rating', 'box-shot']],\n]));\n\nconsole.log(inspect(flatBuf, { depth: null }));\n*/\n\nfunction toFlatBuffer(paths, seed) {\n    return paths.reduce(function(seed, path) {\n        if (isArray(path)) {\n            return pathToFlatBuffer(seed, path, 0, path.length);\n        }\n        return toFlatBuffer(flatBufferToPaths(path), seed);\n    }, seed || {});\n}\n\nfunction pathToFlatBuffer(seed, path, depth, length) {\n\n    if (depth === length) {\n        return undefined;\n    }\n\n    seed = seed || {};\n    var keys = seed['$keys'] || (seed['$keys'] = []);\n    var keysMap = seed['$keysMap'] || (seed['$keysMap'] = {});\n    var keysIndex = -1;\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullBuffer;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = nextKey;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyset = { from: nextKey, length: rangeEnd - nextKey + 1 };\n            nextKey = '{from:' + nextKey + ',length:' + (rangeEnd - nextKey + 1) + '}';\n            if ('undefined' === typeof (keysIndex = keysMap[nextKey])) {\n                keysIndex = keys.length;\n            }\n            keys[keysIndex] = keyset;\n            keysMap[nextKey] = keysIndex;\n            next = pathToFlatBuffer(seed[keysIndex], path, nextDepth, length);\n            if (next !== undefined) {\n                seed[keysIndex] = next;\n            }\n        }\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n\n// WEBPACK FOOTER //\n// .-path-utils/lib/toFlatBuffer.js","var Call = require(\"./request/Call\");\nvar ModelRoot = require(\"./ModelRoot\");\nvar ModelDataSourceAdapter = require(\"./ModelDataSourceAdapter\");\nvar TimeoutScheduler = require(\"./schedulers/TimeoutScheduler\");\nvar ImmediateScheduler = require(\"./schedulers/ImmediateScheduler\");\n\nvar lruCollect = require(\"./lru/collect\");\nvar getSize = require(\"./support/getSize\");\nvar isObject = require(\"./support/isObject\");\nvar isJSONEnvelope = require(\"./support/isJSONEnvelope\");\nvar getCachePosition = require(\"./cache/getCachePosition\");\nvar isJSONGraphEnvelope = require(\"./support/isJSONGraphEnvelope\");\n\nvar setCache = require(\"./cache/set/setPathMaps\");\nvar setJSONGraphs = require(\"./cache/set/setJSONGraphs\");\n\nvar getJSON = require(\"./cache/get/json\");\nvar getCache = require(\"./cache/getCache\");\nvar getJSONGraph = require(\"./cache/get/jsonGraph\");\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._seed = {};\n        this._treatErrorsAsValues = true;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get() {\n    return new Call('get', this, Array.prototype.slice.call(arguments, 0))._toJSON(this._seed || {}, []);\n}\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set() {\n    return new Call('set', this, Array.prototype.slice.call(arguments, 0))._toJSON({}, []);\n}\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    return new Call('get', this, Array.prototype.slice.call(arguments, 0))._toJSON(null, []);\n}\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call() {\n    return new Call('call', this, Array.prototype.slice.call(arguments, 0))._toJSON({}, []);\n}\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    return new Call('invalidate', this, Array.prototype.slice.call(arguments, 0))._toJSON(null, null).then();\n}\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = require(\"./deref\");\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = require(\"./deref/hasValidParentReference\");\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return this.get(path).lift(function(subscriber) {\n        return this.subscribe({\n            onNext: function(data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        })\n    });\n}\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : {path:path,value:value};\n    return this.set(value).lift(function(subscriber) {\n        return this.subscribe({\n            onNext: function(data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        })\n    });\n}\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._seed = null;\n        this._node = this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            lruCollect(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        var out;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (out) {\n            getJSON(this, out, null, false, true);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache() {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n    var result = {};\n    var path = this._path;\n    this._path = [];\n    getJSONGraph(this, paths, result);\n    this._path = path;\n    return result.jsonGraph;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path = []) {\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === \"delete\") {\n                delete clone[key];\n            } else if (key === \"_path\") {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty(\"_node\")) {\n                    delete clone[\"_node\"];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === \"number\") {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[ƒ_abs_path] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = require(\"./cache/getVersion\");\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = require(\"./cache/set/setPathValues\");\nModel.prototype._setPathMaps = require(\"./cache/set/setPathMaps\");\nModel.prototype._setJSONGs = require(\"./cache/set/setJSONGraphs\");\nModel.prototype._setCache = require(\"./cache/set/setPathMaps\");\n\nModel.prototype._invalidatePathValues = require(\"./cache/invalidate/invalidatePathSets\");\nModel.prototype._invalidatePathMaps = require(\"./cache/invalidate/invalidatePathMaps\");\n\n\n\n// WEBPACK FOOTER //\n// ./lib/Model.js","function ModelDataSourceAdapter(model) {\n    this._model = model._materialize().treatErrorsAsValues();\n    // this._model = model._materialize().boxValues().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [\n        path, args, suffixes\n    ].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelDataSourceAdapter.js","var functionTypeof = 'function';\nvar hasOwn = require(\"./support/hasOwn\");\nvar Requests = require(\"./request/Queue\");\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = 0;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\n\nModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value &&\n            cacheNode.$type === messageNode.$type &&\n            cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelRoot.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    args = [].concat(_args[1] || []);\n    suffixes = [].concat(_args[2] || []);\n    thisPaths = [].concat(_args[3] || []);\n    path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue =  getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        args: null,\n        data: data,\n        missing: [],\n        relative: [],\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    args = [].concat(_args[1] || []);\n    suffixes = [].concat(_args[2] || []);\n    thisPaths = [].concat(_args[3] || []);\n    path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        args: null,\n        data: data,\n        missing: [],\n        relative: [],\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/call/index.js","module.exports = {\n    json: require('./json/getJSON'),\n    jsonGraph: require('./jsonGraph/getJSONGraph')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/index.js","var clone = require(\"../../clone\");\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results,\n                 requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onError.js","var arr = new Array(2);\nvar onValue = require(\"./onValue\");\nvar $ref = require(\"../../../types/ref\");\nvar FalcorJSON = require(\"./FalcorJSON\");\nvar onValueType = require(\"../onValueType\");\nvar isExpired = require(\"../../isExpired\");\nvar originalOnMissing = require(\"../onMissing\");\nvar getReferenceTarget = require(\"./getReferenceTarget\");\nvar NullInPathError = require(\"../../../errors/NullInPathError\");\nvar InvalidKeySetError = require(\"../../../errors/InvalidKeySetError\");\nvar getHashCode = require(\"@graphistry/falcor-path-utils/lib/getHashCode\");\nvar flatBufferToPaths = require(\"@graphistry/falcor-path-utils/lib/flatBufferToPaths\");\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, json, path, depth, seed, results,\n                                requestedPath, optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, expireImmediate, branchSelector,\n                                boxValues, materialized, hasDataSource,\n                                treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node ||\n        undefined !== (type = node.$type) ||\n        undefined === path) {\n        arr[1] = false;\n        arr[0] = onValueType(node, type, json,\n                             path, depth, seed, results,\n                             requestedPath, depth,\n                             optimizedPath, optimizedLength,\n                             fromReference, modelRoot, expired, expireImmediate,\n                             branchSelector, boxValues, materialized, hasDataSource,\n                             treatErrorsAsValues, onValue, onMissing);\n        return arr;\n    }\n\n    var f_meta, f_old_keys, f_new_keys, f_code = \"\";\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        keys = path[\"$keys\"],\n        nextDepth = depth + 1, rangeEnd,\n        nextJSON, nextReferenceContainer,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[ƒ_abs_path];\n    }\n\n    if (json) {\n        if (typeof json !== 'object') {\n            json = undefined;\n        } else if (f_meta = json[ƒ_meta]) {\n            if (!branchSelector && !(json instanceof FalcorJSON)) {\n                json = { [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype };\n            } else if (\n                f_meta[ƒm_version]  === node[ƒ_version] &&\n                f_meta[\"$code\"]     === path[\"$code\"] &&\n                f_meta[ƒm_abs_path] === node[ƒ_abs_path]) {\n                results.hasValue = true;\n                arr[0] = json;\n                arr[1] = false;\n                return arr;\n            }\n            f_old_keys = f_meta[ƒm_keys];\n            f_meta[ƒm_version] = node[ƒ_version];\n            f_meta[ƒm_abs_path] = node[ƒ_abs_path];\n            f_meta[ƒm_deref_to] = refContainerRefPath;\n            f_meta[ƒm_deref_from] = refContainerAbsPath;\n        }\n    }\n\n    f_new_keys = {};\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath, nextPathKey,\n        hasMissingPath = false,\n        nextMeta, nextMetaPath;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n        nextMeta = undefined;\n        nextMetaPath = undefined;\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = \"\" + getHashCode(\"\" + f_code + \"null\");\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n            nextPathKey = nextKey;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n            nextPathKey = \"{from:\" + nextKey + \",length:\" + (rangeEnd - nextKey + 1) + \"}\";\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextPath !== undefined &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextReferenceContainer = refTarget[2];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n            }\n\n            // Continue following the path\n\n            arr = walkPathAndBuildOutput(\n                cacheRoot, next, nextJSON, nextPath, nextDepth, seed,\n                results, requestedPath, nextOptimizedPath,\n                nextOptimizedLength, fromReference, nextReferenceContainer,\n                modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n            );\n\n            nextJSON = arr[0];\n            hasMissingPath = hasMissingPath || arr[1];\n\n            if (!seed) {\n                continue;\n            }\n\n            // Inspect the return value from the step and determine whether to\n            // create or write into the JSON branch at this level.\n            //\n            // 1. If the next node was a leaf value, nextJSON is the value.\n            // 2. If the next node was a missing path, nextJSON is undefined.\n            // 3. If the next node was a branch, then nextJSON will either be an\n            //    Object or undefined. If nextJSON is undefined, all paths under\n            //    this step resolved to missing paths. If it's an Object, then\n            //    at least one path resolved to a successful leaf value.\n            //\n            // This check defers creating branches until we see at least one\n            // cache hit. Otherwise, don't waste the cycles creating a branch\n            // if everything underneath is a cache miss.\n\n            if (undefined !== nextJSON) {\n                // The json value will initially be undefined. If we're here,\n                // then at least one leaf value was encountered, so create a\n                // branch to contain it.\n                if (f_meta === undefined) {\n                    f_meta = {};\n                    f_meta[ƒm_version] = node[ƒ_version];\n                    f_meta[ƒm_abs_path] = node[ƒ_abs_path];\n                    f_meta[ƒm_deref_to] = refContainerRefPath;\n                    f_meta[ƒm_deref_from] = refContainerAbsPath;\n                    // Empower developers to instrument branch node creation by\n                    // providing a custom function. If they do, delegate branch\n                    // node creation to them.\n                    json = branchSelector && branchSelector({\n                        [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype }) || {\n                        [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype };\n                }\n\n                f_new_keys[nextKey] = true;\n                if (f_old_keys && f_old_keys.hasOwnProperty(nextKey)) {\n                    f_old_keys[nextKey] = false;\n                }\n                // Set the reported branch or leaf into this branch.\n                json[nextKey] = nextJSON;\n            } else {\n                hasMissingPath = true;\n                if (json && json.hasOwnProperty(nextKey)) {\n                    delete json[nextKey];\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        if (!hasMissingPath) {\n            if (undefined === nextPath) {\n                f_code = \"\" + getHashCode(\"\" + f_code + nextPathKey);\n            } else {\n                f_code = \"\" + getHashCode(\"\" + f_code + nextPathKey + nextPath[\"$code\"]);\n            }\n        }\n    }\n\n    if (hasMissingPath) {\n        f_code = \"__incomplete__\";\n    }\n\n    if (f_meta) {\n        f_meta[\"$code\"] = f_code;\n        f_meta[ƒm_keys] = f_new_keys;\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   json, reportMaterialized, branchSelector) {\n\n    var suffix;\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n    var createMaterializedBranch = !branchSelector ?\n        createDefaultMaterializedBranch :\n        wrapMaterializedBranchSelector(branchSelector);\n\n    return paths.reduce(function(json, restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth,\n                                 results, requestedPath, requestedLength, fromReference,\n                                 optimizedPath, optimizedLength, reportMissing, json,\n                                 reportMaterialized, createMaterializedBranch);\n    }, json);\n}\n\nfunction wrapMaterializedBranchSelector(branchSelector) {\n    return function(path, _depth, node) {\n        return branchSelector(\n            node = createDefaultMaterializedBranch(path, _depth, node)\n        ) || node;\n    }\n}\n\nfunction createDefaultMaterializedBranch(path, _depth, node) {\n    f_meta = {};\n    f_meta[ƒm_version] = 0;\n    f_meta[ƒm_abs_path] = path.slice(0, _depth);\n    return { [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype };\n }\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkFlatBuffer.js","var isArray = Array.isArray;\nvar onValue = require(\"./onValue\");\nvar $ref = require(\"../../../types/ref\");\nvar FalcorJSON = require(\"./FalcorJSON\");\nvar onValueType = require(\"../onValueType\");\nvar isExpired = require(\"../../isExpired\");\nvar originalOnMissing = require(\"../onMissing\");\nvar getReferenceTarget = require(\"./getReferenceTarget\");\nvar NullInPathError = require(\"../../../errors/NullInPathError\");\nvar InvalidKeySetError = require(\"../../../errors/InvalidKeySetError\");\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, json, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type, json,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired, expireImmediate,\n                           branchSelector, boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var f_meta;\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        nextJSON, nextReferenceContainer,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return json;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[ƒ_abs_path];\n    }\n\n    if (json) {\n        if (typeof json !== 'object') {\n            json = undefined;\n        } else if (f_meta = json[ƒ_meta]) {\n            f_meta[ƒm_version] = node[ƒ_version];\n            f_meta[ƒm_abs_path] = node[ƒ_abs_path];\n            f_meta[ƒm_deref_to] = refContainerRefPath;\n            f_meta[ƒm_deref_from] = refContainerAbsPath;\n        }\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextReferenceContainer = refTarget[2];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n            }\n\n            // Continue following the path\n\n            nextJSON = walkPathAndBuildOutput(\n                cacheRoot, next, nextJSON, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, nextReferenceContainer,\n                modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n            );\n\n            // Inspect the return value from the step and determine whether to\n            // create or write into the JSON branch at this level.\n            //\n            // 1. If the next node was a leaf value, nextJSON is the value.\n            // 2. If the next node was a missing path, nextJSON is undefined.\n            // 3. If the next node was a branch, then nextJSON will either be an\n            //    Object or undefined. If nextJSON is undefined, all paths under\n            //    this step resolved to missing paths. If it's an Object, then\n            //    at least one path resolved to a successful leaf value.\n            //\n            // This check defers creating branches until we see at least one\n            // cache hit. Otherwise, don't waste the cycles creating a branch\n            // if everything underneath is a cache miss.\n\n            if (undefined !== nextJSON) {\n                // The json value will initially be undefined. If we're here,\n                // then at least one leaf value was encountered, so create a\n                // branch to contain it.\n                if (f_meta === undefined) {\n                    f_meta = {};\n                    f_meta[ƒm_version] = node[ƒ_version];\n                    f_meta[ƒm_abs_path] = node[ƒ_abs_path];\n                    f_meta[ƒm_deref_to] = refContainerRefPath;\n                    f_meta[ƒm_deref_from] = refContainerAbsPath;\n                    // Empower developers to instrument branch node creation by\n                    // providing a custom function. If they do, delegate branch\n                    // node creation to them.\n                    json = branchSelector && branchSelector({\n                        [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype }) || {\n                        [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype };\n                }\n\n                // Set the reported branch or leaf into this branch.\n                json[nextKey] = nextJSON;\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   json, reportMaterialized, branchSelector) {\n\n    var createMaterializedBranch = !branchSelector ?\n        createDefaultMaterializedBranch :\n        wrapMaterializedBranchSelector(branchSelector);\n\n    return originalOnMissing(path, depth, results,\n                             requestedPath, requestedLength, fromReference,\n                             optimizedPath, optimizedLength, reportMissing,\n                             json, reportMaterialized, createMaterializedBranch);\n}\n\nfunction wrapMaterializedBranchSelector(branchSelector) {\n    return function(path, _depth, node) {\n        return branchSelector(\n            node = createDefaultMaterializedBranch(path, _depth, node)\n        ) || node;\n    }\n}\n\nfunction createDefaultMaterializedBranch(path, _depth, node) {\n    f_meta = {};\n    f_meta[ƒm_version] = 0;\n    f_meta[ƒm_abs_path] = path.slice(0, _depth);\n    return { [ƒ_meta]: f_meta, __proto__: FalcorJSON.prototype };\n }\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkPath.js","var arr = new Array(2);\nvar clone = require(\"../../clone\");\nvar $ref = require(\"../../../types/ref\");\nvar inlineValue = require(\"./inlineValue\");\nvar promote = require(\"../../../lru/promote\");\nvar isExpired = require(\"../../isExpired\");\nvar createHardlink = require(\"../../createHardlink\");\nvar CircularReferenceError = require(\"../../../errors/CircularReferenceError\");\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, boxValues, materialized, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        followedRefsCount = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[ƒ_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (DEBUG) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\n                                \"Followed \" + followedRefsCount + \" references. \" +\n                                \"This might indicate the presence of an indirect \" +\n                                \"circular reference chain.\"\n                            );\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = ((\n                                    typeof console.warn === \"function\" && console.warn) || (\n                                    typeof console.log === \"function\" && console.log));\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getReferenceTarget.js","var clone = require(\"../../clone\");\nvar $ref = require(\"../../../types/ref\");\nvar $error = require(\"../../../types/error\");\nvar inlineValue = require(\"./inlineValue\");\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results,\n                          requestedPath, optimizedPath, optimizedLength,\n                          fromReference, boxValues, materialized) {\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            value = materializedAtom;\n        } else {\n            return undefined;\n        }\n    }\n    // boxValues always clones the node\n    else if (boxValues ||\n            /*\n             * JSON Graph should always clone errors, refs, atoms we didn't\n             * create, and atoms we created to wrap Object values.\n             */\n             $ref === type ||\n             $error === type ||\n             !node[ƒ_wrapped_value] ||\n             \"object\" === typeof value) {\n        value = clone(node);\n    }\n\n    if (seed) {\n        results.hasValue = true;\n        inlineValue(value, optimizedPath, optimizedLength, seed);\n        (seed.paths || (seed.paths = [])).push(\n            requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n        );\n    }\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/onValue.js","var isArray = Array.isArray;\nvar clone = require(\"../../clone\");\nvar $ref = require(\"../../../types/ref\");\nvar onValue = require(\"./onValue\");\nvar inlineValue = require(\"./inlineValue\");\nvar onValueType = require(\"../onValueType\");\nvar isExpired = require(\"../../isExpired\");\nvar originalOnMissing = require(\"../onMissing\");\nvar getReferenceTarget = require(\"./getReferenceTarget\");\nvar NullInPathError = require(\"../../../errors/NullInPathError\");\nvar InvalidKeySetError = require(\"../../../errors/InvalidKeySetError\");\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, modelRoot, expired, expireImmediate,\n                                boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type, seed,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired, expireImmediate,\n                           undefined, boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            keyset = keysOrRanges[keysetIndex];\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, seed,\n                                               boxValues, materialized, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(\n                cacheRoot, next, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate,\n                boxValues, materialized, hasDataSource, treatErrorsAsValues\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   seed, reportMaterialized, branchSelector) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push(\n            (isLeaf = 0 === requestedLength - depth) &&\n                                 // depth + 1 if fromReference === true\n                requestedPath.slice(0, depth + !!fromReference) ||\n                requestedPath.slice(0, depth).concat(path\n                    .slice(depth, requestedLength + !!fromReference))\n        );\n\n        json = inlineValue(isLeaf && materializedAtom || undefined,\n                           optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results,\n                             requestedPath, requestedLength, fromReference,\n                             optimizedPath, optimizedLength, reportMissing,\n                             json, reportMaterialized);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/walkPath.js","var isInternalKey = require(\"../support/isInternalKey\");\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    // only copy objects\n    if (!node || typeof node !== \"object\") {\n        return;\n    }\n\n    Object.\n        keys(node).\n        filter(function(k) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return !isInternalKey(k) && node[k] !== undefined;\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n                var isUserCreatedcacheNext = !cacheNext[ƒ_wrapped_value];\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext, key);\n        });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCache.js","var getBoundCacheNode = require(\"./getBoundCacheNode\");\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[ƒ_version];\n    return (version == null) ? -1 : version;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getVersion.js","var isArray = Array.isArray;\nvar isPathValue = require(\"../support/isPathValue\");\nvar isJSONEnvelope = require(\"../support/isJSONEnvelope\");\nvar isJSONGraphEnvelope = require(\"../support/isJSONGraphEnvelope\");\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = \"JSONGraphs\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/groupCacheArguments.js","var invalidatePathSets = require('./invalidatePathSets');\nvar invalidatePathMaps = require('./invalidatePathMaps');\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n}\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    invalidatePathSets(model, args, expireImmediate);\n    return {};\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/index.js","var $ref = require(\"../types/ref\");\nvar $error = require(\"../types/error\");\nvar getSize = require(\"../support/getSize\");\nvar getTimestamp = require(\"../support/getTimestamp\");\n\nvar wrapNode = require(\"./wrapNode\");\nvar isExpired = require(\"./isExpired\");\nvar insertNode = require(\"./insertNode\");\nvar expireNode = require(\"./expireNode\");\nvar replaceNode = require(\"./replaceNode\");\nvar reconstructPath = require(\"./reconstructPath\");\nvar updateNodeAncestors = require(\"./updateNodeAncestors\");\n\nmodule.exports = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n\n        // The message and cache are both undefined, return undefined.\n        else if (message === undefined) {\n            return message;\n        }\n\n        else {\n            cIsObject = !(!node || typeof node !== 'object');\n            if (cIsObject) {\n                // Is the cache node a branch? If so, return the cache branch.\n                cType = node.$type;\n                if (cType == null) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node[ƒ_parent] == null) {\n                        insertNode(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n            }\n        }\n    } else {\n        cIsObject = !(!node || typeof node !== 'object');\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty, leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node, expireImmediate)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node[ƒ_parent] != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node, expireImmediate) &&\n                        !isExpired(message, expireImmediate) &&\n                        mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n\n        if (mType === $error && errorSelector) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n        }\n\n        if (mType && node === message) {\n            if (node[ƒ_parent] == null) {\n                node = wrapNode(node, cType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            if ((cType && !isExpired(node, expireImmediate)) || !cIsObject) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                //\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n                // If at least one of the cache/message are sentinels, compare them.\n                if (isDistinct && (cType || mType) && comparator) {\n                    isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (isDistinct) {\n                message = wrapNode(message, mType, mType ? message.value : message);\n                sizeOffset = getSize(node) - getSize(message);\n                node = replaceNode(node, message, parent, key, lru, version);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n            expireNode(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode(message, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeJSONGraphNode.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\nvar arrayFlatMap = require(\"../../support/array-flat-map\");\nvar groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: require(\"./setPathMaps\"),\n    setPathValues: require(\"./setPathValues\"),\n    setJSONGraphs: require(\"./setJSONGraphs\")\n};\n\nfunction json(model, args, data, progressive, expireImmediate) {\n    args = groupCacheArguments(args);\n    var set = setGroupsIntoCache(model, args /*, expireImmediate */);\n    var get = progressive && getJSON(model, set.relative, data, progressive, expireImmediate);\n    var jsong = getJSONGraph({\n        _root: model._root, _boxed: model._boxed, _materialized: true,\n        _treatErrorsAsValues: model._treatErrorsAsValues\n    }, set.optimized, {}, progressive, expireImmediate);\n    return {\n        args: args,\n        data: data,\n        fragments: jsong.data,\n        missing: set.optimized,\n        relative: set.relative,\n        error: get && get.error,\n        errors: get && get.errors,\n        requested: jsong.requested,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, args, data, progressive, expireImmediate) {\n    args = groupCacheArguments(args);\n    var set = setGroupsIntoCache(model, args /*, expireImmediate */);\n    var jsong = getJSONGraph({\n        _root: model._root,\n        _boxed: model._boxed, _materialized: true,\n        _treatErrorsAsValues: model._treatErrorsAsValues\n    }, set.optimized, data, progressive, expireImmediate);\n    return {\n        args: args,\n        data: data,\n        error: jsong.error,\n        fragments: jsong.data,\n        missing: set.optimized,\n        relative: set.relative,\n        hasValue: jsong.hasValue,\n        requested: jsong.requested\n    };\n}\n\nfunction setGroupsIntoCache(model, xs /*, expireImmediate */) {\n\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var selector = modelRoot.errorSelector;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports[\"set\" + inputType];\n            var resultPaths = operation(model, groupedArgs, selector, null, false);\n            optimizedPaths.push.apply(optimizedPaths, resultPaths[1]);\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === \"JSONGraphs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, resultPaths[0]);\n            }\n        }\n    }\n\n    return { optimized: optimizedPaths, relative: requestedPaths };\n};\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/index.js","module.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[ƒ_refs_length] || 0,\n        destNodeRefsLength = destNode[ƒ_refs_length] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[ƒ_ref + i];\n        if (ref !== void 0) {\n            ref[ƒ_context] = destNode;\n            destNode[ƒ_ref + (destNodeRefsLength + i)] = ref;\n            fromNode[ƒ_ref + i] = void 0;\n        }\n    }\n    destNode[ƒ_refs_length] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[ƒ_refs_length] = void 0;\n    return destNode;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/transferBackReferences.js","module.exports = function unlinkBackReferences(node) {\n    var i = -1, n = node[ƒ_refs_length] || 0;\n    while (++i < n) {\n        var ref = node[ƒ_ref + i];\n        if (ref != null) {\n            ref[ƒ_context] = ref[ƒ_ref_index] = node[ƒ_ref + i] = void 0;\n        }\n    }\n    node[ƒ_refs_length] = void 0;\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkBackReferences.js","module.exports = function unlinkForwardReference(reference) {\n    var destination = reference[ƒ_context];\n    if (destination) {\n        var i = (reference[ƒ_ref_index] || 0) - 1,\n            n = (destination[ƒ_refs_length] || 0) - 1;\n        while (++i <= n) {\n            destination[ƒ_ref + i] = destination[ƒ_ref + (i + 1)];\n        }\n        destination[ƒ_refs_length] = n;\n        reference[ƒ_ref_index] = reference[ƒ_context] = destination = void 0;\n    }\n    return reference;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkForwardReference.js","module.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[ƒ_parent] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[ƒ_invalidated]) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/hasValidParentReference.js","var CONTAINER_DOES_NOT_EXIST = \"e\";\nvar $ref = require(\"../types/ref\");\nvar getCachePosition = require(\"../cache/getCachePosition\");\nvar InvalidDerefInputError = require(\"../errors/InvalidDerefInputError\");\n\nmodule.exports = function deref(boundJSONArg) {\n\n    if (!boundJSONArg || typeof boundJSONArg !== 'object') {\n        throw new InvalidDerefInputError();\n    }\n\n    var referenceContainer, currentRefPath, i, len;\n    var jsonMetadata = boundJSONArg && boundJSONArg[ƒ_meta];\n\n    if (!jsonMetadata || typeof jsonMetadata !== 'object') {\n        return this._clone({\n            _node: undefined\n        });\n    }\n\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = jsonMetadata[ƒm_abs_path];\n\n    if (!absolutePath) {\n        return this._clone({\n            _node: undefined,\n            _seed: recycleJSON && { json: boundJSONArg } || undefined\n        });\n    } else if (absolutePath.length === 0) {\n        return this._clone({\n            _path: absolutePath,\n            _node: this._root.cache,\n            _referenceContainer: true,\n            _seed: recycleJSON && { json: boundJSONArg } || undefined\n        });\n    }\n\n    var originalRefPath = jsonMetadata[ƒm_deref_to];\n    var originalAbsPath = jsonMetadata[ƒm_deref_from];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheRoot = this._root.cache;\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n            i = 0;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n\n            validContainer = true;\n            for (; validContainer && i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    validContainer = false;\n                }\n            }\n            if (validContainer === false) {\n                cacheNode = undefined;\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n        referenceContainer = true;\n    }\n\n    return this._clone({\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer,\n        _seed: recycleJSON && { json: boundJSONArg } || undefined\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/index.js","var NAME = \"BoundJSONGraphModelError\";\nvar MESSAGE = \"It is not legal to use the JSON Graph \" +\n    \"format from a bound Model. JSON Graph format\" +\n    \" can only be used from a root model.\";\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = this.name;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nBoundJSONGraphModelError.prototype = Object.create(Error.prototype);\nBoundJSONGraphModelError.prototype.name = NAME;\nBoundJSONGraphModelError.message = MESSAGE;\n\nmodule.exports = BoundJSONGraphModelError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/BoundJSONGraphModelError.js","var NAME = \"InvalidDerefInputError\";\nvar MESSAGE = \"Deref can only be used with a non-primitive object from get, set, or call.\";\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidDerefInputError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidDerefInputError.prototype = Object.create(Error.prototype);\nInvalidDerefInputError.prototype.name = NAME;\nInvalidDerefInputError.message = MESSAGE;\n\nmodule.exports = InvalidDerefInputError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidDerefInputError.js","var NAME = \"InvalidModelError\";\nvar MESSAGE = \"The boundPath of the model is not valid since a value or error was found before the path end.\";\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidModelError(boundPath, shortedPath) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidModelError.prototype = Object.create(Error.prototype);\nInvalidModelError.prototype.name = NAME;\nInvalidModelError.message = MESSAGE;\n\nmodule.exports = InvalidModelError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidModelError.js","var NAME = \"MaxRetryExceededError\";\nvar MESSAGE = \"The allowed number of retries have been exceeded.\";\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nfunction MaxRetryExceededError(maxRetryCount, absolute, relative, optimized) {\n    var err = Error.call(this,\n        \"Exceeded the max retry count (\" + maxRetryCount + \") for these paths: \\n\" +\n        (absolute &&\n        \"absolute: [\\n\\t\" + printPaths(absolute) + \"\\n]\\n\" || \"\") +\n        (relative &&\n        \"relative: [\\n\\t\" + printPaths(relative) + \"\\n]\\n\" || \"\") +\n        (optimized &&\n        \"optimized: [\\n\\t\" + printPaths(optimized) + \"\\n]\\n\" || \"\")\n    );\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nMaxRetryExceededError.prototype = Object.create(Error.prototype);\nMaxRetryExceededError.prototype.name = NAME;\nMaxRetryExceededError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = MaxRetryExceededError;\n\nfunction printPaths(paths) {\n    return paths.map(function(path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/MaxRetryExceededError.js","var Source = require('./Source');\nvar Subscriber = require('./Subscriber');\nvar lruCollect = require('../lru/collect');\nvar collapse = require(\"@graphistry/falcor-path-utils/lib/collapse\");\nvar InvalidSourceError = require(\"../errors/InvalidSourceError\");\nvar MaxRetryExceededError = require('../errors/MaxRetryExceededError');\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function(operator, source) {\n    source = new Call(source || this);\n    source.operator = operator;\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    return source;\n}\n\nCall.prototype.operator = function(subscriber) {\n    return this._subscribe(subscriber);\n}\n\nCall.prototype._subscribe = function(subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n}\n\nCall.prototype._toJSON = function(data, errors) {\n    return this.lift(new CallOperator(\n        this.operator.data || data,\n        this.operator.errors || errors,\n        'json',\n        this.operator.progressive,\n        this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype._toJSONG = function(data, errors) {\n    return this.lift(new CallOperator(\n        this.operator.data || data,\n        this.operator.errors || errors,\n        'jsonGraph',\n        this.operator.progressive,\n        this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.retry = function(maxRetryCount) {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        this.operator.progresive,\n        maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.progressively = function() {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        true,\n        this.operator.maxRetryCount\n    ), this.source);\n}\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    if (data === undefined) { data = {}; }\n    if (errors === undefined) { errors = []; }\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function(source, destination) {\n    return source.subscribe(new CallSubscriber(\n        destination, this.data, this.errors, this.operation, this.progressive\n    ));\n}\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.hasValue = false;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: require('../cache/get'),\n    set: require('../cache/set'),\n    call: require('../cache/call'),\n    invalidate: require('../cache/invalidate')\n};\n\nCallSubscriber.prototype.next =\nCallSubscriber.prototype.onNext = function(seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n\n    var seedIsImmutable = progressive && data && !model._recycleJSON;\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type]\n            [operation](model, args, data,\n                        progressive || !model._source,\n                        this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            throw results.error;\n        }\n\n        errors && results.errors &&\n            errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;// || this.args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n}\n\nCallSubscriber.prototype.error =\nCallSubscriber.prototype.onError = function(error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n}\n\nCallSubscriber.prototype.complete =\nCallSubscriber.prototype.onCompleted = function(error) {\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && (\n            (data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return Subscriber.prototype.onError.call(\n                this,  errors.length && errors || error\n            );\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return Subscriber.prototype.onError.call(this, new MaxRetryExceededError(\n            this.retryCount,\n            this.requested,\n            this.relative,\n            this.missing\n        ));\n    }\n\n    this.request = this.model._root.requests[this.type](\n        this.model,\n        this.missing,\n        this.relative,\n        this.fragments\n    ).subscribe(this);\n}\n\nCallSubscriber.prototype.dispose =\nCallSubscriber.prototype.unsubscribe = function() {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 &&\n                                 version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot,\n                           modelRoot.expired,\n                           cache.$size || 0,\n                           modelRoot.maxSize,\n                           modelRoot.collectRatio,\n                           modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n}\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch(e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue, nodeValue,\n        key, keys = Object.keys(node),\n        index = -1, length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === ƒ_meta) {\n            dest[ƒ_meta] = node[ƒ_meta];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (destValue === undefined || \"object\" !== typeof nodeValue) {\n                    dest[key] = nodeValue;\n                }\n                else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Call.js","var Source = require('./Source');\nvar Request = require('./Request');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar ImmediateScheduler = require(\"../schedulers/ImmediateScheduler\");\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler())\n            .batch(requested, optimized || env.paths, env.jsonGraph);\n\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request.connect());\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler())\n            .batch(null, null, env);\n\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request.connect());\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(\n        this, model._source, model._scheduler, requested, optimized\n    );\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function(destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests  = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] =\n            new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Queue.js","var Subject = require('./Subject');\nvar $error = require('../types/error');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar InvalidSourceError = require(\"../errors/InvalidSourceError\");\n\nvar toPaths = require(\"@graphistry/falcor-path-utils/lib/toPaths\");\nvar toCollapseMap = require(\"@graphistry/falcor-path-utils/lib/toCollapseMap\");\nvar toCollapseTrees = require(\"@graphistry/falcor-path-utils/lib/toCollapseTrees\");\nvar hasIntersection = require(\"@graphistry/falcor-path-utils/lib/hasIntersection\");\n\nvar setJSONGraphs = require('../cache/set/setJSONGraphs');\nvar setPathValues = require('../cache/set/setPathValues');\nvar invalidatePaths = require('../cache/invalidate/invalidatePathSets');\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.tree = {};\n    this.paths = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next =\nRequest.prototype.onNext = function(env) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    this.responded = true;\n\n    var jsonGraph = env.jsonGraph;\n    var requested = this.requested;\n    var modelRoot = queue.modelRoot;\n    var invalidated = env.invalidated;\n    var paths = env.paths || this.paths;\n\n    // Run invalidations first.\n    if (invalidated && invalidated.length) {\n        invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n    }\n\n    if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n        setJSONGraphs(\n            { _root: modelRoot },\n            [{ paths: paths, jsonGraph: jsonGraph }],\n            modelRoot.errorSelector, modelRoot.comparator, false\n        );\n    }\n\n    this.observers.slice(0).forEach(function(observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] || paths\n        });\n    });\n}\n\nRequest.prototype.error =\nRequest.prototype.onError = function(error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    this.responded = true;\n\n    error = error || {};\n\n    // Converts errors to objects, a more friendly storage\n    // of errors.\n    error = !(error instanceof Error) ?\n        // if it's $type error, use it raw\n        error.$type === $error && error ||\n        // Otherwise make it an error\n        { $type: $error, value: error } :\n        // If it's instanceof Error, pluck error.message\n        { $type: $error, value: { message: error.message }};\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(\n        this.requested.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ))\n    .map(function(path) { return { path: path, value: error }; });\n\n    if (errorPathValues.length) {\n        setPathValues(\n            { _root: modelRoot, _path: [] },\n            errorPathValues,\n            modelRoot.errorSelector,\n            modelRoot.comparator,\n            false\n        );\n    }\n\n    Subject.prototype.onError.call(this, error);\n}\n\nRequest.prototype.complete =\nRequest.prototype.onCompleted = function() {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n}\n\nRequest.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n}\n\nRequest.prototype.dispose =\nRequest.prototype.unsubscribe = function () {\n    this.tree = {};\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n}\n\nRequest.prototype.connect = function() {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n}\n\nRequest.prototype.batch = function(requested, optimized,\n                                   requestedComplements,\n                                   optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.tree,\n                              requested, optimized,\n                              requestedComplements,\n                              optimizedComplements,\n                              requestedIntersection,\n                              optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            return this;\n        }\n        return null;\n    }\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    this.data = requestedComplements;\n    return this;\n}\n\nfunction flush() {\n\n    this.active = true;\n\n    var obs, paths = this.paths = toPaths(this.tree = toCollapseTrees(\n        this.optimized.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ));\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = null;\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\n\nfunction findIntersections(tree,\n                           requested, optimized,\n                           requestedComplements,\n                           optimizedComplements,\n                           requestedIntersection,\n                           optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = 0;\n    var intersectionIndex = 0;\n    var total = optimized.length;\n    var intersectionFound = false;\n\n    while (++index < total) {\n        // If this does not intersect then add it to the output.\n        var path = optimized[index];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n\n        // If there is no subtree to look into or there is no intersection.\n        if (!subTree || !hasIntersection(subTree, path, 0, pathLen)) {\n            if (intersectionFound) {\n                requestedComplements[complementIndex] = requested[index];\n                optimizedComplements[complementIndex++] = path;\n            }\n        } else {\n            // If there has been no intersection yet and index is larger than 0\n            // (meaning we have had only complements), then we need to update\n            // our complements to match the current reality.\n            if (!intersectionFound) {\n                while (complementIndex < index) {\n                    requestedComplements[complementIndex] = requested[complementIndex];\n                    optimizedComplements[complementIndex] = optimized[complementIndex++];\n                }\n            }\n\n            intersectionFound = true;\n            requestedIntersection[intersectionIndex] = requested[index];\n            optimizedIntersection[intersectionIndex++] = optimized[index];\n        }\n    }\n\n    return intersectionFound;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Request.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\nSubject.prototype.onNext = function(value) {\n    this.observers.slice(0).forEach(function(observer) {\n        observer.onNext(value);\n    });\n}\n\nSubject.prototype.onError = function(error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onError(error);\n    });\n}\n\nSubject.prototype.onCompleted = function() {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onCompleted();\n    });\n}\n\nSubject.prototype.subscribe = function(subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n}\n\nSubject.prototype.dispose =\nSubject.prototype.unsubscribe = function () {\n    this.observers = [];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subject.js","function TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose =\nTimerDisposable.prototype.unsubscribe = function() {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/TimeoutScheduler.js","module.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/array-flat-map.js","var isArray = Array.isArray;\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (key.charAt(0) === ƒ_) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/clone.js","var isObject = require(\"./isObject\");\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getExpires.js","var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getType.js","var isObject = require(\"./isObject\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function(obj, prop) {\n  return isObject(obj) && hasOwn.call(obj, prop);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/hasOwn.js","/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nmodule.exports = function isInternalKey(x) {\n    return x === \"$size\" ||\n        x === ƒ_wrapped_value ||\n        x.charAt(0) === ƒ_;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isInternalKey.js","var isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === \"string\"\n        ));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isPathValue.js","module.exports = \"atom\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/types/atom.js","module.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/index.js\n// module id = 104\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/index.js\n// module id = 105\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/ponyfill.js\n// module id = 106\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 107\n// module chunks = 0"],"sourceRoot":""}