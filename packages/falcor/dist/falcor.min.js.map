{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///falcor.min.js","webpack:///webpack/bootstrap 0b71c4faad932f646d3a","webpack:///./lib/support/isObject.js","webpack:///./lib/types/ref.js","webpack:///./lib/support/isFunction.js","webpack:///./lib/support/isExpired.js","webpack:///./lib/response/ModelResponse.js","webpack:///./lib/internal/unicodePrefix.js","webpack:///./lib/support/expireNode.js","webpack:///./lib/support/getSize.js","webpack:///./~/@graphistry/falcor-path-utils/lib/index.js","webpack:///./lib/support/isPrimitive.js","webpack:///./lib/errors/InvalidSourceError.js","webpack:///./lib/get/getBoundCacheNode.js","webpack:///./lib/internal/ref.js","webpack:///./lib/support/createHardlink.js","webpack:///./lib/errors/NullInPathError.js","webpack:///./lib/get/clone.js","webpack:///./lib/lru/promote.js","webpack:///./lib/support/hasOwn.js","webpack:///./lib/support/updateNodeAncestors.js","webpack:///./lib/types/error.js","webpack:///./lib/internal/version.js","webpack:///./lib/set/setJSONGraphs.js","webpack:///./lib/support/isJSONEnvelope.js","webpack:///./lib/support/isPathValue.js","webpack:///./lib/support/noop.js","webpack:///./lib/types/atom.js","webpack:///./~/@graphistry/falcor-path-utils/lib/hasIntersection.js","webpack:///./~/@graphistry/falcor-path-utils/lib/support/nullTerminator.js","webpack:///./lib/get/index.js","webpack:///./lib/get/jsonGraph/inlineValue.js","webpack:///./lib/lru/collect.js","webpack:///./lib/set/setPathMaps.js","webpack:///./lib/set/setPathValues.js","webpack:///./lib/support/isJSONGraphEnvelope.js","webpack:///./lib/support/now.js","webpack:///./lib/support/removeNode.js","webpack:///./lib/support/removeNodeAndDescendants.js","webpack:///./lib/support/validateInput.js","webpack:///./lib/values/expires-never.js","webpack:///./lib/values/expires-now.js","webpack:///./~/@graphistry/falcor-path-utils/lib/iterateKeySet.js","webpack:///./~/@graphistry/falcor-path-utils/lib/support/cloneArray.js","webpack:///./~/@graphistry/falcor-path-utils/lib/support/types.js","webpack:///./~/@graphistry/falcor-path-utils/lib/toPaths.js","webpack:///./~/@graphistry/falcor-path-utils/lib/toTree.js","webpack:///./lib/errors/CircularReferenceError.js","webpack:///./lib/errors/InvalidKeySetError.js","webpack:///./lib/errors/MaxRetryExceededError.js","webpack:///./lib/get/getCachePosition.js","webpack:///./lib/get/onMissing.js","webpack:///./lib/get/onValueType.js","webpack:///./lib/lru/splice.js","webpack:///./lib/request/RequestTypes.js","webpack:///./lib/response/AssignableDisposable.js","webpack:///./lib/response/get/GetResponse.js","webpack:///./lib/response/get/checkCacheAndReport.js","webpack:///./lib/response/get/validInput.js","webpack:///./lib/response/set/SetResponse.js","webpack:///./lib/support/getTimestamp.js","webpack:///./lib/support/insertNode.js","webpack:///./lib/support/mergeValueOrInsertBranch.js","webpack:///./lib/support/reconstructPath.js","webpack:///./lib/support/replaceNode.js","webpack:///./lib/support/updateBackReferenceVersions.js","webpack:///./lib/support/wrapNode.js","webpack:///./~/es6-promise/dist/es6-promise.js","webpack:///(webpack)/buildin/global.js","webpack:///./lib/index.js","webpack:///./~/@graphistry/falcor-path-utils/lib/collapse.js","webpack:///./~/@graphistry/falcor-path-utils/lib/errors/index.js","webpack:///./~/@graphistry/falcor-path-utils/lib/followReference.js","webpack:///./~/@graphistry/falcor-path-utils/lib/optimizePathSets.js","webpack:///./~/@graphistry/falcor-path-utils/lib/pathCount.js","webpack:///./~/@graphistry/falcor-path-utils/lib/pathsComplementFromLengthTree.js","webpack:///./~/@graphistry/falcor-path-utils/lib/pathsComplementFromTree.js","webpack:///./~/@graphistry/falcor-path-utils/lib/support/catAndSlice.js","webpack:///./lib/Model.js","webpack:///./lib/ModelDataSourceAdapter.js","webpack:///./lib/ModelRoot.js","webpack:///./lib/SymbolShim.js","webpack:///./lib/deref/hasValidParentReference.js","webpack:///./lib/deref/index.js","webpack:///./lib/errors/BoundJSONGraphModelError.js","webpack:///./lib/errors/InvalidDerefInputError.js","webpack:///./lib/errors/InvalidModelError.js","webpack:///./lib/get/getCache.js","webpack:///./lib/get/getValue.js","webpack:///./lib/get/getVersion.js","webpack:///./lib/get/json/getJSON.js","webpack:///./lib/get/json/getReferenceTarget.js","webpack:///./lib/get/json/onError.js","webpack:///./lib/get/json/onValue.js","webpack:///./lib/get/json/walkPath.js","webpack:///./lib/get/jsonGraph/getJSONGraph.js","webpack:///./lib/get/jsonGraph/getReferenceTarget.js","webpack:///./lib/get/jsonGraph/onValue.js","webpack:///./lib/get/jsonGraph/walkPath.js","webpack:///./lib/get/toJSONWithHashCodes.js","webpack:///./lib/invalidate/invalidatePathMaps.js","webpack:///./lib/invalidate/invalidatePathSets.js","webpack:///./lib/request/GetRequest.js","webpack:///./lib/request/RequestQueue.js","webpack:///./lib/request/complement.js","webpack:///./lib/request/flushGetRequest.js","webpack:///./lib/request/sendSetRequest.js","webpack:///./lib/response/CallResponse.js","webpack:///./lib/response/InvalidateResponse.js","webpack:///./lib/response/get/getRequestCycle.js","webpack:///./lib/response/get/index.js","webpack:///./lib/response/get/mergeInto.js","webpack:///./lib/response/set/index.js","webpack:///./lib/response/set/setGroupsIntoCache.js","webpack:///./lib/response/set/setRequestCycle.js","webpack:///./lib/response/set/setValidInput.js","webpack:///./lib/schedulers/ImmediateScheduler.js","webpack:///./lib/schedulers/TimeoutScheduler.js","webpack:///./lib/set/setValue.js","webpack:///./lib/support/array-flat-map.js","webpack:///./lib/support/clone.js","webpack:///./lib/support/getExpires.js","webpack:///./lib/support/getType.js","webpack:///./lib/support/isAlreadyExpired.js","webpack:///./lib/support/isInternalKey.js","webpack:///./lib/support/mergeJSONGraphNode.js","webpack:///./lib/support/transferBackReferences.js","webpack:///./lib/support/unlinkBackReferences.js","webpack:///./lib/support/unlinkForwardReference.js","webpack:///./lib/toEsObservable.js","webpack:///./~/process/browser.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","o","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","module.exports","objTypeof","func","Boolean","functionTypeof","now","$now","$never","node","exp","Promise","ModelResponse","subscribe","_subscribe","noop","Symbol","toEsObservable","ModelResponse.prototype._toJSONG","ModelResponse.prototype.progressively","ModelResponse.prototype.forEach","a","b","observer","onNext","bind","onError","onCompleted","subscription","dispose","unsubscribe","ModelResponse.prototype.then","self","resolve","reject","rejected","values","errors","splice","expired","lru","isObject","iterateKeySet","toTree","toTreeWithUnion","pathsComplementFromTree","pathsComplementFromLengthTree","hasIntersection","toPaths","collapse","optimizePathSets","pathCount","InvalidSourceError","error","err","Error","MESSAGE","NAME","stack","message","innerError","InvalidSourceError.is","e","getCachePosition","getBoundCacheNode","model","path","undefined","__ref","from","to","backRefs","NullInPathError","unicodePrefix","clone","key","keys","json","index","length","EXPIRES_NEVER","head","prev","next","hasOwn","obj","prop","removeNode","updateBackReferenceVersions","nodeArg","offset","version","child","setJSONGraphPathSet","depth","parent","messageRoot","messageParent","requestedPaths","optimizedPaths","requestedPath","optimizedPath","comparator","errorSelector","note","branch","keySet","optimizedIndex","results","setNode","nextNode","nextParent","nextOptimizedPath","reference","type","$ref","isExpired","expireNode","container","count","isPrimitive","createHardlink","arr","mergeJSONGraphNode","Array","isFunction","jsonGraphEnvelopes","modelRoot","cache","initialVersion","jsonGraphEnvelopeIndex","jsonGraphEnvelopeCount","jsonGraphEnvelope","paths","jsonGraph","pathIndex","newVersion","rootChangeHandler","envelope","isArray","pathValue","tree","keyset","keysetIndex","keysetLength","nextDepth","keyIsRange","rangeEnd","keysOrRanges","nullTerminator","nextKey","$__null__$","getWithPathsAsPathMap","getWithPathsAsJSONGraph","inlineJSONGraphValue","seed","curr","updateNodeAncestors","totalArg","max","ratioArg","ratio","shouldUpdate","targetSize","size","total","setPathMap","pathMap","itr","__prefix","keyIndex","keyCount","mergeValueOrInsertBranch","pathMapEnvelopes","bound","pathMapIndex","pathMapCount","pathMapEnvelope","setPathSet","pathValues","pathValueIndex","pathValueCount","Date","unlinkBackReferences","unlinkForwardReference","prefix","removeNodeAndDescendants","key2","isPathValue","isJSONGraphEnvelope","isJSONEnvelope","args","allowedInput","method","len","arg","valid","String","initializeRange","memo","rangeOffset","loaded","empty","done","arrayOffset","nextValue","el","cloneArray","$atom","$error","collapsePathMap","pathmap","code","getHashCode","subs","create","codes","codesIndex","codesCount","pathsets","pathsetsCount","subPath","subCode","subKeys","subKeysIndex","subKeysCount","pathsetClone","getSortedKeys","sets","isNumber","push","parseInt","subSets","subSetsIndex","subSetsCount","firstSubKey","pathset","pathsetIndex","pathsetCount","sortListAscending","map","sort","charCodeAt","val","parseFloat","lengths","allPaths","allPathsLength","typeOfObject","pathsIndex","pathsCount","keysetCount","isSparseRange","innerToTree","reduce","acc","CircularReferenceError","referencePath","JSON","InvalidKeySetError","InvalidKeySetError.is","MaxRetryExceededError","MaxRetryExceededError.is","maxDepth","onMissing","requestedLength","optimizedLength","restPathIndex","restPathCount","restPath","isEmptyKeySet","lastKeyIsNull","missDepth","missTotal","missingPath","missingPaths","isRequestedPath","mPath","Number","promote","onValueType","fromReference","boxValues","materialized","hasDataSource","treatErrorsAsValues","onValue","$type","GetRequest","AssignableDisposable","disosableCallback","disposed","currentDisposable","checkCacheAndReport","getRequestCycle","collectLru","getSize","__version","GetResponse","isJSONGraph","isProgressive","forceCollect","initialCacheVersion","currentRemainingPaths","currentVersion","GetResponse.prototype._toJSONG","GetResponse.prototype.progressively","GetResponse.prototype._subscribe","isJSONG","modelCache","rootOnChangesCompletedHandler","gets","mergeInto","progressive","originalSeed","isSeedImmutable","hasValues","valueNode","hasValueOverall","completed","errs","errorsLength","jsonGraphPaths","pathSyntax","setRequestCycle","SetResponse","_model","_isJSONGraph","_isProgressive","_initialArgs","_value","groups","group","groupType","argIndex","argCount","argType","inputType","arguments","_groups","SetResponse.prototype._subscribe","SetResponse.prototype._toJSONG","SetResponse.prototype.progressively","getType","getTimestamp","wrapNode","insertNode","replaceNode","reconstructPath","mType","isDistinct","sizeOffset","currentPath","transferBackReferences","replacement","expiresNow","getExpires","atomType","typeArg","modelCreated","ツprev","ツnext","ツmodelCreated","atomSize","expires","process","global","useNextTick","nextTick","flush","useVertxTimer","vertxNext","useMutationObserver","iterations","BrowserMutationObserver","document","createTextNode","observe","characterData","data","useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","useSetTimeout","globalSetTimeout","setTimeout","queue","callback","attemptVertx","vertx","runOnLoop","runOnContext","then","onFulfillment","onRejection","_arguments","constructor","PROMISE_ID","makePromise","_state","asap","invokeCallback","_result","Constructor","promise","_resolve","getThen","GET_THEN_ERROR","tryThen","fulfillmentHandler","rejectionHandler","handleForeignThenable","thenable","sealed","fulfill","reason","_reject","_label","handleOwnThenable","FULFILLED","REJECTED","handleMaybeThenable","maybeThenable","then$$","TypeError","publishRejection","_onerror","publish","PENDING","_subscribers","subscribers","settled","detail","ErrorObject","hasCallback","succeeded","failed","TRY_CATCH_ERROR","initializePromise","resolver","resolvePromise","rejectPromise","id","Enumerator","input","_instanceConstructor","_input","_remaining","_enumerate","polyfill","local","Function","P","promiseToString","toString","cast","_isArray","x","customSchedulerFn","scheduleFlush","browserGlobal","browserWindow","window","MutationObserver","WebKitMutationObserver","isNode","isWorker","Uint8ClampedArray","importScripts","Math","random","substring","Enumerator.prototype._enumerate","_eachEntry","Enumerator.prototype._eachEntry","entry","resolve$$","_then","_settledAt","_willSettleAt","Enumerator.prototype._settledAt","state","Enumerator.prototype._willSettleAt","enumerator","all","entries","race","_","_setScheduler","setScheduler","scheduleFn","_setAsap","setAsap","asapFn","_asap","_catch","g","eval","falcor","opts","Model","collapseMap","forEach","collapseKey","innerReferences","circularReference","cacheRoot","ref","maxRefFollow","current","refPath","referenceCount","throwToNext","optimizePathSet","pathSet","out","catAndSlice","iteratorNote","nextOptimized","optimizedPathLength","refResults","followReference","$types","optimized","getRangeOrKeySize","rangeOrKey","stringify","isNaN","getPathCount","numPaths","segment","numKeys","j","outLength","slice","options","_root","ModelRoot","_path","_source","_request","RequestQueue","ImmediateScheduler","_maxSize","_collectRatio","_boxed","_materialized","_treatErrorsAsValues","_allowFromWhenceYouCame","setCache","ModelDataSourceAdapter","CallResponse","InvalidateResponse","TimeoutScheduler","setJSONGraphs","validateInput","noOp","getCache","GET_VALID_INPUT","Model.prototype.preload","obs","Model.prototype.call","argsIdx","argsLen","Model.prototype.invalidate","Model.prototype.setCache","cacheOrJSONGraphEnvelope","boundPath","Model.prototype.getCache","result","Model.prototype.getVersion","concat","_getVersion","Model.prototype._syncCheck","syncRefCount","unsafeMode","Model.prototype._clone","Model.prototype.batch","schedulerOrDelay","scheduler","scheudle","_clone","Model.prototype.unbatch","Model.prototype.treatErrorsAsValues","Model.prototype.asDataSource","Model.prototype._materialize","Model.prototype._dematerialize","Model.prototype.boxValues","Model.prototype.unboxValues","Model.prototype.withoutDataSource","Model.prototype.toJSON","Model.prototype.getPath","Model.prototype._fromWhenceYouCame","allow","ModelDataSourceAdapter.prototype.get","pathSets","apply","_toJSONG","ModelDataSourceAdapter.prototype.set","jsongResponse","set","ModelDataSourceAdapter.prototype.call","suffixes","params","topLevelModel","branchSelector","toJSONWithHashCodes","onChange","onChangesCompleted","ModelRoot.prototype.errorSelector","y","ModelRoot.prototype.comparator","cacheNode","messageNode","ensureSymbol","root.Symbol","description","_id","symbolForPolyfill","objectTypes","freeGlobal","polyfillSymbol","hasValidParentReference","_referenceContainer","InvalidDerefInputError","boundJSONArg","referenceContainer","currentRefPath","absolutePath","originalRefPath","toReference","validContainer","CONTAINER_DOES_NOT_EXIST","_node","BoundJSONGraphModelError","InvalidModelError","shortedPath","_copyCache","fromKey","k","isInternalKey","cacheNext","outNext","isUserCreatedcacheNext","clonedValue","boxedValue","pathIdx","pathLen","walkPathAndBuildOutput","getJSON","criticalError","allowFromWhenceYouCame","getReferenceTarget","context","copy","errorPath","errorValue","onJSONValue","refTarget","nextJSON","nextReferenceContainer","nextOptimizedLength","optimizedLengthNext","iteratingKeyset","getJSONGraph","inlineValue","onJSONGraphValue","computeHashCodeForKeys","str","hash","nodeKey","nodePath","nodeVersion","requestedDepth","pathToReference","__proto__","JSONProto","$__key","$__path","$__version","$__keysPath","$__keyDepth","$__name","$__hash","$__hash__$","arrayProtoMethods","jsonProto","methodName","writable","invalidatePathMap","invalidateNode","invalidatePathSet","createDisposable","request","idx","flattenRequestedPaths","requested","outLen","innerLen","interopDisposable","disposable","complement","flushGetRequest","REQUEST_ID","GetRequestType","setPathValues","emptyArray","requestQueue","scheduled","sent","_scheduler","_pathMap","_optimizedPaths","_requestedPaths","_callbacks","_count","_collapsed","_disposable","_disposed","batch","oPaths","rPaths","callbacks","flushedDisposable","scheduleDisposable","fn","add","complementTuple","requestedComplement","optimizedComplement","inserted","_merge","nextPaths","requests","_requests","RequestTypes","sendSetRequest","cb","refCountCallback","disposables","rRemainingPaths","oRemainingPaths","removeRequest","requestedIntersection","intersectionLength","complementLength","intersectionFound","subTree","pathUtils","listOfPaths","listIdx","listLen","listKeys","pathSetsByLength","pathMapKeys","pathMapIdx","pathMapLen","pathMapKey","collapsedPaths","jsonGraphData","getRequest","emptyDisposable","originalJsonGraph","resultingJsonGraphEnvelope","setObservable","successfulPaths","dataSourceError","callPath","suffix","CallResponse.prototype._subscribe","callArgs","extraPaths","rootModel","boundCallPath","response","res","invalidations","InvalidateResponse.prototype.progressively","InvalidateResponse.prototype._toJSONG","InvalidateResponse.prototype._subscribe","operationFunc","fastCat","arr1","arr2","getResponse","requestedMissingPaths","optimizedMissingPaths","boundRequestedMissingPaths","currentRequestDisposable","nextResults","dest","destValue","nodeValue","$__refPath","$__toReference","setValidInput","pluckPath","pluckEnvelopePaths","arrayFlatMap","groupIndex","groupCount","returnValue","methodArgs","subscribeToFollowupGet","setGroupsIntoCache","requestedAndOptimizedPaths","currentJSONGraph","requestDisposable","jsonGraphEnv","isCompleted","ImmediateScheduler.prototype.schedule","action","delay","TimerDisposable","TimeoutScheduler.prototype.schedule","TimerDisposable.prototype.dispose","clearTimeout","pathArg","valueArg","array","selector","array2","array3","src","anyType","cType","cIsObject","mIsObject","cTimestamp","mTimestamp","fromNode","destNode","fromNodeRefsLength","destNodeRefsLength","destination","FromEsObserverAdapter","esObserver","ToEsSubscriptionAdapter","complete","ToEsSubscriptionAdapter.prototype.unsubscribe","_self","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","run","Item","process.nextTick","Item.prototype.run","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","process.binding","cwd","process.cwd","chdir","process.chdir","dir","umask","process.umask"],"mappings":"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","file":"falcor.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * \n * Copyright 2015 Netflix, Inc\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"falcor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"falcor\"] = factory();\n\telse\n\t\troot[\"falcor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 131);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\nvar objTypeof = \"object\";\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = \"ref\";\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\nvar functionTypeof = \"function\";\n\nmodule.exports = function isFunction(func) {\n    return Boolean(func) && typeof func === functionTypeof;\n};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(34);\nvar $now = __webpack_require__(39);\nvar $never = __webpack_require__(38);\n\nmodule.exports = function isExpired(node) {\n    var exp = node.$expires;\n    return exp != null && exp !== $never && (exp === $now || exp < now());\n};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Promise) {var noop = __webpack_require__(24);\nvar Symbol = __webpack_require__(80);\nvar toEsObservable = __webpack_require__(128);\n\n/**\n * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.\n * @constructor ModelResponse\n * @augments Observable\n*/\nfunction ModelResponse(subscribe) {\n    this._subscribe = subscribe;\n}\n\nModelResponse.prototype[Symbol.observable] = function SymbolObservable() {\n    return toEsObservable(this);\n};\n\nModelResponse.prototype._toJSONG = function toJSONG() {\n    return this;\n};\n\n/**\n * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.\n * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.\n * @name progressively\n * @memberof ModelResponse.prototype\n * @function\n * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.\n * @example\nvar dataSource = (new falcor.Model({\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\",\n      age: 31\n    }\n  }\n})).asDataSource();\n\nvar model = new falcor.Model({\n  source: dataSource,\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n  }\n});\n\nmodel.\n  get([\"user\",[\"name\", \"surname\", \"age\"]]).\n  progressively().\n  // this callback will be invoked twice, once with the data in the\n  // Model cache, and again with the additional data retrieved from the DataSource.\n  subscribe(function(json){\n    console.log(JSON.stringify(json,null,4));\n  });\n\n// prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\"\n//         }\n//     }\n// }\n// ...and then prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\",\n//             \"age\": 31\n//         }\n//     }\n// }\n*/\nModelResponse.prototype.progressively = function progressively() {\n    return this;\n};\n\nModelResponse.prototype.subscribe = ModelResponse.prototype.forEach = function subscribe(a, b, c) {\n    var observer = a;\n    if (observer && typeof observer === \"object\") {\n        if (!(observer.onNext || observer.onError || observer.onCompleted)) {\n            observer = {\n                onNext: (observer.next || noop).bind(observer),\n                onError: (observer.error || noop).bind(observer),\n                onCompleted: (observer.complete || noop).bind(observer)\n            };\n        }\n    } else {\n        observer = {\n            onNext: a || noop,\n            onError: b || noop,\n            onCompleted: c || noop\n        };\n    }\n    var subscription = this._subscribe(observer);\n    switch (typeof subscription) {\n        case \"function\":\n            return { dispose: subscription, unsubscribe: subscription };\n        case \"object\":\n            return subscription || { dispose: noop, unsubscribe: noop };\n        default:\n            return { dispose: noop, unsubscribe: noop };\n    }\n};\n\nModelResponse.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var self = this;\n    if (!self._promise) {\n        self._promise = new Promise(function (resolve, reject) {\n            var rejected = false;\n            var values = [];\n            self.subscribe(function (value) {\n                values[values.length] = value;\n            }, function (errors) {\n                rejected = true;\n                reject(errors);\n            }, function () {\n                var value = values;\n                if (values.length <= 1) {\n                    value = values[0];\n                }\n\n                if (rejected === false) {\n                    resolve(value);\n                }\n            });\n        });\n    }\n    return self._promise.then(onNext, onError);\n};\n\nmodule.exports = ModelResponse;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(65)))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = \"ツ\";\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar splice = __webpack_require__(51);\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node.ツinvalidated) {\n        node.ツinvalidated = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n    iterateKeySet: __webpack_require__(40),\n    toTree: __webpack_require__(44),\n    toTreeWithUnion: __webpack_require__(76),\n    pathsComplementFromTree: __webpack_require__(74),\n    pathsComplementFromLengthTree: __webpack_require__(73),\n    hasIntersection: __webpack_require__(26),\n    toPaths: __webpack_require__(43),\n    collapse: __webpack_require__(68),\n    optimizePathSets: __webpack_require__(71),\n    pathCount: __webpack_require__(72)\n};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\nvar objTypeof = \"object\";\nmodule.exports = function isPrimitive(value) {\n    return value == null || typeof value !== objTypeof;\n};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidSourceError\";\nvar MESSAGE = \"An exception was thrown when making a request.\";\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidSourceError(error) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.innerError = error;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidSourceError.prototype = Object.create(Error.prototype);\nInvalidSourceError.prototype.name = NAME;\nInvalidSourceError.is = function (e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidSourceError;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getCachePosition = __webpack_require__(48);\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node.ツparent === undefined || node.ツinvalidated) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(5) + \"ref\";\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __ref = __webpack_require__(12);\n\nmodule.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to.ツrefsLength || 0;\n    to[__ref + backRefs] = from;\n    to.ツrefsLength = backRefs + 1;\n\n    // create a hard reference\n    from.ツrefIndex = backRefs;\n    from.ツcontext = to;\n};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nvar NAME = \"NullInPathError\";\nvar MESSAGE = \"`null` is not allowed in branch key positions.\";\n\n/**\n * Does not allow null in path\n */\nfunction NullInPathError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nNullInPathError.prototype = Object.create(Error.prototype);\nNullInPathError.prototype.name = NAME;\nNullInPathError.message = MESSAGE;\n\nmodule.exports = NullInPathError;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar unicodePrefix = __webpack_require__(5);\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key,\n        keys = Object.keys(node),\n        json = {},\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (key.charAt(0) === unicodePrefix) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EXPIRES_NEVER = __webpack_require__(38);\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root.ツhead;\n\n    // Nothing is in the cache.\n    if (!head) {\n        root.ツhead = root.ツtail = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object.ツprev;\n    var next = object.ツnext;\n    if (next) {\n        next.ツprev = prev;\n    }\n    if (prev) {\n        prev.ツnext = next;\n    }\n    object.ツprev = undefined;\n\n    // Insert into head position\n    root.ツhead = object;\n    object.ツnext = head;\n    head.ツprev = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root.ツtail) {\n        root.ツtail = prev;\n    }\n};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (obj, prop) {\n  return isObject(obj) && hasOwn.call(obj, prop);\n};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(35);\nvar updateBackReferenceVersions = __webpack_require__(63);\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child.ツparent;\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child.ツkey, lru);\n        } else if (child.ツversion !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = \"error\";\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(5) + \"version\";\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(5);\nvar $ref = __webpack_require__(1);\nvar createHardlink = __webpack_require__(13);\nvar isExpired = __webpack_require__(122);\nvar isFunction = __webpack_require__(2);\nvar isPrimitive = __webpack_require__(9);\nvar expireNode = __webpack_require__(6);\nvar iterateKeySet = __webpack_require__(8).iterateKeySet;\nvar mergeJSONGraphNode = __webpack_require__(124);\nvar NullInPathError = __webpack_require__(14);\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var initialVersion = cache.ツversion;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, results[3], results[2], requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n            node = results[0];\n            optimizedPath = results[4];\n            if (isPrimitive(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container.ツcontext !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, messageRoot, messageParent, message, key, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node.ツkey;\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && \"json\" in envelope;\n};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(0);\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (isArray(pathValue.path) || typeof pathValue.path === \"string\");\n};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nmodule.exports = function noop() {};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\nmodule.exports = \"atom\";\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar nullTerminator = __webpack_require__(27);\n\nmodule.exports = hasIntersection\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === nullTerminator;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\nmodule.exports = { $__null__$: null };\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n    getWithPathsAsPathMap: __webpack_require__(89),\n    getWithPathsAsJSONGraph: __webpack_require__(94)\n};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\nmodule.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed) {\n\n    var key,\n        depth = 0,\n        prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        curr = {};\n        seed.jsonGraph = curr;\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = node;\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNode = __webpack_require__(35);\nvar updateNodeAncestors = __webpack_require__(18);\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node.ツparent) {\n            // eslint-disable-line no-cond-assign\n            removeNode(node, parent, node.ツkey, lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru.ツtail;\n        node = prev;\n        while (total >= targetSize && node) {\n            prev = prev.ツprev;\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru.ツtail = lru.ツprev = node;\n        if (node == null) {\n            lru.ツhead = lru.ツnext = undefined;\n        } else {\n            node.ツnext = undefined;\n        }\n    }\n};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isArray = Array.isArray;\nvar $ref = __webpack_require__(1);\nvar __prefix = __webpack_require__(5);\nvar createHardlink = __webpack_require__(13);\nvar getBoundCacheNode = __webpack_require__(11);\nvar hasOwn = __webpack_require__(17);\nvar isObject = __webpack_require__(0);\nvar isExpired = __webpack_require__(3);\nvar isFunction = __webpack_require__(2);\nvar isPrimitive = __webpack_require__(9);\nvar expireNode = __webpack_require__(6);\nvar mergeValueOrInsertBranch = __webpack_require__(60);\nvar NullInPathError = __webpack_require__(14);\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector);\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node.ツcontext;\n\n        if (node != null) {\n            parent = node.ツparent || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                node = results[0];\n                optimizedPath = results[2];\n                if (isPrimitive(node)) {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container.ツcontext !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (type === void 0) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node.ツkey;\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (isObject(pathMap) && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === __prefix || key[0] === \"$\" || !hasOwn(pathMap, key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar $ref = __webpack_require__(1);\nvar createHardlink = __webpack_require__(13);\nvar getBoundCacheNode = __webpack_require__(11);\nvar isExpired = __webpack_require__(3);\nvar isFunction = __webpack_require__(2);\nvar isPrimitive = __webpack_require__(9);\nvar expireNode = __webpack_require__(6);\nvar iterateKeySet = __webpack_require__(8).iterateKeySet;\nvar mergeValueOrInsertBranch = __webpack_require__(60);\nvar NullInPathError = __webpack_require__(14);\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node.ツcontext;\n\n        if (node != null) {\n            parent = node.ツparent || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                node = results[0];\n                optimizedPath = results[2];\n                if (isPrimitive(node)) {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container.ツcontext !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node.ツkey;\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(0);\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));\n};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\nmodule.exports = Date.now;\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(1);\nvar splice = __webpack_require__(51);\nvar isObject = __webpack_require__(0);\nvar unlinkBackReferences = __webpack_require__(126);\nvar unlinkForwardReference = __webpack_require__(127);\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (isObject(node)) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            splice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node.ツparent = void 0;\n        return true;\n    }\n    return false;\n};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar hasOwn = __webpack_require__(17);\nvar prefix = __webpack_require__(5);\nvar removeNode = __webpack_require__(35);\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (key2[0] !== prefix && key2[0] !== \"$\" && hasOwn(node, key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isPathValue = __webpack_require__(23);\nvar isJSONGraphEnvelope = __webpack_require__(33);\nvar isJSONEnvelope = __webpack_require__(22);\n\n/**\n *\n * @param {Object} allowedInput - allowedInput is a map of input styles\n * that are allowed\n * @private\n */\nmodule.exports = function validateInput(args, allowedInput, method) {\n    for (var i = 0, len = args.length; i < len; ++i) {\n        var arg = args[i];\n        var valid = false;\n\n        // Path\n        if (isArray(arg) && allowedInput.path) {\n            valid = true;\n        }\n\n        // Path Syntax\n        // else if (typeof arg === \"string\" && allowedInput.pathSyntax) {\n        //     valid = true;\n        // }\n\n        // Path Value\n        else if (isPathValue(arg) && allowedInput.pathValue) {\n                valid = true;\n            }\n\n            // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}\n            else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {\n                    valid = true;\n                }\n\n                // json env {json: {...}}\n                else if (isJSONEnvelope(arg) && allowedInput.json) {\n                        valid = true;\n                    }\n\n                    // selector functions\n                    else if (typeof arg === \"function\" && i + 1 === len && allowedInput.selector) {\n                            valid = true;\n                        }\n\n        if (!valid) {\n            return new Error(\"Unrecognized argument \" + typeof arg + \" [\" + String(arg) + \"] \" + \"to Model#\" + method + \"\");\n        }\n    }\n    return true;\n};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\nmodule.exports = 1;\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\nmodule.exports = 0;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\nfunction cloneArray(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nmodule.exports = cloneArray;\n\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n    $ref: 'ref',\n    $atom: 'atom',\n    $error: 'error'\n};\n\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeOfObject = \"object\";\nvar nullTerminator = __webpack_require__(27);\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var code = getHashCode(String(depth));\n    var subs = Object.create(null);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = getHashCode(code + key + subCode);\n\n            isNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === nullTerminator) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            // if (key === '$__null__$') {\n            //     key = null;\n            // }\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\nfunction getHashCode(key) {\n    var code = 5381;\n    var index = -1;\n    var count = key.length;\n    while (++index < count) {\n        code = (code << 5) + code + key.charCodeAt(index);\n    }\n    return String(code);\n}\n\n/**\n * Return true if argument is a number or can be cast to a number\n * @private\n */\nfunction isNumber(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar nullTerminator = __webpack_require__(27);\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\nmodule.exports = function toTree(paths) {\n    return paths.reduce(function(acc, path) {\n        return innerToTree(acc, path, 0, path.length);\n    }, {});\n};\n\nfunction innerToTree(seed, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullTerminator;\n    }\n\n    seed = seed || {};\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = null;\n            } else {\n                node = seed[nextKey];\n                next = innerToTree(node, path, nextDepth, length);\n                if (!next) {\n                    seed[nextKey] = null;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\nvar NAME = \"CircularReferenceError\";\n\n/**\n * Does not allow null in path\n */\nfunction CircularReferenceError(referencePath) {\n    var err = Error.call(this, \"Encountered circular reference \" + JSON.stringify(referencePath));\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nCircularReferenceError.prototype = Object.create(Error.prototype);\nCircularReferenceError.prototype.name = NAME;\n\nmodule.exports = CircularReferenceError;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidKeySetError\";\nvar MESSAGE = \"Keysets can only contain Keys or Ranges\";\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidKeySetError(path, keysOrRanges) {\n    var err = Error.call(this, \"The KeySet \" + JSON.stringify(keysOrRanges) + \" in path \" + JSON.stringify(path) + \" contains a KeySet. \" + MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidKeySetError.prototype = Object.create(Error.prototype);\nInvalidKeySetError.prototype.name = NAME;\nInvalidKeySetError.is = function (e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidKeySetError;\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\nvar NAME = \"MaxRetryExceededError\";\nvar MESSAGE = \"The allowed number of retries have been exceeded.\";\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nfunction MaxRetryExceededError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nMaxRetryExceededError.prototype = Object.create(Error.prototype);\nMaxRetryExceededError.prototype.name = NAME;\nMaxRetryExceededError.is = function (e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = MaxRetryExceededError;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(1);\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type,\n        depth = 0;\n    var maxDepth = path.length;\n\n    do {\n        node = node[path[depth]];\n\n        while (node && (type = node.$type) === $ref) {\n            node = getCachePosition(cache, node.value);\n        }\n    } while (++depth < maxDepth && node && !type);\n\n    return node;\n};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results, requestedPath, requestedLength, optimizedPath, optimizedLength) {\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var lastKeyIsNull = keyset === null;\n    var missDepth = depth,\n        missTotal = requestedLength,\n        missingPath = requestedPath,\n        missingPaths = results.requestedMissingPaths || (results.requestedMissingPaths = []);\n\n    var isRequestedPath = true,\n        index,\n        count,\n        mPath;\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n            missingPaths.push(mPath);\n        } else {\n            missingPaths.push(restPath);\n        }\n\n        isRequestedPath = !isRequestedPath;\n\n        if (isRequestedPath) {\n            break;\n        }\n\n        missDepth = optimizedLength;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n        missingPath = optimizedPath;\n        missingPaths = results.optimizedMissingPaths || (results.optimizedMissingPaths = []);\n    } while (true);\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if (\"object\" !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if (\"number\" !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $atom = __webpack_require__(25);\nvar promote = __webpack_require__(16);\nvar isExpired = __webpack_require__(3);\nvar expireNode = __webpack_require__(6);\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing) {\n\n    if (!node || !type) {\n        if (materialized && !hasDataSource) {\n            if (seed) {\n                results.hasValue = true;\n                return { $type: $atom };\n            }\n            return undefined;\n        } else {\n            return onMissing(path, depth, results, requestedPath, requestedLength, optimizedPath, optimizedLength);\n        }\n    } else if (isExpired(node)) {\n        if (!node.ツinvalidated) {\n            expireNode(node, expired, modelRoot);\n        }\n        return onMissing(path, depth, results, requestedPath, requestedLength, optimizedPath, optimizedLength);\n    }\n\n    promote(modelRoot, node);\n\n    if (seed) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n        }\n        return onValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues);\n    }\n\n    return undefined;\n}\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\nmodule.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object.ツprev;\n    var next = object.ツnext;\n    if (next) {\n        next.ツprev = prev;\n    }\n    if (prev) {\n        prev.ツnext = next;\n    }\n    object.ツprev = object.ツnext = undefined;\n\n    if (object === root.ツhead) {\n        root.ツhead = next;\n    }\n    if (object === root.ツtail) {\n        root.ツtail = prev;\n    }\n};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n    GetRequest: \"GET\"\n};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n/**\n * Will allow for state tracking of the current disposable.  Also fulfills the\n * disposable interface.\n * @private\n */\nvar AssignableDisposable = function AssignableDisposable(disosableCallback) {\n    this.disposed = false;\n    this.currentDisposable = disosableCallback;\n};\n\nAssignableDisposable.prototype = {\n\n    unsubscribe: function unsubscribe() {\n        return this.dispose();\n    },\n    /**\n     * Disposes of the current disposable.  This would be the getRequestCycle\n     * disposable.\n     */\n    dispose: function dispose() {\n\n        if (this.disposed || !this.currentDisposable) {\n            return;\n        }\n\n        this.disposed = true;\n\n        // If the current disposable fulfills the disposable interface or just\n        // a disposable function.\n        var currentDisposable = this.currentDisposable;\n        this.currentDisposable = null;\n\n        if (currentDisposable.dispose) {\n            currentDisposable.dispose();\n        } else if (currentDisposable.unsubscribe) {\n            currentDisposable.unsubscribe();\n        } else if (typeof currentDisposable === \"function\") {\n            currentDisposable();\n        }\n    }\n};\n\nmodule.exports = AssignableDisposable;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar ModelResponse = __webpack_require__(4);\nvar checkCacheAndReport = __webpack_require__(55);\nvar getRequestCycle = __webpack_require__(108);\nvar noop = __webpack_require__(24);\nvar empty = { dispose: noop, unsubscribe: noop };\nvar collectLru = __webpack_require__(30);\nvar getSize = __webpack_require__(7);\nvar __version = __webpack_require__(20);\nvar isFunction = __webpack_require__(2);\n\n/**\n * The get response.  It takes in a model and paths and starts\n * the request cycle.  It has been optimized for cache first requests\n * and closures.\n * @param {Model} model -\n * @param {Array} paths -\n * @augments ModelResponse\n * @private\n */\nvar GetResponse = module.exports = function GetResponse(model, paths, isJSONGraph, isProgressive, forceCollect, initialCacheVersion) {\n    this.model = model;\n    this.currentRemainingPaths = paths;\n    this.isJSONGraph = isJSONGraph || false;\n    this.isProgressive = isProgressive || false;\n    this.forceCollect = forceCollect || false;\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof initialCacheVersion === \"number\") {\n        this.initialCacheVersion = initialCacheVersion;\n    } else if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n};\n\nGetResponse.prototype = Object.create(ModelResponse.prototype);\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nGetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new GetResponse(this.model, this.currentRemainingPaths, true, this.isProgressive, this.forceCollect, this.initialCacheVersion);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nGetResponse.prototype.progressively = function progressively() {\n    return new GetResponse(this.model, this.currentRemainingPaths, this.isJSONGraph, true, this.forceCollect, this.initialCacheVersion);\n};\n\n/**\n * purely for the purposes of closure creation other than the initial\n * prototype created closure.\n *\n * @private\n */\nGetResponse.prototype._subscribe = function _subscribe(observer) {\n\n    var seed = [{}];\n    var errors = [];\n    var model = this.model;\n    var isJSONG = observer.isJSONG = this.isJSONGraph;\n    var isProgressive = this.isProgressive;\n    var results = checkCacheAndReport(model, this.currentRemainingPaths, observer, isProgressive, isJSONG, seed, errors);\n\n    // If there are no results, finish.\n    if (!results) {\n\n        var modelRoot = model._root;\n        var modelCache = modelRoot.cache;\n        var currentVersion = modelCache[__version];\n\n        if (this.forceCollect) {\n            collectLru(modelRoot, modelRoot.expired, getSize(modelCache), model._maxSize, model._collectRatio, currentVersion);\n        }\n\n        var initialCacheVersion = this.initialCacheVersion;\n        var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n        if (initialCacheVersion !== currentVersion && modelRoot.syncRefCount <= 0 && isFunction(rootOnChangesCompletedHandler)) {\n            rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n        }\n        return empty;\n    }\n\n    // Starts the async request cycle.\n    return getRequestCycle(this, model, results, observer, errors, 1, this.initialCacheVersion);\n};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar gets = __webpack_require__(28);\nvar mergeInto = __webpack_require__(110);\nvar collapse = __webpack_require__(8).collapse;\nvar getWithPathsAsPathMap = gets.getWithPathsAsPathMap;\nvar getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;\n\n/**\n * Checks cache for the paths and reports if in progressive mode.  If\n * there are missing paths then return the cache hit results.\n *\n * @param {Model} model - The model that the request was made with.\n * @param {Array} requestedMissingPaths -\n * @param {Boolean} progressive -\n * @param {Boolean} isJSONG -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @param {Object} seed - The state of the output\n * @private\n */\nmodule.exports = function checkCacheAndReport(model, requestedPaths, observer, progressive, isJSONG, seed, errors) {\n\n    var originalSeed,\n        isSeedImmutable = progressive && !isJSONG && seed;\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (isSeedImmutable) {\n        originalSeed = seed[0];\n        seed[0] = {};\n    }\n\n    // checks the cache for the data.\n    var results;\n    if (isJSONG) {\n        results = getWithPathsAsJSONGraph(model, requestedPaths, seed);\n    } else {\n        results = getWithPathsAsPathMap(model, requestedPaths, seed);\n    }\n\n    // We must communicate critical errors from get that are critical\n    // errors such as bound path is broken or this is a JSONGraph request\n    // with a bound path.\n    if (results.criticalError) {\n        observer.onError(results.criticalError);\n        return null;\n    }\n\n    var hasValues = results.hasValue;\n    var valueNode = results.values[0];\n    var hasValueOverall = Boolean(valueNode.json || valueNode.jsonGraph);\n\n    // We are done when there are no missing paths or the model does not\n    // have a dataSource to continue on fetching from.\n    var completed = !results.requestedMissingPaths || !results.requestedMissingPaths.length || !model._source;\n\n    // Copy the errors into the total errors array.\n    if (results.errors) {\n        var errs = results.errors;\n        var errorsLength = errors.length;\n        for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {\n            errors[errorsLength] = errs[i];\n        }\n    }\n\n    // If the valueNode should be immutable, merge the previous valueNode into\n    // the one that was just created.\n    if (isSeedImmutable && originalSeed) {\n        valueNode = mergeInto(valueNode, originalSeed);\n    }\n\n    // If there are values to report, then report.\n    // Which are under two conditions:\n    // 1.  This request for data yielded at least one value (hasValue) and  the\n    // request is progressive\n    //\n    // 2.  The request if finished and the json key off\n    // the valueNode has a value.\n    if (hasValues && progressive || hasValueOverall && completed) {\n        try {\n            if (isJSONG && valueNode) {\n                var jsonGraphPaths = valueNode.paths;\n                if (jsonGraphPaths && jsonGraphPaths.length > 0) {\n                    valueNode.paths = collapse(jsonGraphPaths);\n                }\n            }\n            ++model._root.syncRefCount;\n            observer.onNext(valueNode);\n        } catch (e) {\n            throw e;\n        } finally {\n            --model._root.syncRefCount;\n        }\n    }\n\n    // if there are missing paths, then lets return them.\n    if (completed) {\n        if (errors.length) {\n            observer.onError(errors);\n        } else {\n            observer.onCompleted();\n        }\n\n        return null;\n    }\n\n    // Return the results object.\n    return results;\n};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n    path: true,\n    pathSyntax: true\n};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar ModelResponse = __webpack_require__(4);\nvar isArray = Array.isArray;\nvar isPathValue = __webpack_require__(23);\nvar isJSONGraphEnvelope = __webpack_require__(33);\nvar isJSONEnvelope = __webpack_require__(22);\nvar setRequestCycle = __webpack_require__(113);\nvar __version = __webpack_require__(20);\n\n/**\n *  The set response is responsible for doing the request loop for the set\n * operation and subscribing to the follow up get.\n *\n * The constructors job is to parse out the arguments and put them in their\n * groups.  The following subscribe will do the actual cache set and dataSource\n * operation remoting.\n *\n * @param {Model} model -\n * @param {Array} args - The array of arguments that can be JSONGraph, JSON, or\n * pathValues.\n * @param {Boolean} isJSONGraph - if the request is a jsonGraph output format.\n * @param {Boolean} isProgressive - progressive output.\n * @augments ModelResponse\n * @private\n */\nvar SetResponse = module.exports = function SetResponse(model, args, isJSONGraph, isProgressive, initialCacheVersion) {\n\n    // The response properties.\n    this._model = model;\n    this._isJSONGraph = isJSONGraph || false;\n    this._isProgressive = isProgressive || false;\n    this._initialArgs = args;\n    this._value = [{}];\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof initialCacheVersion === \"number\") {\n        this.initialCacheVersion = initialCacheVersion;\n    } else if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg)) {\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = \"JSONGs\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n};\n\nSetResponse.prototype = Object.create(ModelResponse.prototype);\n\n/**\n * The subscribe function will setup the remoting of the operation and cache\n * setting.\n *\n * @private\n */\nSetResponse.prototype._subscribe = function _subscribe(observer) {\n    var groups = this._groups;\n    var model = this._model;\n    var isJSONGraph = this._isJSONGraph;\n    var isProgressive = this._isProgressive;\n\n    // Starts the async request cycle.\n    return setRequestCycle(model, observer, groups, isJSONGraph, isProgressive, 0, this.initialCacheVersion);\n};\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nSetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new SetResponse(this._model, this._initialArgs, true, this._isProgressive, this.initialCacheVersion);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nSetResponse.prototype.progressively = function progressively() {\n    return new SetResponse(this._model, this._initialArgs, this._isJSONGraph, true, this.initialCacheVersion);\n};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\nmodule.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node.ツkey = key;\n    node.ツparent = parent;\n\n    if (version !== undefined) {\n        node.ツversion = version;\n    }\n    if (!node.ツabsolutePath) {\n        node.ツabsolutePath = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(1);\nvar $error = __webpack_require__(19);\nvar getType = __webpack_require__(121);\nvar getSize = __webpack_require__(7);\nvar getTimestamp = __webpack_require__(58);\n\nvar isExpired = __webpack_require__(3);\nvar isPrimitive = __webpack_require__(9);\nvar isFunction = __webpack_require__(2);\n\nvar wrapNode = __webpack_require__(64);\nvar expireNode = __webpack_require__(6);\nvar insertNode = __webpack_require__(59);\nvar replaceNode = __webpack_require__(62);\nvar updateNodeAncestors = __webpack_require__(18);\nvar reconstructPath = __webpack_require__(61);\n\nmodule.exports = function mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node)) {\n            type = \"expired\";\n            expireNode(node, expired, lru);\n        }\n        if (type && type !== $ref || isPrimitive(node)) {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && isFunction(comparator)) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (mType === $error && isFunction(errorSelector)) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize(node) - getSize(message);\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n  var path = currentPath.slice(0, currentPath.depth);\n  path[path.length] = key;\n\n  return path;\n};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\nvar transferBackReferences = __webpack_require__(125);\nvar removeNodeAndDescendants = __webpack_require__(36);\nvar updateBackReferenceVersions = __webpack_require__(63);\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (isObject(node)) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __ref = __webpack_require__(12);\n\nmodule.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        if (node && node.ツversion !== version) {\n            node.ツversion = version;\n            stack[count++] = node.ツparent;\n            var i = -1;\n            var n = node.ツrefsLength || 0;\n            while (++i < n) {\n                stack[count++] = node[__ref + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(34);\nvar expiresNow = __webpack_require__(39);\n\nvar atomSize = 50;\n\nvar clone = __webpack_require__(119);\nvar isArray = Array.isArray;\nvar getSize = __webpack_require__(7);\nvar getExpires = __webpack_require__(120);\nvar atomType = __webpack_require__(25);\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node.ツmodelCreated;\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node.ツprev = undefined;\n        node.ツnext = undefined;\n        node.ツmodelCreated = modelCreated || false;\n    } else {\n        node = {\n            $type: atomType,\n            value: value,\n            ツprev: undefined,\n            ツnext: undefined,\n            ツmodelCreated: true\n        };\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + expires * -1;\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process, Promise, global) {var require;/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   3.3.0\n */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  return typeof x === 'function' || typeof x === 'object' && x !== null;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (!Array.isArray) {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n} else {\n  _isArray = Array.isArray;\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  return function () {\n    vertxNext(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = __webpack_require__(130);\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  _resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        _resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      _reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      _reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    _reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return _resolve(promise, value);\n    }, function (reason) {\n      return _reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$) {\n  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$ === GET_THEN_ERROR) {\n      _reject(promise, GET_THEN_ERROR.error);\n    } else if (then$$ === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$)) {\n      handleForeignThenable(promise, maybeThenable, then$$);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction _resolve(promise, value) {\n  if (promise === value) {\n    _reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction _reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      _reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      _resolve(promise, value);\n    } else if (failed) {\n      _reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      _reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      _resolve(promise, value);\n    }, function rejectPromise(reason) {\n      _reject(promise, reason);\n    });\n  } catch (e) {\n    _reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this._input = input;\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate();\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    _reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n};\n\nEnumerator.prototype._enumerate = function () {\n  var length = this.length;\n  var _input = this._input;\n\n  for (var i = 0; this._state === PENDING && i < length; i++) {\n    this._eachEntry(_input[i], i);\n  }\n};\n\nEnumerator.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$ = c.resolve;\n\n  if (resolve$$ === resolve) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$) {\n        return resolve$$(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$(entry), i);\n  }\n};\n\nEnumerator.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      _reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  _reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = resolve;\nPromise.reject = reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\nPromise.prototype = {\n  constructor: Promise,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nfunction polyfill() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise;\n}\n\npolyfill();\n// Strange compat..\nPromise.polyfill = polyfill;\nPromise.Promise = Promise;\n\nreturn Promise;\n\n})));\n//# sourceMappingURL=es6-promise.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129), __webpack_require__(65), __webpack_require__(66)))\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar Model = __webpack_require__(77);\n\nfunction falcor(opts) {\n    return new Model(opts);\n}\n\nfalcor.Model = Model;\n\nmodule.exports = falcor;\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar toPaths = __webpack_require__(43);\nvar toTree = __webpack_require__(44);\n\nmodule.exports = function collapse(paths) {\n    var collapseMap = paths.\n        reduce(function(acc, path) {\n            var len = path.length;\n            if (!acc[len]) {\n                acc[len] = [];\n            }\n            acc[len].push(path);\n            return acc;\n        }, {});\n\n    Object.\n        keys(collapseMap).\n        forEach(function(collapseKey) {\n            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n        });\n\n    return toPaths(collapseMap);\n};\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports) {\n\n/*eslint-disable*/\nmodule.exports = {\n    innerReferences: 'References with inner references are not allowed.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar cloneArray = __webpack_require__(41);\nvar $ref = __webpack_require__(42).$ref;\nvar errors = __webpack_require__(69);\n\n/**\n * performs the simplified cache reference follow.  This\n * differs from get as there is just following and reporting,\n * not much else.\n *\n * @param {Object} cacheRoot\n * @param {Array} ref\n */\nmodule.exports = function followReference(cacheRoot, ref, maxRefFollow) {\n    var current = cacheRoot;\n    var refPath = ref;\n    var depth = -1;\n    var length = refPath.length;\n    var key, next, type;\n    var referenceCount = 0;\n\n    while (++depth < length) {\n        key = refPath[depth];\n        next = current[key];\n        type = next && next.$type;\n\n        if (!next || type && type !== $ref) {\n            current = next;\n            break;\n        }\n\n        // Show stopper exception.  This route is malformed.\n        if (type && type === $ref && depth + 1 < length) {\n            var err = new Error(errors.innerReferences);\n            err.throwToNext = true;\n            throw err;\n        }\n\n        // potentially follow reference\n        if (depth + 1 === length) {\n            if (type === $ref) {\n                depth = -1;\n                refPath = next.value;\n                length = refPath.length;\n                next = cacheRoot;\n                referenceCount++;\n            }\n\n            if (referenceCount > maxRefFollow) {\n                throw new Error(errors.circularReference);\n            }\n        }\n        current = next;\n    }\n\n    return [current, cloneArray(refPath)];\n};\n\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar iterateKeySet = __webpack_require__(40);\nvar cloneArray = __webpack_require__(41);\nvar catAndSlice = __webpack_require__(75);\nvar $types = __webpack_require__(42);\nvar $ref = $types.$ref;\nvar followReference = __webpack_require__(70);\n\n/**\n * The fastest possible optimize of paths.\n *\n * What it does:\n * - Any atom short-circuit / found value will be removed from the path.\n * - All paths will be exploded which means that collapse will need to be\n *   ran afterwords.\n * - Any missing path will be optimized as much as possible.\n */\nmodule.exports = function optimizePathSets(cache, paths, maxRefFollow) {\n    var optimized = [];\n    paths.forEach(function(p) {\n        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n    });\n\n    return optimized;\n};\n\n\n/**\n * optimizes one pathSet at a time.\n */\nfunction optimizePathSet(cache, cacheRoot, pathSet,\n                         depth, out, optimizedPath, maxRefFollow) {\n\n    // at missing, report optimized path.\n    if (cache === undefined) {\n        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n        return;\n    }\n\n    // all other sentinels are short circuited.\n    // Or we found a primitive (which includes null)\n    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n            (typeof cache !== 'object')) {\n        return;\n    }\n\n    // If the reference is the last item in the path then do not\n    // continue to search it.\n    if (cache.$type === $ref && depth === pathSet.length) {\n        return;\n    }\n\n    var keySet = pathSet[depth];\n    var isKeySet = typeof keySet === 'object';\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet(keySet, iteratorNote);\n    }\n    var next, nextOptimized;\n    do {\n        next = cache[key];\n        var optimizedPathLength = optimizedPath.length;\n        if (key !== null) {\n            optimizedPath[optimizedPathLength] = key;\n        }\n\n        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n            var refResults =\n                followReference(cacheRoot, next.value, maxRefFollow);\n            next = refResults[0];\n\n            // must clone to avoid the mutation from above destroying the cache.\n            nextOptimized = cloneArray(refResults[1]);\n        } else {\n            nextOptimized = optimizedPath;\n        }\n\n        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n                        out, nextOptimized, maxRefFollow);\n        optimizedPath.length = optimizedPathLength;\n\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (iteratorNote && !iteratorNote.done);\n}\n\n\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\n/**\n * Helper for getPathCount. Used to determine the size of a key or range.\n * @function\n * @param {Object} rangeOrKey\n * @return The size of the key or range passed in.\n */\nfunction getRangeOrKeySize(rangeOrKey) {\n    if (rangeOrKey == null) {\n        return 1;\n    } else if (Array.isArray(rangeOrKey)) {\n        throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n    } else if (typeof rangeOrKey === \"object\") {\n        return getRangeSize(rangeOrKey);\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Returns the size (number of items) in a Range,\n * @function\n * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n * @return The number of items in the range.\n */\nfunction getRangeSize(range) {\n\n    var to = range.to;\n    var length = range.length;\n\n    if (to != null) {\n        if (isNaN(to) || parseInt(to, 10) !== to) {\n            throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n        }\n        var from = range.from || 0;\n        if (isNaN(from) || parseInt(from, 10) !== from) {\n            throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n        }\n        if (from <= to) {\n            return (to - from) + 1;\n        } else {\n            return 0;\n        }\n    } else if (length != null) {\n        if (isNaN(length) || parseInt(length, 10) !== length) {\n            throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n        } else {\n            return length;\n        }\n    } else {\n        throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n    }\n}\n\n/**\n * Returns a count of the number of paths this pathset\n * represents.\n *\n * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n * would represent 11 paths (0 to 10, inclusive), and\n * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n *\n * @function\n * @param {Object[]} pathSet the path set.\n *\n * @return The number of paths this represents\n */\nfunction getPathCount(pathSet) {\n    if (pathSet.length === 0) {\n        throw new Error(\"All paths must have length larger than zero.\");\n    }\n\n    var numPaths = 1;\n\n    for (var i = 0; i < pathSet.length; i++) {\n        var segment = pathSet[i];\n\n        if (Array.isArray(segment)) {\n\n            var numKeys = 0;\n\n            for (var j = 0; j < segment.length; j++) {\n                var keySet = segment[j];\n\n                numKeys += getRangeOrKeySize(keySet);\n            }\n\n            numPaths *= numKeys;\n\n        } else {\n            numPaths *= getRangeOrKeySize(segment);\n        }\n    }\n\n    return numPaths;\n}\n\n\nmodule.exports = getPathCount;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar hasIntersection = __webpack_require__(26);\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromLengthTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = paths[i];\n        if (!hasIntersection(tree[path.length], path, 0, path.length)) {\n            out[++outLength] = path;\n        }\n    }\n    return out;\n};\n\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar hasIntersection = __webpack_require__(26);\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        if (!hasIntersection(tree, paths[i], 0, paths[i].length)) {\n            out[++outLength] = paths[i];\n        }\n    }\n    return out;\n};\n\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\nmodule.exports = function catAndSlice(a, b, slice) {\n    var next = [], i, j, len;\n    for (i = 0, len = a.length; i < len; ++i) {\n        next[i] = a[i];\n    }\n\n    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n        next[i] = b[j];\n    }\n\n    return next;\n};\n\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar ModelRoot = __webpack_require__(79);\nvar ModelDataSourceAdapter = __webpack_require__(78);\n\nvar RequestQueue = __webpack_require__(102);\nvar ModelResponse = __webpack_require__(4);\nvar CallResponse = __webpack_require__(106);\nvar InvalidateResponse = __webpack_require__(107);\n\nvar TimeoutScheduler = __webpack_require__(116);\nvar ImmediateScheduler = __webpack_require__(115);\n\nvar collectLru = __webpack_require__(30);\n\nvar getSize = __webpack_require__(7);\nvar isObject = __webpack_require__(0);\nvar isFunction = __webpack_require__(2);\nvar isPrimitive = __webpack_require__(9);\nvar isJSONEnvelope = __webpack_require__(22);\nvar isJSONGraphEnvelope = __webpack_require__(33);\n\nvar setCache = __webpack_require__(31);\nvar setJSONGraphs = __webpack_require__(21);\nvar validateInput = __webpack_require__(37);\nvar noOp = function () {};\nvar getCache = __webpack_require__(86);\nvar get = __webpack_require__(28);\nvar GET_VALID_INPUT = __webpack_require__(56);\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n/**\n* This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n* @callback Model~errorSelector\n* @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n* @returns {Object} the JSONGraph Error object to store in the Model cache.\n*/\n\n/**\n* This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n* @callback Model~comparator\n* @param {Object} existingValue - the current value in the Model cache.\n* @param {Object} newValue - the value about to be set into the Model cache.\n* @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n*/\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(o) {\n\n    var options = o || {};\n    this._root = options._root || new ModelRoot(options, this);\n    this._path = options.path || options._path || [];\n    this._source = options.source || options._source;\n    this._request = options.request || options._request || new RequestQueue(this, options.scheduler || new ImmediateScheduler());\n\n    if (typeof options.maxSize === \"number\") {\n        this._maxSize = options.maxSize;\n    } else {\n        this._maxSize = options._maxSize || Model.prototype._maxSize;\n    }\n\n    if (typeof options.collectRatio === \"number\") {\n        this._collectRatio = options.collectRatio;\n    } else {\n        this._collectRatio = options._collectRatio || Model.prototype._collectRatio;\n    }\n\n    if (options.boxed || options.hasOwnProperty(\"_boxed\")) {\n        this._boxed = options.boxed || options._boxed;\n    }\n\n    if (options.materialized || options.hasOwnProperty(\"_materialized\")) {\n        this._materialized = options.materialized || options._materialized;\n    }\n\n    if (typeof options.treatErrorsAsValues === \"boolean\") {\n        this._treatErrorsAsValues = options.treatErrorsAsValues;\n    } else if (options.hasOwnProperty(\"_treatErrorsAsValues\")) {\n        this._treatErrorsAsValues = options._treatErrorsAsValues;\n    }\n\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\nModel.prototype._materialized = false;\nModel.prototype._boxed = false;\nModel.prototype._progressive = false;\nModel.prototype._treatErrorsAsValues = false;\nModel.prototype._maxSize = Math.pow(2, 53) - 1;\nModel.prototype._collectRatio = 0.75;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = __webpack_require__(109);\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = __webpack_require__(111);\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    var out = validateInput(arguments, GET_VALID_INPUT, \"preload\");\n    if (out !== true) {\n        return new ModelResponse(function (o) {\n            o.onError(out);\n        });\n    }\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    return new ModelResponse(function (obs) {\n        return self.get.apply(self, args).subscribe(function () {}, function (err) {\n            obs.onError(err);\n        }, function () {\n            obs.onCompleted();\n        });\n    });\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\nModel.prototype.call = function call() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        var arg = arguments[argsIdx];\n        args[argsIdx] = arg;\n        var argType = typeof arg;\n        if (argsIdx > 1 && !Array.isArray(arg) || argsIdx === 0 && !Array.isArray(arg) && argType !== \"string\" || argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function (o) {\n                o.onError(new Error(\"Invalid argument\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    return new CallResponse(this, args[0], args[1], args[2], args[3]);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n        if (!Array.isArray(args[argsIdx])) {\n            throw new Error(\"Invalid argument\");\n        }\n    }\n\n    // creates the obs, subscribes and will throw the errors if encountered.\n    new InvalidateResponse(this, args).subscribe(noOp, function (e) {\n        throw e;\n    });\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = __webpack_require__(82);\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = __webpack_require__(81);\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = __webpack_require__(87);\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = __webpack_require__(117);\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        var out;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (out) {\n            get.getWithPathsAsPathMap(this, out, []);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache(...paths) {\n\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var result = [{}];\n    var path = this._path;\n    get.getWithPathsAsJSONGraph(this, paths, result);\n    this._path = path;\n    return result[0].jsonGraph;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path = []) {\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\nModel.prototype._syncCheck = function syncCheck(name) {\n    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {\n        throw new Error(\"Model#\" + name + \" may only be called within the context of a request selector.\");\n    }\n    return true;\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    for (var key in opts) {\n        var value = opts[key];\n        if (value === \"delete\") {\n            delete clone[key];\n        } else {\n            clone[key] = value;\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === \"number\") {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (isFunction(schedulerOrDelay.schedule)) {\n        scheduler = schedulerOrDelay;\n    } else if (isFunction(schedulerOrDelay)) {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, scheduler);\n\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, new ImmediateScheduler());\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({\n        _treatErrorsAsValues: true\n    });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this._path\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._getVersion = __webpack_require__(88);\nModel.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;\nModel.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;\n\nModel.prototype._setPathValues = __webpack_require__(32);\nModel.prototype._setPathMaps = __webpack_require__(31);\nModel.prototype._setJSONGs = __webpack_require__(21);\nModel.prototype._setCache = __webpack_require__(31);\n\nModel.prototype._invalidatePathValues = __webpack_require__(100);\nModel.prototype._invalidatePathMaps = __webpack_require__(99);\n\n/***/ },\n/* 78 */\n/***/ function(module, exports) {\n\nfunction ModelDataSourceAdapter(model) {\n    this._model = model._materialize().boxValues().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    var params = [path, args, suffixes].concat(paths);\n    return this._model.call.apply(this._model, params)._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar hasOwn = __webpack_require__(17);\nvar isFunction = __webpack_require__(2);\nvar toJSONWithHashCodes = __webpack_require__(98);\n\nfunction ModelRoot(o, topLevelModel) {\n\n    var options = o || {};\n\n    this.version = 0;\n    this.syncRefCount = 0;\n    this.expired = options.expired || [];\n    this.unsafeMode = options.unsafeMode || false;\n    this.cache = {};\n    this.topLevelModel = topLevelModel;\n\n    if (isFunction(options.comparator)) {\n        this.comparator = options.comparator;\n    }\n\n    if (options.JSONWithHashCodes === true) {\n        this.branchSelector = toJSONWithHashCodes;\n    } else if (isFunction(options.branchSelector)) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (isFunction(options.errorSelector)) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (isFunction(options.branchSelector)) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (isFunction(options.onChange)) {\n        this.onChange = options.onChange;\n    }\n\n    if (isFunction(options.onChangesCompleted)) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\n\nModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value && cacheNode.$type === messageNode.$type && cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var objectTypes = {\n    \"boolean\": false,\n    \"function\": true,\n    \"object\": true,\n    \"number\": false,\n    \"string\": false,\n    \"undefined\": false\n};\n\n/*eslint-disable */\nvar _root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;\nvar freeGlobal = objectTypes[typeof global] && global;\n\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    _root = freeGlobal;\n}\n/*eslint-enable */\n\nvar _id = 0;\n\nfunction ensureSymbol(root) {\n    if (!root.Symbol) {\n        root.Symbol = function symbolFuncPolyfill(description) {\n            return \"@@Symbol(\" + description + \"):\" + _id++ + \"}\";\n        };\n    }\n    return root.Symbol;\n}\n\nfunction ensureObservable(Symbol) {\n    /* eslint-disable dot-notation */\n    if (!Symbol.observable) {\n        if (typeof Symbol.for === \"function\") {\n            Symbol[\"observable\"] = Symbol.for(\"observable\");\n        } else {\n            Symbol[\"observable\"] = \"@@observable\";\n        }\n    }\n    /* eslint-disable dot-notation */\n}\n\nfunction symbolForPolyfill(key) {\n    return \"@@\" + key;\n}\n\nfunction ensureFor(Symbol) {\n    /* eslint-disable dot-notation */\n    if (!Symbol.for) {\n        Symbol[\"for\"] = symbolForPolyfill;\n    }\n    /* eslint-enable dot-notation */\n}\n\nfunction polyfillSymbol(root) {\n    var Symbol = ensureSymbol(root);\n    ensureObservable(Symbol);\n    ensureFor(Symbol);\n    return Symbol;\n}\n\nmodule.exports = polyfillSymbol(_root);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))\n\n/***/ },\n/* 81 */\n/***/ function(module, exports) {\n\nmodule.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference.ツparent === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference.ツinvalidated) {\n        return false;\n    }\n\n    return true;\n}\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar CONTAINER_DOES_NOT_EXIST = \"e\";\nvar $ref = __webpack_require__(1);\nvar getCachePosition = __webpack_require__(48);\nvar InvalidDerefInputError = __webpack_require__(84);\n\nmodule.exports = function deref(boundJSONArg) {\n\n    var referenceContainer, currentRefPath, i, len;\n    var absolutePath = boundJSONArg && boundJSONArg.$__path;\n    var originalRefPath = boundJSONArg && boundJSONArg.$__refPath;\n    var toReference = boundJSONArg && boundJSONArg.$__toReference;\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    if (absolutePath) {\n        var cacheRoot = this._root.cache;\n        var cacheNode = getCachePosition(cacheRoot, absolutePath);\n        var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n        if (absolutePath.length === 0) {\n            return this._clone({\n                _path: absolutePath,\n                _referenceContainer: true\n            });\n        }\n\n        if (toReference) {\n\n            validContainer = false;\n\n            i = -1;\n            len = toReference.length;\n            referenceContainer = cacheRoot;\n            while (++i < len) {\n                referenceContainer = referenceContainer[toReference[i]];\n                if (!referenceContainer || referenceContainer.$type) {\n                    break;\n                }\n            }\n\n            // If the reference container is still a sentinel value then compare\n            // the reference value with refPath.  If they are the same, then the\n            // model is still valid.\n            if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n                i = 0;\n                len = originalRefPath.length;\n                currentRefPath = referenceContainer.value;\n\n                validContainer = true;\n                for (; validContainer && i < len; ++i) {\n                    if (currentRefPath[i] !== originalRefPath[i]) {\n                        validContainer = false;\n                    }\n                }\n                if (validContainer === false) {\n                    cacheNode = undefined;\n                }\n            }\n        }\n\n        // Signal to the deref'd model that it has been disconnected from the\n        // graph or there is no _fromWhenceYouCame\n        if (!validContainer) {\n            referenceContainer = false;\n        }\n\n        // The container did not exist, therefore there is no reference\n        // container and fromWhenceYouCame should always return true.\n        else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n                referenceContainer = true;\n            }\n\n        return this._clone({\n            _node: cacheNode,\n            _path: absolutePath,\n            _referenceContainer: referenceContainer\n        });\n    }\n\n    throw new InvalidDerefInputError();\n};\n\n/***/ },\n/* 83 */\n/***/ function(module, exports) {\n\nvar NAME = \"BoundJSONGraphModelError\";\nvar MESSAGE = \"It is not legal to use the JSON Graph \" + \"format from a bound Model. JSON Graph format\" + \" can only be used from a root model.\";\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = this.name;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nBoundJSONGraphModelError.prototype = Object.create(Error.prototype);\nBoundJSONGraphModelError.prototype.name = NAME;\nBoundJSONGraphModelError.message = MESSAGE;\n\nmodule.exports = BoundJSONGraphModelError;\n\n/***/ },\n/* 84 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidDerefInputError\";\nvar MESSAGE = \"Deref can only be used with a non-primitive object from get, set, or call.\";\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidDerefInputError() {\n  var err = Error.call(this, MESSAGE);\n  err.name = NAME;\n  this.stack = err.stack;\n  this.message = err.message;\n  return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidDerefInputError.prototype = Object.create(Error.prototype);\nInvalidDerefInputError.prototype.name = NAME;\nInvalidDerefInputError.message = MESSAGE;\n\nmodule.exports = InvalidDerefInputError;\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\nvar NAME = \"InvalidModelError\";\nvar MESSAGE = \"The boundPath of the model is not valid since a value or error was found before the path end.\";\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidModelError(boundPath, shortedPath) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidModelError.prototype = Object.create(Error.prototype);\nInvalidModelError.prototype.name = NAME;\nInvalidModelError.message = MESSAGE;\n\nmodule.exports = InvalidModelError;\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternalKey = __webpack_require__(123);\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    Object.keys(node).filter(function (k) {\n        // Its not an internal key and the node has a value.  In the cache\n        // there are 3 possibilities for values.\n        // 1: A branch node.\n        // 2: A $type-value node.\n        // 3: undefined\n        // We will strip out 3\n        return !isInternalKey(k) && node[k] !== undefined;\n    }).forEach(function (key) {\n        var cacheNext = node[key];\n        var outNext = out[key];\n\n        if (!outNext) {\n            outNext = out[key] = {};\n        }\n\n        // Paste the node into the out cache.\n        if (cacheNext.$type) {\n            var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n            var isUserCreatedcacheNext = !cacheNext.ツmodelCreated;\n            var value;\n            if (isObject || isUserCreatedcacheNext) {\n                value = cloneBoxedValue(cacheNext);\n            } else {\n                value = cacheNext.value;\n            }\n\n            out[key] = value;\n            return;\n        }\n\n        _copyCache(cacheNext, outNext, key);\n    });\n}\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar ModelResponse = __webpack_require__(4);\n\nmodule.exports = function getValue(path) {\n    var pathIdx = 0;\n    var pathLen = path.length;\n    while (++pathIdx < pathLen) {\n        if (typeof path[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function (o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    var self = this;\n    return new ModelResponse(function (obs) {\n        return self.get(path).subscribe(function (data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = path.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[path[depth]];\n            }\n            obs.onNext(curr);\n        }, function (err) {\n            obs.onError(err);\n        }, function () {\n            obs.onCompleted();\n        });\n    });\n};\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getBoundCacheNode = __webpack_require__(11);\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node.ツversion;\n    return version == null ? -1 : version;\n};\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar walkPathAndBuildOutput = __webpack_require__(93);\nvar getBoundCacheNode = __webpack_require__(11);\nvar InvalidModelError = __webpack_require__(85);\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, values) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath.length;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return {\n                criticalError: new InvalidModelError(boundPath, boundPath)\n            };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame,\n        seed = values[0],\n        json = seed && seed.json,\n        results = { values: values },\n        path,\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        requestedLength = path.length;\n        json = walkPathAndBuildOutput(cache, node, json, path,\n        /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n        /* fromReference = */false, referenceContainer, modelRoot, expired, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar $ref = __webpack_require__(1);\nvar promote = __webpack_require__(16);\nvar isExpired = __webpack_require__(3);\nvar createHardlink = __webpack_require__(13);\nvar CircularReferenceError = __webpack_require__(45);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        followedRefsCount = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref.ツcontext)) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (false) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\"Followed \" + followedRefsCount + \" references. \" + \"This might indicate the presence of an indirect \" + \"circular reference chain.\");\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = typeof console.warn === \"function\" && console.warn || typeof console.log === \"function\" && console.log;\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(15);\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results, requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(15);\nvar onError = __webpack_require__(91);\nvar $atom = __webpack_require__(25);\nvar $error = __webpack_require__(19);\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath, fromReference, boxValues);\n    }\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            results.hasValue = true;\n            return { $type: $atom };\n        }\n        return undefined;\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    if (boxValues) {\n        return clone(node);\n    }\n\n    return value;\n}\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar $ref = __webpack_require__(1);\nvar onValue = __webpack_require__(92);\nvar onMissing = __webpack_require__(49);\nvar onValueType = __webpack_require__(50);\nvar isExpired = __webpack_require__(3);\nvar getReferenceTarget = __webpack_require__(90);\nvar NullInPathError = __webpack_require__(14);\nvar InvalidKeySetError = __webpack_require__(46);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        nextJSON,\n        nextReferenceContainer,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return json;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === $ref && !isExpired(next)) {\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextReferenceContainer = refTarget[2];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n            }\n\n            // Continue following the path\n\n            nextJSON = walkPathAndBuildOutput(cacheRoot, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n            // Inspect the return value from the step and determine whether to\n            // create or write into the JSON branch at this level.\n            //\n            // 1. If the next node was a leaf value, nextJSON is the value.\n            // 2. If the next node was a missing path, nextJSON is undefined.\n            // 3. If the next node was a branch, then nextJSON will either be an\n            //    Object or undefined. If nextJSON is undefined, all paths under\n            //    this step resolved to missing paths. If it's an Object, then\n            //    at least one path resolved to a successful leaf value.\n            //\n            // This check defers creating branches until we see at least one\n            // cache hit. Otherwise, don't waste the cycles creating a branch\n            // if everything underneath is a cache miss.\n\n            if (undefined !== nextJSON) {\n                // The json value will initially be undefined. If we're here,\n                // then at least one leaf value was encountered, so create a\n                // branch to contain it.\n                if (undefined === json) {\n                    // Enable developers to instrument branch node creation by\n                    // providing a custom function. If they do, delegate branch\n                    // node creation to them.\n                    if (branchSelector) {\n\n                        // branchSelector = (\n                        //     nodeKey: String|Number|null,\n                        //     nodePath: Array|null,\n                        //     nodeVersion: Number,\n                        //     requestedPath: Array,\n                        //     requestedDepth: Number,\n                        //     referencePath: Array|null,\n                        //     pathToReference: Array|null\n                        // ) => Object { $__path?, $__refPath?, $__toReference? }\n\n                        json = branchSelector(node.ツkey, node.ツabsolutePath, node.ツversion, path, depth, allowFromWhenceYouCame && referenceContainer && referenceContainer.value || undefined, allowFromWhenceYouCame && referenceContainer && referenceContainer.ツabsolutePath || undefined);\n                    }\n                    // Otherwise, create a branch ourselves and assign the required metadata\n                    else {\n                            json = {};\n                            // Only assign the $__path if this isn't the top-level\n                            // branch (e.g. { json: {} <-- this one }).\n                            if (depth > 0) {\n                                json.$__path = node.ツabsolutePath;\n                            }\n                            if (allowFromWhenceYouCame && referenceContainer) {\n                                json.$__refPath = referenceContainer.value;\n                                json.$__toReference = referenceContainer.ツabsolutePath;\n                            }\n                        }\n                }\n\n                // Set the reported branch or leaf into this branch.\n                json[nextKey] = nextJSON;\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will either be a branch, or undefined if all paths were cache misses\n    return json;\n}\n/* eslint-enable */\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar walkPathAndBuildOutput = __webpack_require__(97);\nvar BoundJSONGraphModelError = __webpack_require__(83);\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, values) {\n\n    var node,\n        cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath.length;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return {\n            criticalError: new BoundJSONGraphModelError()\n        };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        seed = values[0],\n        results = { values: values },\n        path,\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n        /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n        /* fromReference = */false, modelRoot, expired, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    return results;\n}\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar clone = __webpack_require__(15);\nvar $ref = __webpack_require__(1);\nvar inlineValue = __webpack_require__(29);\nvar promote = __webpack_require__(16);\nvar isExpired = __webpack_require__(3);\nvar createHardlink = __webpack_require__(13);\nvar CircularReferenceError = __webpack_require__(45);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, boxValues, materialized) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        followedRefsCount = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref.ツcontext)) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (false) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\"Followed \" + followedRefsCount + \" references. \" + \"This might indicate the presence of an indirect \" + \"circular reference chain.\");\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = typeof console.warn === \"function\" && console.warn || typeof console.log === \"function\" && console.log;\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(15);\nvar $ref = __webpack_require__(1);\nvar $atom = __webpack_require__(25);\nvar $error = __webpack_require__(19);\nvar inlineValue = __webpack_require__(29);\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized) {\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            value = { $type: $atom };\n        } else {\n            return undefined;\n        }\n    }\n    // boxValues always clones the node\n    else if (boxValues ||\n        /*\n         * JSON Graph should always clone errors, refs, atoms we didn't\n         * create, and atoms we created to wrap Object values.\n         */\n        $ref === type || $error === type || !node.ツmodelCreated || \"object\" === typeof value) {\n            value = clone(node);\n        }\n\n    if (results && requestedPath) {\n        results.hasValue = true;\n        inlineValue(value, optimizedPath, optimizedLength, seed, boxValues, materialized);\n        (seed.paths || (seed.paths = [])).push(requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n        );\n    }\n\n    return value;\n}\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar clone = __webpack_require__(15);\nvar $ref = __webpack_require__(1);\nvar onValue = __webpack_require__(96);\nvar onMissing = __webpack_require__(49);\nvar inlineValue = __webpack_require__(29);\nvar onValueType = __webpack_require__(50);\nvar isExpired = __webpack_require__(3);\nvar getReferenceTarget = __webpack_require__(95);\nvar NullInPathError = __webpack_require__(14);\nvar InvalidKeySetError = __webpack_require__(46);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                keyset = keysOrRanges[keysetIndex];\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === $ref && !isExpired(next)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, seed, boxValues, materialized);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(cacheRoot, next, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, modelRoot, expired, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\nmodule.exports = toJSONWithHashCodes;\n\n/**\n * branchSelector = (\n *     nodeKey: String|Number|null,\n *     nodePath: Array|null,\n *     nodeVersion: Number,\n *     requestedPath: Array,\n *     requestedDepth: Number,\n *     referencePath: Array|null,\n *     pathToReference: Array|null\n * ) => Object { $__path?, $__refPath?, $__toReference? }\n */\n\nfunction toJSONWithHashCodes(nodeKey = '$__cache__$', nodePath = [], nodeVersion = 0, requestedPath = [], requestedDepth = 0, referencePath, pathToReference) {\n\n    var json = {\n        __proto__: JSONProto,\n        $__key: nodeKey,\n        $__path: nodePath,\n        $__version: nodeVersion,\n        $__keysPath: requestedPath,\n        $__keyDepth: requestedDepth\n    };\n\n    if (referencePath && pathToReference) {\n        json.$__refPath = referencePath;\n        json.$__toReference = pathToReference;\n    }\n\n    return json;\n}\n\nvar isArray = Array.isArray;\nvar JSONProto = Object.create(Object.prototype, Object.assign({\n    $__name: { value: 'falcor-node' },\n    $__hash: {\n        enumerable: false,\n        get() {\n            var $__hash__$ = this.$__hash__$;\n            if ($__hash__$ === undefined) {\n                $__hash__$ = this.$__hash__$ = `${ getHashCode(`${ computeHashCodeForKeys('$__cache__$', this.$__path, 0) }${ computeHashCodeForKeys(this.$__key, this.$__keysPath, this.$__keyDepth) }`) }`;\n            }\n            return $__hash__$;\n        }\n    }\n}, arrayProtoMethods().reduce((jsonProto, methodName) => {\n    var method = Array.prototype[methodName];\n    jsonProto[methodName] = {\n        writable: true, enumerable: false, value() {\n            return method.apply(this, arguments);\n        }\n    };\n    return jsonProto;\n}, {})));\n\nfunction arrayProtoMethods() {\n    return ['concat', 'copyWithin', 'entries', 'every', 'fill', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'keys', 'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight', 'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'unshift', 'values'];\n}\n\nfunction computeHashCodeForKeys(key, path, depth) {\n\n    var code = `${ getHashCode(`${ key }`) }`;\n\n    if (depth === path.length) {\n        return code;\n    }\n\n    var nextDepth = depth + 1;\n    var keyset,\n        keysetIndex = -1,\n        keysetLength = 0;\n    var nextKey, keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return code;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    break iteratingKeyset;\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (\"number\" !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        do {\n            code = `${ getHashCode(`${ code }${ computeHashCodeForKeys(nextKey, path, nextDepth) }`) }`;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return code;\n}\n\nfunction getHashCode(str) {\n    var hash = 5381,\n        i = str.length;\n    while (i) {\n        hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createHardlink = __webpack_require__(13);\nvar __prefix = __webpack_require__(5);\n\nvar $ref = __webpack_require__(1);\n\nvar getBoundCacheNode = __webpack_require__(11);\n\nvar promote = __webpack_require__(16);\nvar getSize = __webpack_require__(7);\nvar hasOwn = __webpack_require__(17);\nvar isObject = __webpack_require__(0);\nvar isExpired = __webpack_require__(3);\nvar isFunction = __webpack_require__(2);\nvar isPrimitive = __webpack_require__(9);\nvar expireNode = __webpack_require__(6);\nvar updateNodeAncestors = __webpack_require__(18);\nvar removeNodeAndDescendants = __webpack_require__(36);\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var comparator = modelRoot._comparator;\n    var errorSelector = modelRoot._errorSelector;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, errorSelector);\n    }\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isPrimitive(pathMap) || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (key[0] !== __prefix && key[0] !== \"$\" && hasOwn(pathMap, key)) {\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n            var results = invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, errorSelector);\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, errorSelector);\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node.ツcontext;\n\n    if (node != null) {\n        parent = node.ツparent || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, errorSelector);\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container.ツcontext !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(root, parent, node, key, value, branch, reference, version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node.ツkey;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __ref = __webpack_require__(12);\n\nvar $ref = __webpack_require__(1);\n\nvar getBoundCacheNode = __webpack_require__(11);\n\nvar promote = __webpack_require__(16);\nvar getSize = __webpack_require__(7);\nvar isExpired = __webpack_require__(3);\nvar isFunction = __webpack_require__(2);\nvar isPrimitive = __webpack_require__(9);\nvar expireNode = __webpack_require__(6);\nvar iterateKeySet = __webpack_require__(8).iterateKeySet;\nvar updateNodeAncestors = __webpack_require__(18);\nvar removeNodeAndDescendants = __webpack_require__(36);\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(path, 0, cache, parent, node, version, expired, lru);\n    }\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(path, depth, root, parent, node, version, expired, lru) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        var results = invalidateNode(root, parent, node, key, branch, false, version, expired, lru);\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru);\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node.ツcontext;\n\n    if (node != null) {\n        parent = node.ツparent || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(root, parent, node, key, branch, true, version, expired, lru);\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container.ツcontext !== node) {\n            var backRefs = node.ツrefsLength || 0;\n            node.ツrefsLength = backRefs + 1;\n            node[__ref + backRefs] = container;\n            container.ツcontext = node;\n            container.ツrefIndex = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(root, parent, node, key, branch, reference, version, expired, lru) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(root, node, version, expired, lru);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node.ツkey;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar complement = __webpack_require__(103);\nvar flushGetRequest = __webpack_require__(104);\nvar REQUEST_ID = 0;\nvar GetRequestType = __webpack_require__(52).GetRequest;\nvar setJSONGraphs = __webpack_require__(21);\nvar setPathValues = __webpack_require__(32);\nvar noop = __webpack_require__(24);\nvar $error = __webpack_require__(19);\nvar emptyArray = [];\nvar InvalidSourceError = __webpack_require__(10);\n\n/**\n * Creates a new GetRequest.  This GetRequest takes a scheduler and\n * the request queue.  Once the scheduler fires, all batched requests\n * will be sent to the server.  Upon request completion, the data is\n * merged back into the cache and all callbacks are notified.\n *\n * @param {Scheduler} scheduler -\n * @param {RequestQueue} requestQueue -\n */\nvar GetRequest = function (scheduler, requestQueue) {\n    this.sent = false;\n    this.scheduled = false;\n    this.requestQueue = requestQueue;\n    this.id = ++REQUEST_ID;\n    this.type = GetRequestType;\n\n    this._scheduler = scheduler;\n    this._pathMap = {};\n    this._optimizedPaths = [];\n    this._requestedPaths = [];\n    this._callbacks = [];\n    this._count = 0;\n    this._disposable = null;\n    this._collapsed = null;\n    this._disposed = false;\n};\n\nGetRequest.prototype = {\n    /**\n     * batches the paths that are passed in.  Once the request is complete,\n     * all callbacks will be called and the request will be removed from\n     * parent queue.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} callback -\n     */\n    batch: function (requestedPaths, optimizedPaths, callback) {\n        var self = this;\n        var oPaths = self._optimizedPaths;\n        var rPaths = self._requestedPaths;\n        var callbacks = self._callbacks;\n        var idx = oPaths.length;\n\n        // If its not sent, simply add it to the requested paths\n        // and callbacks.\n        oPaths[idx] = optimizedPaths;\n        rPaths[idx] = requestedPaths;\n        callbacks[idx] = callback;\n        ++self._count;\n\n        // If it has not been scheduled, then schedule the action\n        if (!self.scheduled) {\n            self.scheduled = true;\n\n            var flushedDisposable;\n            var scheduleDisposable = self._scheduler.schedule(function () {\n                self._disposable = flushedDisposable = interopDisposable(flushGetRequest(self, oPaths, function (err, data) {\n                    var i, fn, len;\n                    self.requestQueue.removeRequest(self);\n                    self._disposed = true;\n\n                    if (err instanceof InvalidSourceError) {\n                        for (i = 0, len = callbacks.length; i < len; ++i) {\n                            fn = callbacks[i];\n                            if (fn) {\n                                fn(err);\n                            }\n                        }\n                        return;\n                    }\n\n                    // If there is at least one callback remaining, then\n                    // callback the callbacks.\n                    if (self._count) {\n                        self._merge(rPaths, err, data);\n\n                        // Call the callbacks.  The first one inserts all\n                        // the data so that the rest do not have consider\n                        // if their data is present or not.\n                        for (i = 0, len = callbacks.length; i < len; ++i) {\n                            fn = callbacks[i];\n                            if (fn) {\n                                fn(err, data);\n                            }\n                        }\n                    }\n                }));\n            });\n\n            // There is a race condition here. If the scheduler is sync then it\n            // exposes a condition where the flush request cannot be disposed.\n            // To correct this issue, if there is no flushedDisposable, then the\n            // scheduler is async and should use scheduler disposable, else use\n            // the flushedDisposable.\n            self._disposable = interopDisposable(flushedDisposable || scheduleDisposable);\n        }\n\n        // Disposes this batched request.  This does not mean that the\n        // entire request has been disposed, but just the local one, if all\n        // requests are disposed, then the outer disposable will be removed.\n        return createDisposable(self, idx);\n    },\n\n    /**\n     * Attempts to add paths to the outgoing request.  If there are added\n     * paths then the request callback will be added to the callback list.\n     *\n     * @returns {Array} - the remaining paths in the request.\n     */\n    add: function (requested, optimized, callback) {\n        // uses the length tree complement calculator.\n        var self = this;\n        var complementTuple = complement(requested, optimized, self._pathMap);\n        var optimizedComplement;\n        var requestedComplement;\n\n        if (complementTuple) {\n            requestedComplement = complementTuple[2];\n            optimizedComplement = complementTuple[1];\n        } else {\n            requestedComplement = requested;\n            optimizedComplement = optimized;\n        }\n\n        var inserted = false;\n        var disposable = false;\n\n        // If the out paths is less than the passed in paths, then there\n        // has been an intersection and the complement has been returned.\n        // Therefore, this can be deduped across requests.\n        if (optimizedComplement.length < optimized.length) {\n            inserted = true;\n            var idx = self._callbacks.length;\n            self._callbacks[idx] = callback;\n            self._requestedPaths[idx] = complementTuple[0];\n            self._optimizedPaths[idx] = [];\n            ++self._count;\n\n            disposable = createDisposable(self, idx);\n        }\n\n        return [inserted, requestedComplement, optimizedComplement, disposable];\n    },\n\n    /**\n     * merges the response into the model\"s cache.\n     */\n    _merge: function (requested, err, data) {\n        var self = this;\n        var model = self.requestQueue.model;\n        var modelRoot = model._root;\n        var errorSelector = modelRoot.errorSelector;\n        var comparator = modelRoot.comparator;\n        var boundPath = model._path;\n\n        model._path = emptyArray;\n\n        // flatten all the requested paths, adds them to the\n        var nextPaths = flattenRequestedPaths(requested);\n\n        // Insert errors in every requested position.\n        if (err) {\n            var error = err;\n\n            // Converts errors to objects, a more friendly storage\n            // of errors.\n            if (error instanceof Error) {\n                error = {\n                    message: error.message\n                };\n            }\n            // Not all errors are value $types.\n            else if (!error.$type) {\n                    error = {\n                        $type: $error,\n                        value: error\n                    };\n                }\n\n            var pathValues = nextPaths.map(function (x) {\n                return {\n                    path: x,\n                    value: error\n                };\n            });\n            setPathValues(model, pathValues, errorSelector, comparator);\n        }\n\n        // Insert the jsonGraph from the dataSource.\n        else {\n                setJSONGraphs(model, [{\n                    paths: nextPaths,\n                    jsonGraph: data.jsonGraph\n                }], errorSelector, comparator);\n            }\n\n        // return the model\"s boundPath\n        model._path = boundPath;\n    }\n};\n\n// Creates a more efficient closure of the things that are\n// needed.  So the request and the idx.  Also prevents code\n// duplication.\nfunction createDisposable(request, idx) {\n    var disposed = false;\n    return function () {\n        if (disposed || request._disposed) {\n            return;\n        }\n\n        disposed = true;\n        request._callbacks[idx] = null;\n        request._optimizedPaths[idx] = [];\n        request._requestedPaths[idx] = [];\n\n        // If there are no more requests, then dispose all of the request.\n        var count = --request._count;\n        if (count === 0) {\n            request._disposable.dispose();\n            request.requestQueue.removeRequest(request);\n        }\n    };\n}\n\nfunction flattenRequestedPaths(requested) {\n    var out = [];\n    var outLen = -1;\n    for (var i = 0, len = requested.length; i < len; ++i) {\n        var paths = requested[i];\n        for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {\n            out[++outLen] = paths[j];\n        }\n    }\n    return out;\n}\n\nfunction interopDisposable(disposable) {\n    if (!disposable) {\n        return { dispose: noop, unsubscribe: noop };\n    }\n    if (!disposable.unsubscribe) {\n        disposable.unsubscribe = disposable.dispose;\n    } else if (!disposable.dispose) {\n        disposable.dispose = disposable.unsubscribe;\n    }\n    return disposable;\n}\n\nmodule.exports = GetRequest;\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar RequestTypes = __webpack_require__(52);\nvar sendSetRequest = __webpack_require__(105);\nvar GetRequest = __webpack_require__(101);\nvar collapse = __webpack_require__(8).collapse;\n\n/**\n * The request queue is responsible for queuing the operations to\n * the model\"s dataSource.\n *\n * @param {Model} model -\n * @param {Scheduler} scheduler -\n */\nfunction RequestQueue(model, scheduler) {\n    this.model = model;\n    this.scheduler = scheduler;\n    this.requests = this._requests = [];\n}\n\nRequestQueue.prototype = {\n    /**\n     * Sets the scheduler, but will not affect any current requests.\n     */\n    setScheduler: function (scheduler) {\n        this.scheduler = scheduler;\n    },\n\n    /**\n     * performs a set against the dataSource.  Sets, though are not batched\n     * currently could be batched potentially in the future.  Since no batching\n     * is required the setRequest action is simplified significantly.\n     *\n     * @param {JSONGraphEnvelope) jsonGraph -\n     */\n    set: function (jsonGraph, cb) {\n        jsonGraph.paths = collapse(jsonGraph.paths);\n        return sendSetRequest(jsonGraph, this.model, cb);\n    },\n\n    /**\n     * Creates a get request to the dataSource.  Depending on the current\n     * scheduler is how the getRequest will be flushed.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} cb -\n     */\n    get: function (requestedPaths, optimizedPaths, cb) {\n        var self = this;\n        var disposables = [];\n        var count = 0;\n        var requests = self._requests;\n        var i, len;\n        var oRemainingPaths = optimizedPaths;\n        var rRemainingPaths = requestedPaths;\n        var disposed = false;\n        var request;\n\n        for (i = 0, len = requests.length; i < len; ++i) {\n            request = requests[i];\n            if (request.type !== RequestTypes.GetRequest) {\n                continue;\n            }\n\n            // The request has been sent, attempt to jump on the request\n            // if possible.\n            if (request.sent) {\n                var results = request.add(rRemainingPaths, oRemainingPaths, refCountCallback);\n\n                // Checks to see if the results were successfully inserted\n                // into the outgoing results.  Then our paths will be reduced\n                // to the complement.\n                if (results[0]) {\n                    rRemainingPaths = results[1];\n                    oRemainingPaths = results[2];\n                    disposables[disposables.length] = results[3];\n                    ++count;\n                }\n            }\n\n            // If there is a non sent request, then we can batch and leave.\n            else {\n                    request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);\n                    oRemainingPaths = [];\n                    rRemainingPaths = [];\n                    ++count;\n                }\n\n            // If there are no more remaining paths then exit the loop.\n            if (!oRemainingPaths.length) {\n                break;\n            }\n        }\n\n        // After going through all the available requests if there are more\n        // paths to process then a new request must be made.\n        if (oRemainingPaths.length) {\n            request = new GetRequest(self.scheduler, self);\n            requests[requests.length] = request;\n            ++count;\n            var disposable = request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);\n            disposables[disposables.length] = disposable;\n        }\n\n        // This is a simple refCount callback.\n        function refCountCallback(err) {\n            if (disposed) {\n                return;\n            }\n\n            --count;\n\n            // If the count becomes 0, then its time to notify the\n            // listener that the request is done.\n            if (count === 0) {\n                cb(err);\n            }\n        }\n\n        // When disposing the request all of the outbound requests will be\n        // disposed of.\n        return function () {\n            if (disposed || count === 0) {\n                return;\n            }\n\n            disposed = true;\n            var length = disposables.length;\n            for (var idx = 0; idx < length; ++idx) {\n                disposables[idx]();\n            }\n        };\n    },\n\n    /**\n     * Removes the request from the request\n     */\n    removeRequest: function (request) {\n        var requests = this._requests;\n        var i = requests.length;\n        while (--i >= 0) {\n            if (requests[i].id === request.id) {\n                requests.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\nmodule.exports = RequestQueue;\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar hasIntersection = __webpack_require__(8).hasIntersection;\n\n/**\n * creates the complement of the requested and optimized paths\n * based on the provided tree.\n *\n * If there is no complement then this is just a glorified\n * array copy.\n */\nmodule.exports = function complement(requested, optimized, tree) {\n    var optimizedComplement = [];\n    var requestedComplement = [];\n    var requestedIntersection = [];\n    var intersectionLength = -1,\n        complementLength = -1;\n    var intersectionFound = false;\n\n    for (var i = 0, len = optimized.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = optimized[i];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n\n        // If there is no subtree to look into or there is no intersection.\n        if (!subTree || !hasIntersection(subTree, path, 0, pathLen)) {\n\n            if (intersectionFound) {\n                optimizedComplement[++complementLength] = path;\n                requestedComplement[complementLength] = requested[i];\n            }\n        } else {\n            // If there has been no intersection yet and\n            // i is bigger than 0 (meaning we have had only complements)\n            // then we need to update our complements to match the current\n            // reality.\n            if (!intersectionFound && i > 0) {\n                requestedComplement = requested.slice(0, i);\n                optimizedComplement = optimized.slice(0, i);\n            }\n\n            requestedIntersection[++intersectionLength] = requested[i];\n            intersectionFound = true;\n        }\n    }\n\n    if (!intersectionFound) {\n        return null;\n    }\n\n    return [requestedIntersection, optimizedComplement, requestedComplement];\n};\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar pathUtils = __webpack_require__(8);\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\nvar InvalidSourceError = __webpack_require__(10);\n\n/**\n * Flushes the current set of requests.  This will send the paths to the\n * dataSource.  * The results of the dataSource will be sent to callback which\n * should perform the zip of all callbacks.\n * @param {GetRequest} request -\n * @param {Array} listOfPaths -\n * @param {Function} callback -\n * @private\n */\nmodule.exports = function flushGetRequest(request, listOfPaths, callback) {\n    if (request._count === 0) {\n        request.requestQueue.removeRequest(request);\n        return null;\n    }\n\n    request.sent = true;\n    request.scheduled = false;\n\n    // TODO: Move this to the collapse algorithm,\n    // TODO: we should have a collapse that returns the paths and\n    // TODO: the trees.\n\n    // Take all the paths and add them to the pathMap by length.\n    // Since its a list of paths\n    var pathMap = request._pathMap;\n    var listKeys = Object.keys(listOfPaths);\n    var listIdx = 0,\n        listLen = listKeys.length;\n    for (; listIdx < listLen; ++listIdx) {\n        var paths = listOfPaths[listIdx];\n        for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {\n            var pathSet = paths[j];\n            var len = pathSet.length;\n\n            if (!pathMap[len]) {\n                pathMap[len] = [pathSet];\n            } else {\n                var pathSetsByLength = pathMap[len];\n                pathSetsByLength[pathSetsByLength.length] = pathSet;\n            }\n        }\n    }\n\n    // now that we have them all by length, convert each to a tree.\n    var pathMapKeys = Object.keys(pathMap);\n    var pathMapIdx = 0,\n        pathMapLen = pathMapKeys.length;\n    for (; pathMapIdx < pathMapLen; ++pathMapIdx) {\n        var pathMapKey = pathMapKeys[pathMapIdx];\n        pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);\n    }\n\n    // Take the pathMapTree and create the collapsed paths and send those\n    // off to the server.\n    var collapsedPaths = request._collasped = toPaths(pathMap);\n    var jsonGraphData;\n\n    // Make the request.\n    // You are probably wondering why this is not cancellable.  If a request\n    // goes out, and all the requests are removed, the request should not be\n    // cancelled.  The reasoning is that another request could come in, after\n    // all callbacks have been removed and be deduped.  Might as well keep this\n    // around until it comes back.  If at that point there are no requests then\n    // we cancel at the callback above.\n    var getRequest;\n    try {\n        getRequest = request.requestQueue.model._source.get(collapsedPaths);\n    } catch (e) {\n        callback(new InvalidSourceError());\n        return null;\n    }\n\n    // Ensures that the disposable is available for the outside to cancel.\n    var disposable = getRequest.subscribe(function (data) {\n        jsonGraphData = data;\n    }, function (err) {\n        callback(err, jsonGraphData);\n    }, function () {\n        callback(null, jsonGraphData);\n    });\n\n    return disposable;\n};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar setJSONGraphs = __webpack_require__(21);\nvar setPathValues = __webpack_require__(32);\nvar InvalidSourceError = __webpack_require__(10);\n\nvar emptyArray = [];\nvar emptyDisposable = { dispose: function () {} };\n\n/**\n * A set request is not an object like GetRequest.  It simply only needs to\n * close over a couple values and its never batched together (at least not now).\n *\n * @private\n * @param {JSONGraphEnvelope} jsonGraph -\n * @param {Model} model -\n * @param {Function} callback -\n */\nvar sendSetRequest = function (originalJsonGraph, model, callback) {\n    var paths = originalJsonGraph.paths;\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var comparator = modelRoot.comparator;\n    var boundPath = model._path;\n    var resultingJsonGraphEnvelope;\n\n    // This is analogous to GetRequest _merge / flushGetRequest\n    // SetRequests are just considerably simplier.\n    var setObservable;\n    try {\n        setObservable = model._source.set(originalJsonGraph);\n    } catch (e) {\n        callback(new InvalidSourceError());\n        return emptyDisposable;\n    }\n\n    var disposable = setObservable.subscribe(function onNext(jsonGraphEnvelope) {\n        // When disposed, no data is inserted into.  This can sync resolve\n        // and if thats the case then its undefined.\n        if (disposable && disposable.disposed) {\n            return;\n        }\n\n        // onNext will insert all data into the model then save the json\n        // envelope from the incoming result.\n        model._path = emptyArray;\n\n        var successfulPaths = setJSONGraphs(model, [{\n            paths: paths,\n            jsonGraph: jsonGraphEnvelope.jsonGraph\n        }], errorSelector, comparator);\n\n        jsonGraphEnvelope.paths = successfulPaths[1];\n\n        model._path = boundPath;\n        resultingJsonGraphEnvelope = jsonGraphEnvelope;\n    }, function onError(dataSourceError) {\n        if (disposable && disposable.disposed) {\n            return;\n        }\n        model._path = emptyArray;\n\n        setPathValues(model, paths.map(function (path) {\n            return {\n                path: path,\n                value: dataSourceError\n            };\n        }), errorSelector, comparator);\n\n        model._path = boundPath;\n\n        callback(dataSourceError);\n    }, function onCompleted() {\n        callback(null, resultingJsonGraphEnvelope);\n    });\n\n    return disposable;\n};\n\nmodule.exports = sendSetRequest;\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar SetResponse = __webpack_require__(57);\nvar ModelResponse = __webpack_require__(4);\nvar InvalidSourceError = __webpack_require__(10);\nvar __version = __webpack_require__(20);\n\n/**\n * @private\n * @augments ModelResponse\n */\nfunction CallResponse(model, callPath, args, suffix, paths) {\n    this.callPath = callPath;\n    this.args = args;\n\n    if (paths) {\n        this.paths = paths;\n    }\n    if (suffix) {\n        this.suffix = suffix;\n    }\n    this.model = model;\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n}\n\nCallResponse.prototype = Object.create(ModelResponse.prototype);\nCallResponse.prototype._subscribe = function _subscribe(observer) {\n    var callPath = this.callPath;\n    var callArgs = this.args;\n    var suffixes = this.suffix;\n    var extraPaths = this.paths;\n    var model = this.model;\n    var rootModel = model._clone({\n        _path: []\n    });\n    var boundPath = model._path;\n    var boundCallPath = boundPath.concat(callPath);\n    var initialCacheVersion = this.initialCacheVersion;\n\n    /* eslint-disable consistent-return */\n    // Precisely the same error as the router when a call function does not\n    // exist.\n    if (!model._source) {\n        observer.onError(new Error(\"function does not exist\"));\n        return;\n    }\n\n    var response, obs;\n    try {\n        obs = model._source.call(boundCallPath, callArgs, suffixes, extraPaths);\n    } catch (e) {\n        observer.onError(new InvalidSourceError(e));\n        return;\n    }\n\n    return obs.subscribe(function (res) {\n        response = res;\n    }, function (err) {\n        observer.onError(err);\n    }, function () {\n\n        // Run the invalidations first then the follow up JSONGraph set.\n        var invalidations = response.invalidated;\n        if (invalidations && invalidations.length) {\n            // Increment `syncRefCount` here to block calling the _root's\n            // onChangesCompleted handler.\n            ++model._root.syncRefCount;\n            rootModel.invalidate.apply(rootModel, invalidations);\n            --model._root.syncRefCount;\n        }\n\n        // Use the SetResponse directly so we can specify the\n        // initialCacheVersion from before the call operation was invoked.\n        return new SetResponse(rootModel.withoutDataSource(), [response], false, false, initialCacheVersion).subscribe(function (x) {\n            observer.onNext(x);\n        }, function (err) {\n            observer.onError(err);\n        }, function () {\n            observer.onCompleted();\n        });\n    });\n    /* eslint-enable consistent-return */\n};\n\nmodule.exports = CallResponse;\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar ModelResponse = __webpack_require__(4);\nvar isPathValue = __webpack_require__(23);\nvar isJSONEnvelope = __webpack_require__(22);\nvar noop = __webpack_require__(24);\nvar empty = { dispose: noop, unsubscribe: noop };\nvar __version = __webpack_require__(20);\nvar isFunction = __webpack_require__(2);\n\nfunction InvalidateResponse(model, args, initialCacheVersion) {\n    // TODO: This should be removed.  There should only be 1 type of arguments\n    // coming in, but we have strayed from documentation.\n    this._model = model;\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof initialCacheVersion === \"number\") {\n        this.initialCacheVersion = initialCacheVersion;\n    } else if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg)) {\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        } else {\n            throw new Error(\"Invalid Input\");\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n}\n\nInvalidateResponse.prototype = Object.create(ModelResponse.prototype);\nInvalidateResponse.prototype.progressively = function progressively() {\n    return this;\n};\nInvalidateResponse.prototype._toJSONG = function _toJSONG() {\n    return this;\n};\n\nInvalidateResponse.prototype._subscribe = function _subscribe(observer) {\n\n    var model = this._model;\n    this._groups.forEach(function (group) {\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n        var operationName = \"_invalidate\" + inputType;\n        var operationFunc = model[operationName];\n        operationFunc(model, methodArgs);\n    });\n    observer.onCompleted();\n\n    var modelRoot = model._root;\n    var modelCache = modelRoot.cache;\n    var currentVersion = modelCache[__version];\n    var initialCacheVersion = this.initialCacheVersion;\n    var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n    if (initialCacheVersion !== currentVersion && modelRoot.syncRefCount <= 0 && isFunction(rootOnChangesCompletedHandler)) {\n        rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n    }\n\n    return empty;\n};\n\nmodule.exports = InvalidateResponse;\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar checkCacheAndReport = __webpack_require__(55);\nvar MaxRetryExceededError = __webpack_require__(47);\nvar collectLru = __webpack_require__(30);\nvar getSize = __webpack_require__(7);\nvar AssignableDisposable = __webpack_require__(53);\nvar InvalidSourceError = __webpack_require__(10);\nvar isFunction = __webpack_require__(2);\n\n/**\n * The get request cycle for checking the cache and reporting\n * values.  If there are missing paths then the async request cycle to\n * the data source is performed until all paths are resolved or max\n * requests are made.\n * @param {GetResponse} getResponse -\n * @param {Model} model - The model that the request was made with.\n * @param {Object} results -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @private\n */\nmodule.exports = function getRequestCycle(getResponse, model, results, observer, errors, count, initialCacheVersion) {\n    // we have exceeded the maximum retry limit.\n    if (count === 10) {\n        throw new MaxRetryExceededError();\n    }\n\n    var requestQueue = model._request;\n    var requestedMissingPaths = results.requestedMissingPaths;\n    var optimizedMissingPaths = results.optimizedMissingPaths;\n    var disposable = new AssignableDisposable();\n\n    // We need to prepend the bound path to all requested missing paths and\n    // pass those into the requestQueue.\n    var boundRequestedMissingPaths = [];\n    var boundPath = model._path;\n    if (boundPath.length) {\n        for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {\n            boundRequestedMissingPaths[i] = fastCat(boundPath, requestedMissingPaths[i]);\n        }\n    }\n\n    // No bound path, no array copy and concat.\n    else {\n            boundRequestedMissingPaths = requestedMissingPaths;\n        }\n\n    var currentRequestDisposable = requestQueue.get(boundRequestedMissingPaths, optimizedMissingPaths, function (err) {\n\n        if (err instanceof InvalidSourceError) {\n            observer.onError(err);\n            return;\n        }\n\n        // Once the request queue finishes, check the cache and bail if\n        // we can.\n        var nextResults = checkCacheAndReport(model, requestedMissingPaths, observer, getResponse.isProgressive, getResponse.isJSONGraph, results.values, errors);\n\n        // If there are missing paths coming back form checkCacheAndReport\n        // the its reported from the core cache check method.\n        if (nextResults) {\n\n            // update the which disposable to use.\n            disposable.currentDisposable = getRequestCycle(getResponse, model, nextResults, observer, errors, count + 1, initialCacheVersion);\n        }\n\n        // We have finished.  Since we went to the dataSource, we must\n        // collect on the cache.\n        else {\n\n                var modelRoot = model._root;\n                var modelCache = modelRoot.cache;\n                var currentVersion = modelCache.ツversion;\n\n                collectLru(modelRoot, modelRoot.expired, getSize(modelCache), model._maxSize, model._collectRatio, currentVersion);\n\n                var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n                if (initialCacheVersion !== currentVersion && modelRoot.syncRefCount <= 0 && isFunction(rootOnChangesCompletedHandler)) {\n                    rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n                }\n            }\n    });\n    disposable.currentDisposable = currentRequestDisposable;\n    return disposable;\n};\n\nfunction fastCat(arr1, arr2) {\n    var a = [],\n        i,\n        len,\n        j;\n    for (i = 0, len = arr1.length; i < len; i++) {\n        a[i] = arr1[i];\n    }\n    for (j = 0, len = arr2.length; j < len; j++) {\n        a[i++] = arr2[j];\n    }\n    return a;\n}\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar ModelResponse = __webpack_require__(4);\nvar GET_VALID_INPUT = __webpack_require__(56);\nvar validateInput = __webpack_require__(37);\nvar GetResponse = __webpack_require__(54);\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nmodule.exports = function get(...paths) {\n    // Validates the input.  If the input is not pathSets or strings then we\n    // will onError.\n    var out = validateInput(paths, GET_VALID_INPUT, \"get\");\n    if (out !== true) {\n        return new ModelResponse(function (o) {\n            o.onError(out);\n        });\n    }\n\n    return new GetResponse(this, paths);\n};\n\n/***/ },\n/* 110 */\n/***/ function(module, exports) {\n\nmodule.exports = mergeInto;\n\n/* eslint-disable camelcase */\nfunction mergeInto(dest, node) {\n\n    var destValue,\n        nodeValue,\n        key,\n        keys = Object.keys(node),\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key !== \"$__path\" && key !== \"$__refPath\" && key !== \"$__toReference\") {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (destValue === undefined || \"object\" !== typeof nodeValue) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    var $__path = node.$__path;\n\n    if ($__path) {\n        dest.$__path = $__path;\n        var $__refPath = node.$__refPath;\n        var $__toReference = node.$__toReference;\n        if ($__refPath && $__toReference) {\n            dest.$__refPath = $__refPath;\n            dest.$__toReference = $__toReference;\n        }\n    }\n\n    return dest;\n}\n/* eslint-enable */\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar setValidInput = __webpack_require__(114);\nvar validateInput = __webpack_require__(37);\nvar SetResponse = __webpack_require__(57);\nvar ModelResponse = __webpack_require__(4);\n\nmodule.exports = function set() {\n    var out = validateInput(arguments, setValidInput, \"set\");\n    if (out !== true) {\n        return new ModelResponse(function (o) {\n            o.onError(out);\n        });\n    }\n\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    var args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n    }\n    return new SetResponse(this, args);\n};\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arrayFlatMap = __webpack_require__(118);\n\n/**\n * Takes the groups that are created in the SetResponse constructor and sets\n * them into the cache.\n */\nmodule.exports = function setGroupsIntoCache(model, groups) {\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var groupIndex = -1;\n    var groupCount = groups.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var returnValue = {\n        requestedPaths: requestedPaths,\n        optimizedPaths: optimizedPaths\n    };\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = groups[groupIndex];\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n\n        if (methodArgs.length > 0) {\n            var operationName = \"_set\" + inputType;\n            var operationFunc = model[operationName];\n            var successfulPaths = operationFunc(model, methodArgs, errorSelector);\n\n            optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);\n\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));\n            } else if (inputType === \"JSONGs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, successfulPaths[0]);\n            }\n        }\n    }\n\n    return returnValue;\n};\n\nfunction pluckPath(pathValue) {\n    return pathValue.path;\n}\n\nfunction pluckEnvelopePaths(jsonGraphEnvelope) {\n    return jsonGraphEnvelope.paths;\n}\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar emptyArray = [];\nvar AssignableDisposable = __webpack_require__(53);\nvar GetResponse = __webpack_require__(54);\nvar setGroupsIntoCache = __webpack_require__(112);\nvar getWithPathsAsPathMap = __webpack_require__(28).getWithPathsAsPathMap;\nvar InvalidSourceError = __webpack_require__(10);\nvar MaxRetryExceededError = __webpack_require__(47);\n\n/**\n * The request cycle for set.  This is responsible for requesting to dataSource\n * and allowing disposing inflight requests.\n */\nmodule.exports = function setRequestCycle(model, observer, groups, isJSONGraph, isProgressive, count, initialCacheVersion) {\n    // we have exceeded the maximum retry limit.\n    if (count === 10) {\n        throw new MaxRetryExceededError();\n    }\n\n    var requestedAndOptimizedPaths = setGroupsIntoCache(model, groups);\n    var optimizedPaths = requestedAndOptimizedPaths.optimizedPaths;\n    var requestedPaths = requestedAndOptimizedPaths.requestedPaths;\n    var isMaster = model._source === undefined;\n\n    // Local set only.  We perform a follow up get.  If performance is ever\n    // a requirement simply requiring in checkCacheAndReport and use get request\n    // internals.  Figured this is more \"pure\".\n    if (isMaster) {\n        return subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph, isProgressive, initialCacheVersion);\n    }\n\n    // Progressively output the data from the first set.\n    if (isProgressive) {\n        var results = getWithPathsAsPathMap(model, requestedPaths, [{}]);\n        if (results.criticalError) {\n            observer.onError(results.criticalError);\n            return null;\n        }\n        observer.onNext(results.values[0]);\n    }\n\n    var currentJSONGraph = getJSONGraph(model, optimizedPaths);\n    var disposable = new AssignableDisposable();\n\n    // Sends out the setRequest.  The Queue will call the callback with the\n    // JSONGraph envelope / error.\n    var requestDisposable = model._request.\n    // TODO: There is error handling that has not been addressed yet.\n\n    // If disposed before this point then the sendSetRequest will not\n    // further any callbacks.  Therefore, if we are at this spot, we are\n    // not disposed yet.\n    set(currentJSONGraph, function (error, jsonGraphEnv) {\n        if (typeof error === InvalidSourceError) {\n            observer.onError(error);\n            return;\n        }\n\n        // TODO: This seems like there are errors with this approach, but\n        // for sanity sake I am going to keep this logic in here until a\n        // rethink can be done.\n        var isCompleted = false;\n        if (error || optimizedPaths.length === jsonGraphEnv.paths.length) {\n            isCompleted = true;\n        }\n\n        // Happy case.  One request to the dataSource will fulfill the\n        // required paths.\n        if (isCompleted) {\n            disposable.currentDisposable = subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph, isProgressive, initialCacheVersion);\n        }\n\n        // TODO: The unhappy case.  I am unsure how this can even be\n        // achieved.\n        else {\n                // We need to restart the setRequestCycle.\n                setRequestCycle(model, observer, groups, isJSONGraph, isProgressive, count + 1, initialCacheVersion);\n            }\n    });\n\n    // Sets the current disposable as the requestDisposable.\n    disposable.currentDisposable = requestDisposable;\n\n    return disposable;\n};\n\nfunction getJSONGraph(model, optimizedPaths) {\n    var boundPath = model._path;\n    var envelope = {};\n    model._path = emptyArray;\n    model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);\n    model._path = boundPath;\n\n    return envelope;\n}\n\nfunction subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph, isProgressive, initialCacheVersion) {\n\n    // Creates a new response and subscribes to it with the original observer.\n    // Also sets forceCollect to true, incase the operation is synchronous and\n    // exceeds the cache limit size\n    var response = new GetResponse(model, requestedPaths, isJSONGraph, isProgressive, true, initialCacheVersion);\n    return response.subscribe(observer);\n}\n\n/***/ },\n/* 114 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n    pathValue: true,\n    pathSyntax: true,\n    json: true,\n    jsonGraph: true\n};\n\n/***/ },\n/* 115 */\n/***/ function(module, exports) {\n\nvar empty = { dispose: function () {} };\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n/***/ },\n/* 116 */\n/***/ function(module, exports) {\n\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    var id = setTimeout(action, this.delay);\n    return new TimerDisposable(id);\n};\n\nTimerDisposable.prototype.dispose = function () {\n    if (this.disposed) {\n        return;\n    }\n\n    clearTimeout(this.id);\n    this.disposed = true;\n};\n\nmodule.exports = TimeoutScheduler;\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar ModelResponse = __webpack_require__(4);\nvar isPathValue = __webpack_require__(23);\n\nmodule.exports = function setValue(pathArg, valueArg) {\n    var value = isPathValue(pathArg) ? pathArg : { path: pathArg, value: valueArg };\n    var pathIdx = 0;\n    var path = value.path;\n    var pathLen = path.length;\n    while (++pathIdx < pathLen) {\n        if (typeof path[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function (o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n    var self = this;\n    return new ModelResponse(function (obs) {\n        return self.set(value).subscribe(function (data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = path.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[path[depth]];\n            }\n            obs.onNext(curr);\n        }, function (err) {\n            obs.onError(err);\n        }, function () {\n            obs.onCompleted();\n        });\n    });\n};\n\n/***/ },\n/* 118 */\n/***/ function(module, exports) {\n\nmodule.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar unicodePrefix = __webpack_require__(5);\nvar hasOwn = __webpack_require__(17);\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(0);\n\nmodule.exports = function clone(value) {\n    var dest = value;\n    if (isObject(dest)) {\n        dest = isArray(value) ? [] : {};\n        var src = value;\n        for (var key in src) {\n            if (key.charAt(0) === unicodePrefix || !hasOwn(src, key)) {\n                continue;\n            }\n            dest[key] = src[key];\n        }\n    }\n    return dest;\n};\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(0);\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(34);\nvar $now = __webpack_require__(39);\nvar $never = __webpack_require__(38);\n\nmodule.exports = function isAlreadyExpired(node) {\n    var exp = node.$expires;\n    return exp != null && exp !== $never && exp !== $now && exp < now();\n};\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar unicodePrefix = __webpack_require__(5);\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nmodule.exports = function isInternalKey(x) {\n  return x === \"$size\" || x === \"$modelCreated\" || x.charAt(0) === unicodePrefix;\n};\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $ref = __webpack_require__(1);\nvar $error = __webpack_require__(19);\nvar getSize = __webpack_require__(7);\nvar getTimestamp = __webpack_require__(58);\nvar isObject = __webpack_require__(0);\nvar isExpired = __webpack_require__(3);\nvar isFunction = __webpack_require__(2);\n\nvar wrapNode = __webpack_require__(64);\nvar insertNode = __webpack_require__(59);\nvar expireNode = __webpack_require__(6);\nvar replaceNode = __webpack_require__(62);\nvar updateNodeAncestors = __webpack_require__(18);\nvar reconstructPath = __webpack_require__(61);\n\nmodule.exports = function mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n    var sizeOffset;\n\n    var cType, mType, cIsObject, mIsObject, cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n\n        // The messange and cache are both undefined, therefore return null.\n        else if (message === undefined) {\n                return message;\n            } else {\n                cIsObject = isObject(node);\n                if (cIsObject) {\n                    // Is the cache node a branch? If so, return the cache branch.\n                    cType = node.$type;\n                    if (cType == null) {\n                        // Has the branch been introduced to the cache yet? If not,\n                        // give it a parent, key, and absolute path.\n                        if (node.ツparent == null) {\n                            insertNode(node, parent, key, version, optimizedPath);\n                        }\n                        return node;\n                    }\n                }\n            }\n    } else {\n        cIsObject = isObject(node);\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || mIsObject && !mType) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n            // If the cache is a reference, but the message is empty, leave the cache alone...\n            if (message == null) {\n                // ...unless the cache is an expired reference. In that case, expire\n                // the cache node and return undefined.\n                if (isExpired(node)) {\n                    expireNode(node, expired, lru);\n                    return void 0;\n                }\n                return node;\n            }\n            mIsObject = isObject(message);\n            if (mIsObject) {\n                mType = message.$type;\n                // If the cache and the message are both references,\n                // check if we need to replace the cache reference.\n                if (mType === $ref) {\n                    if (node === message) {\n                        // If the cache and message are the same reference,\n                        // we performed a whole-branch merge of one of the\n                        // grandparents. If we've previously graphed this\n                        // reference, break early. Otherwise, continue to\n                        // leaf insertion below.\n                        if (node.ツparent != null) {\n                            return node;\n                        }\n                    } else {\n\n                        cTimestamp = node.$timestamp;\n                        mTimestamp = message.$timestamp;\n\n                        // - If either the cache or message reference is expired,\n                        //   replace the cache reference with the message.\n                        // - If neither of the references are expired, compare their\n                        //   timestamps. If either of them don't have a timestamp,\n                        //   or the message's timestamp is newer, replace the cache\n                        //   reference with the message reference.\n                        // - If the message reference is older than the cache\n                        //   reference, short-circuit.\n                        if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {\n                            return void 0;\n                        }\n                    }\n                }\n            }\n        }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n            // If the cache and the message are the same value, we branch-merged one\n            // of the message's ancestors. If this is the first time we've seen this\n            // leaf, give the message a $size and $type, attach its graph pointers,\n            // and update the cache sizes and versions.\n\n            if (mType === $error && isFunction(errorSelector)) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            if (mType && node === message) {\n                if (node.ツparent == null) {\n                    node = wrapNode(node, cType, node.value);\n                    parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                    node = insertNode(node, parent, key, version, optimizedPath);\n                }\n            }\n            // If the cache and message are different, the cache value is expired,\n            // or the message is a primitive, replace the cache with the message value.\n            // If the message is a sentinel, clone and maintain its type.\n            // If the message is a primitive value, wrap it in an atom.\n            else {\n                    var isDistinct = true;\n                    // If the cache is a branch, but the message is a leaf, replace the\n                    // cache branch with the message leaf.\n                    if (cType && !isExpired(node) || !cIsObject) {\n                        // Compare the current cache value with the new value. If either of\n                        // them don't have a timestamp, or the message's timestamp is newer,\n                        // replace the cache value with the message value. If a comparator\n                        // is specified, the comparator takes precedence over timestamps.\n                        //\n                        // Comparing either Number or undefined to undefined always results in false.\n                        isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                        // If at least one of the cache/message are sentinels, compare them.\n                        if (isDistinct && (cType || mType) && isFunction(comparator)) {\n                            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                        }\n                    }\n                    if (isDistinct) {\n                        message = wrapNode(message, mType, mType ? message.value : message);\n                        sizeOffset = getSize(node) - getSize(message);\n                        node = replaceNode(node, message, parent, key, lru, version);\n                        parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                    }\n                }\n\n            // Promote the message edge in the LRU.\n            if (isExpired(node)) {\n                expireNode(node, expired, lru);\n            }\n        } else if (node == null) {\n            node = insertNode(message, parent, key, undefined, optimizedPath);\n        }\n\n    return node;\n};\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __ref = __webpack_require__(12);\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode.ツrefsLength || 0,\n        destNodeRefsLength = destNode.ツrefsLength || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[__ref + i];\n        if (ref !== void 0) {\n            ref.ツcontext = destNode;\n            destNode[__ref + (destNodeRefsLength + i)] = ref;\n            fromNode[__ref + i] = void 0;\n        }\n    }\n    destNode.ツrefsLength = fromNodeRefsLength + destNodeRefsLength;\n    fromNode.ツrefsLength = void 0;\n    return destNode;\n};\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __ref = __webpack_require__(12);\n\nmodule.exports = function unlinkBackReferences(node) {\n    var i = -1,\n        n = node.ツrefsLength || 0;\n    while (++i < n) {\n        var ref = node[__ref + i];\n        if (ref != null) {\n            ref.ツcontext = ref.ツrefIndex = node[__ref + i] = void 0;\n        }\n    }\n    node.ツrefsLength = void 0;\n    return node;\n};\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __ref = __webpack_require__(12);\n\nmodule.exports = function unlinkForwardReference(reference) {\n    var destination = reference.ツcontext;\n    if (destination) {\n        var i = (reference.ツrefIndex || 0) - 1,\n            n = (destination.ツrefsLength || 0) - 1;\n        while (++i <= n) {\n            destination[__ref + i] = destination[__ref + (i + 1)];\n        }\n        destination.ツrefsLength = n;\n        reference.ツrefIndex = reference.ツcontext = destination = void 0;\n    }\n    return reference;\n};\n\n/***/ },\n/* 128 */\n/***/ function(module, exports) {\n\n/**\n * FromEsObserverAdapter is an adpater from an ES Observer to an Rx 2 Observer\n * @constructor FromEsObserverAdapter\n*/\nfunction FromEsObserverAdapter(esObserver) {\n    this.esObserver = esObserver;\n}\n\nFromEsObserverAdapter.prototype = {\n    onNext: function onNext(value) {\n        if (typeof this.esObserver.next === \"function\") {\n            this.esObserver.next(value);\n        }\n    },\n    onError: function onError(error) {\n        if (typeof this.esObserver.error === \"function\") {\n            this.esObserver.error(error);\n        }\n    },\n    onCompleted: function onCompleted() {\n        if (typeof this.esObserver.complete === \"function\") {\n            this.esObserver.complete();\n        }\n    }\n};\n\n/**\n * ToEsSubscriptionAdapter is an adpater from the Rx 2 subscription to the ES subscription\n * @constructor ToEsSubscriptionAdapter\n*/\nfunction ToEsSubscriptionAdapter(subscription) {\n    this.subscription = subscription;\n}\n\nToEsSubscriptionAdapter.prototype.unsubscribe = function unsubscribe() {\n    this.subscription.dispose();\n};\n\nfunction toEsObservable(_self) {\n    return {\n        subscribe: function subscribe(observer) {\n            return new ToEsSubscriptionAdapter(_self.subscribe(new FromEsObserverAdapter(observer)));\n        }\n    };\n}\n\nmodule.exports = toEsObservable;\n\n/***/ },\n/* 129 */\n/***/ function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 130 */\n/***/ function(module, exports) {\n\n/* (ignored) */\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(67);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// falcor.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 131);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0b71c4faad932f646d3a","var objTypeof = \"object\";\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isObject.js","module.exports = \"ref\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/types/ref.js","var functionTypeof = \"function\";\n\nmodule.exports = function isFunction(func) {\n    return Boolean(func) && typeof func === functionTypeof;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isFunction.js","var now = require(\"./../support/now\");\nvar $now = require(\"../values/expires-now\");\nvar $never = require(\"../values/expires-never\");\n\nmodule.exports = function isExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never ) && (\n        exp === $now || exp < now());\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isExpired.js","var noop = require(\"./../support/noop\");\nvar Symbol = require(\"../SymbolShim\");\nvar toEsObservable = require(\"../toEsObservable\");\n\n/**\n * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.\n * @constructor ModelResponse\n * @augments Observable\n*/\nfunction ModelResponse(subscribe) {\n    this._subscribe = subscribe;\n}\n\nModelResponse.prototype[Symbol.observable] = function SymbolObservable() {\n    return toEsObservable(this);\n};\n\nModelResponse.prototype._toJSONG = function toJSONG() {\n    return this;\n};\n\n/**\n * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.\n * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.\n * @name progressively\n * @memberof ModelResponse.prototype\n * @function\n * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.\n * @example\nvar dataSource = (new falcor.Model({\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\",\n      age: 31\n    }\n  }\n})).asDataSource();\n\nvar model = new falcor.Model({\n  source: dataSource,\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n  }\n});\n\nmodel.\n  get([\"user\",[\"name\", \"surname\", \"age\"]]).\n  progressively().\n  // this callback will be invoked twice, once with the data in the\n  // Model cache, and again with the additional data retrieved from the DataSource.\n  subscribe(function(json){\n    console.log(JSON.stringify(json,null,4));\n  });\n\n// prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\"\n//         }\n//     }\n// }\n// ...and then prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\",\n//             \"age\": 31\n//         }\n//     }\n// }\n*/\nModelResponse.prototype.progressively = function progressively() {\n    return this;\n};\n\nModelResponse.prototype.subscribe =\nModelResponse.prototype.forEach = function subscribe(a, b, c) {\n    var observer = a;\n    if (observer && typeof observer === \"object\") {\n        if (!(observer.onNext || observer.onError || observer.onCompleted)) {\n            observer = {\n                onNext: (observer.next || noop).bind(observer),\n                onError: (observer.error || noop).bind(observer),\n                onCompleted: (observer.complete || noop).bind(observer)\n            };\n        }\n    } else {\n        observer = {\n            onNext: a || noop,\n            onError: b || noop,\n            onCompleted: c || noop\n        };\n    }\n    var subscription = this._subscribe(observer);\n    switch (typeof subscription) {\n        case \"function\":\n            return { dispose: subscription, unsubscribe: subscription };\n        case \"object\":\n            return subscription || { dispose: noop, unsubscribe: noop };\n        default:\n            return { dispose: noop, unsubscribe: noop };\n    }\n};\n\nModelResponse.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var self = this;\n    if (!self._promise) {\n        self._promise = new Promise(function(resolve, reject) {\n            var rejected = false;\n            var values = [];\n            self.subscribe(\n                function(value) {\n                    values[values.length] = value;\n                },\n                function(errors) {\n                    rejected = true;\n                    reject(errors);\n                },\n                function() {\n                    var value = values;\n                    if (values.length <= 1) {\n                        value = values[0];\n                    }\n\n                    if (rejected === false) {\n                        resolve(value);\n                    }\n                }\n            );\n        });\n    }\n    return self._promise.then(onNext, onError);\n};\n\nmodule.exports = ModelResponse;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/ModelResponse.js","module.exports = \"ツ\";\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/unicodePrefix.js","var splice = require(\"./../lru/splice\");\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node.ツinvalidated) {\n        node.ツinvalidated = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/expireNode.js","var isObject = require(\"./../support/isObject\");\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getSize.js","module.exports = {\n    iterateKeySet: require('./iterateKeySet'),\n    toTree: require('./toTree'),\n    toTreeWithUnion: require('./toTreeWithUnion'),\n    pathsComplementFromTree: require('./pathsComplementFromTree'),\n    pathsComplementFromLengthTree: require('./pathsComplementFromLengthTree'),\n    hasIntersection: require('./hasIntersection'),\n    toPaths: require('./toPaths'),\n    collapse: require('./collapse'),\n    optimizePathSets: require('./optimizePathSets'),\n    pathCount: require('./pathCount')\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/index.js\n// module id = 8\n// module chunks = 0","var objTypeof = \"object\";\nmodule.exports = function isPrimitive(value) {\n    return value == null || typeof value !== objTypeof;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isPrimitive.js","var NAME = \"InvalidSourceError\";\nvar MESSAGE = \"An exception was thrown when making a request.\";\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidSourceError(error) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.innerError = error;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidSourceError.prototype = Object.create(Error.prototype);\nInvalidSourceError.prototype.name = NAME;\nInvalidSourceError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidSourceError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidSourceError.js","var getCachePosition = require(\"./../get/getCachePosition\");\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node.ツparent === undefined || node.ツinvalidated) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/getBoundCacheNode.js","module.exports = require(\"./unicodePrefix\") + \"ref\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/ref.js","var __ref = require(\"./../internal/ref\");\n\nmodule.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to.ツrefsLength || 0;\n    to[__ref + backRefs] = from;\n    to.ツrefsLength = backRefs + 1;\n\n    // create a hard reference\n    from.ツrefIndex = backRefs;\n    from.ツcontext = to;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/createHardlink.js","var NAME = \"NullInPathError\";\nvar MESSAGE = \"`null` is not allowed in branch key positions.\";\n\n/**\n * Does not allow null in path\n */\nfunction NullInPathError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nNullInPathError.prototype = Object.create(Error.prototype);\nNullInPathError.prototype.name = NAME;\nNullInPathError.message = MESSAGE;\n\nmodule.exports = NullInPathError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NullInPathError.js","var unicodePrefix = require(\"./../internal/unicodePrefix\");\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key, keys = Object.keys(node),\n        json = {}, index = -1, length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (key.charAt(0) === unicodePrefix) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/clone.js","var EXPIRES_NEVER = require(\"./../values/expires-never\");\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root.ツhead;\n\n    // Nothing is in the cache.\n    if (!head) {\n        root.ツhead = root.ツtail = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object.ツprev;\n    var next = object.ツnext;\n    if (next) {\n        next.ツprev = prev;\n    }\n    if (prev) {\n        prev.ツnext = next;\n    }\n    object.ツprev = undefined;\n\n    // Insert into head position\n    root.ツhead = object;\n    object.ツnext = head;\n    head.ツprev = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root.ツtail) {\n        root.ツtail = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/promote.js","var isObject = require(\"./isObject\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function(obj, prop) {\n  return isObject(obj) && hasOwn.call(obj, prop);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/hasOwn.js","var removeNode = require(\"./../support/removeNode\");\nvar updateBackReferenceVersions = require(\"./../support/updateBackReferenceVersions\");\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child.ツparent;\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child.ツkey, lru);\n        } else if (child.ツversion !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/updateNodeAncestors.js","module.exports = \"error\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/types/error.js","module.exports = require(\"./unicodePrefix\") + \"version\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/version.js","var arr = new Array(5);\nvar $ref = require(\"./../types/ref\");\nvar createHardlink = require(\"./../support/createHardlink\");\nvar isExpired = require(\"./../support/isAlreadyExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar iterateKeySet = require(\"@graphistry/falcor-path-utils\").iterateKeySet;\nvar mergeJSONGraphNode = require(\"./../support/mergeJSONGraphNode\");\nvar NullInPathError = require(\"./../errors/NullInPathError\");\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var initialVersion = cache.ツversion;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(\n                root, parent, node, messageRoot, messageParent, message,\n                key, branch, true, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            optimizedPath = results[4];\n            if (isPrimitive(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container.ツcontext !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node.ツkey;\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(\n            parent, node, message, key, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/set/setJSONGraphs.js","var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && (\"json\" in envelope);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONEnvelope.js","var isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === \"string\"\n        ));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isPathValue.js","module.exports = function noop() {};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/noop.js","module.exports = \"atom\";\n\n\n\n// WEBPACK FOOTER //\n// ./lib/types/atom.js","var isArray = Array.isArray;\nvar nullTerminator = require('./support/nullTerminator');\n\nmodule.exports = hasIntersection\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\n\nfunction hasIntersection(tree, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var intersects = true;\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return tree === nullTerminator;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                if (tree[nextKey] !== null) {\n                    return false;\n                }\n            } else {\n                next = tree[nextKey];\n                if (next === null || next === undefined) {\n                    return false;\n                } else if (hasIntersection(next, path, nextDepth, length) === false) {\n                    return false;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return true;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/hasIntersection.js\n// module id = 26\n// module chunks = 0","module.exports = { $__null__$: null };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/support/nullTerminator.js\n// module id = 27\n// module chunks = 0","module.exports = {\n    getWithPathsAsPathMap: require(\"./json/getJSON\"),\n    getWithPathsAsJSONGraph: require(\"./jsonGraph/getJSONGraph\")\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/index.js","module.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed) {\n\n    var key, depth = 0, prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        curr = {};\n        seed.jsonGraph = curr;\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = node;\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/jsonGraph/inlineValue.js","var removeNode = require(\"./../support/removeNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node.ツparent) {  // eslint-disable-line no-cond-assign\n            removeNode(node, parent, node.ツkey, lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru.ツtail;\n        node = prev;\n        while ((total >= targetSize) && node) {\n            prev = prev.ツprev;\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru.ツtail = lru.ツprev = node;\n        if (node == null) {\n            lru.ツhead = lru.ツnext = undefined;\n        } else {\n            node.ツnext = undefined;\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/collect.js","var arr = new Array(3);\nvar isArray = Array.isArray;\nvar $ref = require(\"./../types/ref\");\nvar __prefix = require(\"./../internal/unicodePrefix\");\nvar createHardlink = require(\"./../support/createHardlink\");\nvar getBoundCacheNode = require(\"./../get/getBoundCacheNode\");\nvar hasOwn = require(\"./../support/hasOwn\");\nvar isObject = require(\"./../support/isObject\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar mergeValueOrInsertBranch = require(\"./../support/mergeValueOrInsertBranch\");\nvar NullInPathError = require(\"./../errors/NullInPathError\");\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node.ツcontext;\n\n        if (node != null) {\n            parent = node.ツparent || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (isPrimitive(node)) {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container.ツcontext !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (type === void 0) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node.ツkey;\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (isObject(pathMap) && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === __prefix || key[0] === \"$\" || !hasOwn(pathMap, key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/set/setPathMaps.js","var arr = new Array(3);\nvar $ref = require(\"./../types/ref\");\nvar createHardlink = require(\"./../support/createHardlink\");\nvar getBoundCacheNode = require(\"./../get/getBoundCacheNode\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar iterateKeySet = require(\"@graphistry/falcor-path-utils\").iterateKeySet;\nvar mergeValueOrInsertBranch = require(\"./../support/mergeValueOrInsertBranch\");\nvar NullInPathError = require(\"./../errors/NullInPathError\");\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node.ツcontext;\n\n        if (node != null) {\n            parent = node.ツparent || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (isPrimitive(node)) {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container.ツcontext !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node.ツkey;\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/set/setPathValues.js","var isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONGraphEnvelope.js","module.exports = Date.now;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/now.js","var $ref = require(\"./../types/ref\");\nvar splice = require(\"./../lru/splice\");\nvar isObject = require(\"./../support/isObject\");\nvar unlinkBackReferences = require(\"./../support/unlinkBackReferences\");\nvar unlinkForwardReference = require(\"./../support/unlinkForwardReference\");\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (isObject(node)) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            splice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node.ツparent = void 0;\n        return true;\n    }\n    return false;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/removeNode.js","var hasOwn = require(\"./../support/hasOwn\");\nvar prefix = require(\"./../internal/unicodePrefix\");\nvar removeNode = require(\"./../support/removeNode\");\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (key2[0] !== prefix && key2[0] !== \"$\" && hasOwn(node, key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/removeNodeAndDescendants.js","var isArray = Array.isArray;\nvar isPathValue = require(\"./../support/isPathValue\");\nvar isJSONGraphEnvelope = require(\"./../support/isJSONGraphEnvelope\");\nvar isJSONEnvelope = require(\"./../support/isJSONEnvelope\");\n\n/**\n *\n * @param {Object} allowedInput - allowedInput is a map of input styles\n * that are allowed\n * @private\n */\nmodule.exports = function validateInput(args, allowedInput, method) {\n    for (var i = 0, len = args.length; i < len; ++i) {\n        var arg = args[i];\n        var valid = false;\n\n        // Path\n        if (isArray(arg) && allowedInput.path) {\n            valid = true;\n        }\n\n        // Path Syntax\n        // else if (typeof arg === \"string\" && allowedInput.pathSyntax) {\n        //     valid = true;\n        // }\n\n        // Path Value\n        else if (isPathValue(arg) && allowedInput.pathValue) {\n            valid = true;\n        }\n\n        // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}\n        else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {\n            valid = true;\n        }\n\n        // json env {json: {...}}\n        else if (isJSONEnvelope(arg) && allowedInput.json) {\n            valid = true;\n        }\n\n        // selector functions\n        else if (typeof arg === \"function\" &&\n                 i + 1 === len &&\n                 allowedInput.selector) {\n            valid = true;\n        }\n\n        if (!valid) {\n            return new Error(\"Unrecognized argument \" + (typeof arg) + \" [\" + String(arg) + \"] \" + \"to Model#\" + method + \"\");\n        }\n    }\n    return true;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/validateInput.js","module.exports = 1;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-never.js","module.exports = 0;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-now.js","var isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/iterateKeySet.js\n// module id = 40\n// module chunks = 0","function cloneArray(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nmodule.exports = cloneArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/support/cloneArray.js\n// module id = 41\n// module chunks = 0","module.exports = {\n    $ref: 'ref',\n    $atom: 'atom',\n    $error: 'error'\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/support/types.js\n// module id = 42\n// module chunks = 0","var isArray = Array.isArray;\nvar typeOfObject = \"object\";\nvar nullTerminator = require('./support/nullTerminator');\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var code = getHashCode(String(depth));\n    var subs = Object.create(null);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = getHashCode(code + key + subCode);\n\n            isNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    if (map === nullTerminator) {\n        keys[len++] = null;\n    } else {\n        for (var key in map) {\n            // if (key === '$__null__$') {\n            //     key = null;\n            // }\n            keys[len++] = key;\n        }\n        if (len > 1) {\n            keys.sort(sort);\n        }\n    }\n    return len;\n}\n\nfunction getHashCode(key) {\n    var code = 5381;\n    var index = -1;\n    var count = key.length;\n    while (++index < count) {\n        code = (code << 5) + code + key.charCodeAt(index);\n    }\n    return String(code);\n}\n\n/**\n * Return true if argument is a number or can be cast to a number\n * @private\n */\nfunction isNumber(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/toPaths.js\n// module id = 43\n// module chunks = 0","var isArray = Array.isArray;\nvar nullTerminator = require('./support/nullTerminator');\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\nmodule.exports = function toTree(paths) {\n    return paths.reduce(function(acc, path) {\n        return innerToTree(acc, path, 0, path.length);\n    }, {});\n};\n\nfunction innerToTree(seed, path, depth, length) {\n\n    if (depth === length) {\n        return true;\n    }\n\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var node, next, nextKey, nextDepth = depth + 1,\n        keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return nullTerminator;\n    }\n\n    seed = seed || {};\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            if (nextDepth === length) {\n                seed[nextKey] = null;\n            } else {\n                node = seed[nextKey];\n                next = innerToTree(node, path, nextDepth, length);\n                if (!next) {\n                    seed[nextKey] = null;\n                } else if (!node) {\n                    seed[nextKey] = next;\n                }\n            }\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return seed;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/toTree.js\n// module id = 44\n// module chunks = 0","var NAME = \"CircularReferenceError\";\n\n/**\n * Does not allow null in path\n */\nfunction CircularReferenceError(referencePath) {\n    var err = Error.call(this, \"Encountered circular reference \" +\n        JSON.stringify(referencePath));\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nCircularReferenceError.prototype = Object.create(Error.prototype);\nCircularReferenceError.prototype.name = NAME;\n\nmodule.exports = CircularReferenceError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/CircularReferenceError.js","var NAME = \"InvalidKeySetError\";\nvar MESSAGE = \"Keysets can only contain Keys or Ranges\";\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidKeySetError(path, keysOrRanges) {\n    var err = Error.call(this,\n        \"The KeySet \" + JSON.stringify(keysOrRanges) +\n        \" in path \" + JSON.stringify(path) + \" contains a KeySet. \" + MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidKeySetError.prototype = Object.create(Error.prototype);\nInvalidKeySetError.prototype.name = NAME;\nInvalidKeySetError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidKeySetError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidKeySetError.js","var NAME = \"MaxRetryExceededError\";\nvar MESSAGE = \"The allowed number of retries have been exceeded.\";\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nfunction MaxRetryExceededError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nMaxRetryExceededError.prototype = Object.create(Error.prototype);\nMaxRetryExceededError.prototype.name = NAME;\nMaxRetryExceededError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = MaxRetryExceededError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/MaxRetryExceededError.js","var $ref = require(\"./../types/ref\");\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type, depth = 0;\n    var maxDepth = path.length;\n\n    do {\n        node = node[path[depth]];\n\n        while (node && (type = node.$type) === $ref) {\n            node = getCachePosition(cache, node.value);\n        }\n    } while (++depth < maxDepth && node && !type);\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/getCachePosition.js","var isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength,\n                   optimizedPath, optimizedLength) {\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var lastKeyIsNull = keyset === null;\n    var missDepth = depth,\n        missTotal = requestedLength,\n        missingPath = requestedPath,\n        missingPaths = results.requestedMissingPaths || (\n        results.requestedMissingPaths = []);\n\n    var isRequestedPath = true,\n        index, count, mPath;\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n            missingPaths.push(mPath);\n        } else {\n            missingPaths.push(restPath);\n        }\n\n        isRequestedPath = !isRequestedPath;\n\n        if (isRequestedPath) {\n            break;\n        }\n\n        missDepth = optimizedLength;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n        missingPath = optimizedPath;\n        missingPaths = results.optimizedMissingPaths || (\n            results.optimizedMissingPaths = []);\n    } while (true);\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if (\"object\" !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if (\"number\" !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/onMissing.js","var $atom = require(\"./../types/atom\");\nvar promote = require(\"./../lru/promote\");\nvar isExpired = require(\"./../support/isExpired\");\nvar expireNode = require(\"./../support/expireNode\");\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type,\n                     path, depth, seed, results,\n                     requestedPath, requestedLength,\n                     optimizedPath, optimizedLength,\n                     fromReference, modelRoot, expired,\n                     boxValues, materialized, hasDataSource,\n                     treatErrorsAsValues, onValue, onMissing) {\n\n    if (!node || !type) {\n        if (materialized && !hasDataSource) {\n            if (seed) {\n                results.hasValue = true;\n                return { $type: $atom };\n            }\n            return undefined;\n        } else {\n            return onMissing(path, depth, results,\n                             requestedPath, requestedLength,\n                             optimizedPath, optimizedLength);\n        }\n    } else if (isExpired(node)) {\n        if (!node.ツinvalidated) {\n            expireNode(node, expired, modelRoot);\n        }\n        return onMissing(path, depth, results,\n                         requestedPath, requestedLength,\n                         optimizedPath, optimizedLength);\n    }\n\n    promote(modelRoot, node);\n\n    if (seed) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n        }\n        return onValue(node, type, depth, seed, results,\n                       requestedPath, optimizedPath, optimizedLength,\n                       fromReference, boxValues, materialized, treatErrorsAsValues);\n    }\n\n    return undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/onValueType.js","module.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object.ツprev;\n    var next = object.ツnext;\n    if (next) {\n        next.ツprev = prev;\n    }\n    if (prev) {\n        prev.ツnext = next;\n    }\n    object.ツprev = object.ツnext = undefined;\n\n    if (object === root.ツhead) {\n        root.ツhead = next;\n    }\n    if (object === root.ツtail) {\n        root.ツtail = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/splice.js","module.exports = {\n    GetRequest: \"GET\"\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/RequestTypes.js","/**\n * Will allow for state tracking of the current disposable.  Also fulfills the\n * disposable interface.\n * @private\n */\nvar AssignableDisposable = function AssignableDisposable(disosableCallback) {\n    this.disposed = false;\n    this.currentDisposable = disosableCallback;\n};\n\n\nAssignableDisposable.prototype = {\n\n    unsubscribe: function unsubscribe() {\n        return this.dispose();\n    },\n    /**\n     * Disposes of the current disposable.  This would be the getRequestCycle\n     * disposable.\n     */\n    dispose: function dispose() {\n\n        if (this.disposed || !this.currentDisposable) {\n            return;\n        }\n\n        this.disposed = true;\n\n        // If the current disposable fulfills the disposable interface or just\n        // a disposable function.\n        var currentDisposable = this.currentDisposable;\n        this.currentDisposable = null;\n\n        if (currentDisposable.dispose) {\n            currentDisposable.dispose();\n        } else if (currentDisposable.unsubscribe) {\n            currentDisposable.unsubscribe();\n        } else if (typeof currentDisposable === \"function\") {\n            currentDisposable();\n        }\n    }\n};\n\n\nmodule.exports = AssignableDisposable;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/AssignableDisposable.js","var ModelResponse = require(\"./../ModelResponse\");\nvar checkCacheAndReport = require(\"./checkCacheAndReport\");\nvar getRequestCycle = require(\"./getRequestCycle\");\nvar noop = require(\"./../../support/noop\");\nvar empty = { dispose: noop, unsubscribe: noop };\nvar collectLru = require(\"./../../lru/collect\");\nvar getSize = require(\"./../../support/getSize\");\nvar __version = require(\"./../../internal/version\");\nvar isFunction = require(\"./../../support/isFunction\");\n\n/**\n * The get response.  It takes in a model and paths and starts\n * the request cycle.  It has been optimized for cache first requests\n * and closures.\n * @param {Model} model -\n * @param {Array} paths -\n * @augments ModelResponse\n * @private\n */\nvar GetResponse = module.exports = function GetResponse(model, paths,\n                                                        isJSONGraph,\n                                                        isProgressive,\n                                                        forceCollect,\n                                                        initialCacheVersion) {\n    this.model = model;\n    this.currentRemainingPaths = paths;\n    this.isJSONGraph = isJSONGraph || false;\n    this.isProgressive = isProgressive || false;\n    this.forceCollect = forceCollect || false;\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof initialCacheVersion === \"number\") {\n        this.initialCacheVersion = initialCacheVersion;\n    } else if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n};\n\nGetResponse.prototype = Object.create(ModelResponse.prototype);\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nGetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new GetResponse(this.model, this.currentRemainingPaths,\n                           true, this.isProgressive, this.forceCollect,\n                           this.initialCacheVersion);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nGetResponse.prototype.progressively = function progressively() {\n    return new GetResponse(this.model, this.currentRemainingPaths,\n                           this.isJSONGraph, true, this.forceCollect,\n                           this.initialCacheVersion);\n};\n\n/**\n * purely for the purposes of closure creation other than the initial\n * prototype created closure.\n *\n * @private\n */\nGetResponse.prototype._subscribe = function _subscribe(observer) {\n\n    var seed = [{}];\n    var errors = [];\n    var model = this.model;\n    var isJSONG = observer.isJSONG = this.isJSONGraph;\n    var isProgressive = this.isProgressive;\n    var results = checkCacheAndReport(model, this.currentRemainingPaths,\n                                      observer, isProgressive, isJSONG, seed,\n                                      errors);\n\n    // If there are no results, finish.\n    if (!results) {\n\n        var modelRoot = model._root;\n        var modelCache = modelRoot.cache;\n        var currentVersion = modelCache[__version];\n\n        if (this.forceCollect) {\n            collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                    model._maxSize, model._collectRatio, currentVersion);\n        }\n\n        var initialCacheVersion = this.initialCacheVersion;\n        var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n        if (initialCacheVersion !== currentVersion && (\n            modelRoot.syncRefCount <= 0) &&\n            isFunction(rootOnChangesCompletedHandler)) {\n            rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n        }\n        return empty;\n    }\n\n    // Starts the async request cycle.\n    return getRequestCycle(this, model, results,\n                           observer, errors, 1,\n                           this.initialCacheVersion);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/get/GetResponse.js","var gets = require(\"./../../get\");\nvar mergeInto = require(\"./mergeInto\");\nvar collapse = require(\"@graphistry/falcor-path-utils\").collapse;\nvar getWithPathsAsPathMap = gets.getWithPathsAsPathMap;\nvar getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;\n\n/**\n * Checks cache for the paths and reports if in progressive mode.  If\n * there are missing paths then return the cache hit results.\n *\n * @param {Model} model - The model that the request was made with.\n * @param {Array} requestedMissingPaths -\n * @param {Boolean} progressive -\n * @param {Boolean} isJSONG -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @param {Object} seed - The state of the output\n * @private\n */\nmodule.exports = function checkCacheAndReport(model, requestedPaths, observer,\n                                              progressive, isJSONG, seed,\n                                              errors) {\n\n    var originalSeed, isSeedImmutable = progressive && !isJSONG && seed;\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (isSeedImmutable) {\n        originalSeed = seed[0];\n        seed[0] = {};\n    }\n\n    // checks the cache for the data.\n    var results;\n    if (isJSONG) {\n        results = getWithPathsAsJSONGraph(model, requestedPaths, seed);\n    } else {\n        results = getWithPathsAsPathMap(model, requestedPaths, seed);\n    }\n\n    // We must communicate critical errors from get that are critical\n    // errors such as bound path is broken or this is a JSONGraph request\n    // with a bound path.\n    if (results.criticalError) {\n        observer.onError(results.criticalError);\n        return null;\n    }\n\n    var hasValues = results.hasValue;\n    var valueNode = results.values[0];\n    var hasValueOverall = Boolean(valueNode.json || valueNode.jsonGraph);\n\n    // We are done when there are no missing paths or the model does not\n    // have a dataSource to continue on fetching from.\n    var completed = !results.requestedMissingPaths ||\n                    !results.requestedMissingPaths.length ||\n                    !model._source;\n\n    // Copy the errors into the total errors array.\n    if (results.errors) {\n        var errs = results.errors;\n        var errorsLength = errors.length;\n        for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {\n            errors[errorsLength] = errs[i];\n        }\n    }\n\n    // If the valueNode should be immutable, merge the previous valueNode into\n    // the one that was just created.\n    if (isSeedImmutable && originalSeed) {\n        valueNode = mergeInto(valueNode, originalSeed);\n    }\n\n    // If there are values to report, then report.\n    // Which are under two conditions:\n    // 1.  This request for data yielded at least one value (hasValue) and  the\n    // request is progressive\n    //\n    // 2.  The request if finished and the json key off\n    // the valueNode has a value.\n    if (hasValues && progressive || hasValueOverall && completed) {\n        try {\n            if (isJSONG && valueNode) {\n                var jsonGraphPaths = valueNode.paths;\n                if (jsonGraphPaths && jsonGraphPaths.length > 0) {\n                    valueNode.paths = collapse(jsonGraphPaths);\n                }\n            }\n            ++model._root.syncRefCount;\n            observer.onNext(valueNode);\n        } catch (e) {\n            throw e;\n        } finally {\n            --model._root.syncRefCount;\n        }\n    }\n\n    // if there are missing paths, then lets return them.\n    if (completed) {\n        if (errors.length) {\n            observer.onError(errors);\n        } else {\n            observer.onCompleted();\n        }\n\n        return null;\n    }\n\n    // Return the results object.\n    return results;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/get/checkCacheAndReport.js","module.exports = {\n    path: true,\n    pathSyntax: true\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/get/validInput.js","var ModelResponse = require(\"./../ModelResponse\");\nvar isArray = Array.isArray;\nvar isPathValue = require(\"./../../support/isPathValue\");\nvar isJSONGraphEnvelope = require(\"./../../support/isJSONGraphEnvelope\");\nvar isJSONEnvelope = require(\"./../../support/isJSONEnvelope\");\nvar setRequestCycle = require(\"./setRequestCycle\");\nvar __version = require(\"./../../internal/version\");\n\n/**\n *  The set response is responsible for doing the request loop for the set\n * operation and subscribing to the follow up get.\n *\n * The constructors job is to parse out the arguments and put them in their\n * groups.  The following subscribe will do the actual cache set and dataSource\n * operation remoting.\n *\n * @param {Model} model -\n * @param {Array} args - The array of arguments that can be JSONGraph, JSON, or\n * pathValues.\n * @param {Boolean} isJSONGraph - if the request is a jsonGraph output format.\n * @param {Boolean} isProgressive - progressive output.\n * @augments ModelResponse\n * @private\n */\nvar SetResponse = module.exports = function SetResponse(model, args,\n                                                        isJSONGraph,\n                                                        isProgressive,\n                                                        initialCacheVersion) {\n\n    // The response properties.\n    this._model = model;\n    this._isJSONGraph = isJSONGraph || false;\n    this._isProgressive = isProgressive || false;\n    this._initialArgs = args;\n    this._value = [{}];\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof initialCacheVersion === \"number\") {\n        this.initialCacheVersion = initialCacheVersion;\n    } else if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg)) {\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = \"JSONGs\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n};\n\nSetResponse.prototype = Object.create(ModelResponse.prototype);\n\n/**\n * The subscribe function will setup the remoting of the operation and cache\n * setting.\n *\n * @private\n */\nSetResponse.prototype._subscribe = function _subscribe(observer) {\n    var groups = this._groups;\n    var model = this._model;\n    var isJSONGraph = this._isJSONGraph;\n    var isProgressive = this._isProgressive;\n\n    // Starts the async request cycle.\n    return setRequestCycle(model, observer, groups,\n                           isJSONGraph, isProgressive,\n                           0, this.initialCacheVersion);\n};\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nSetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new SetResponse(this._model, this._initialArgs,\n                           true, this._isProgressive, this.initialCacheVersion);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nSetResponse.prototype.progressively = function progressively() {\n    return new SetResponse(this._model, this._initialArgs,\n                           this._isJSONGraph, true, this.initialCacheVersion);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/set/SetResponse.js","var isObject = require(\"./../support/isObject\");\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getTimestamp.js","module.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node.ツkey = key;\n    node.ツparent = parent;\n\n    if (version !== undefined) {\n        node.ツversion = version;\n    }\n    if (!node.ツabsolutePath) {\n        node.ツabsolutePath = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/insertNode.js","var $ref = require(\"./../types/ref\");\nvar $error = require(\"./../types/error\");\nvar getType = require(\"./../support/getType\");\nvar getSize = require(\"./../support/getSize\");\nvar getTimestamp = require(\"./../support/getTimestamp\");\n\nvar isExpired = require(\"./../support/isExpired\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar isFunction = require(\"./../support/isFunction\");\n\nvar wrapNode = require(\"./../support/wrapNode\");\nvar expireNode = require(\"./../support/expireNode\");\nvar insertNode = require(\"./../support/insertNode\");\nvar replaceNode = require(\"./../support/replaceNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar reconstructPath = require(\"./../support/reconstructPath\");\n\nmodule.exports = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node)) {\n            type = \"expired\";\n            expireNode(node, expired, lru);\n        }\n        if ((type && type !== $ref) || isPrimitive(node)) {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && isFunction(comparator)) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (mType === $error && isFunction(errorSelector)) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize(node) - getSize(message);\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/mergeValueOrInsertBranch.js","/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/reconstructPath.js","var isObject = require(\"./../support/isObject\");\nvar transferBackReferences = require(\"./../support/transferBackReferences\");\nvar removeNodeAndDescendants = require(\"./../support/removeNodeAndDescendants\");\nvar updateBackReferenceVersions = require(\"./../support/updateBackReferenceVersions\");\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (isObject(node)) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/replaceNode.js","var __ref = require(\"./../internal/ref\");\n\nmodule.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        if (node && node.ツversion !== version) {\n            node.ツversion = version;\n            stack[count++] = node.ツparent;\n            var i = -1;\n            var n = node.ツrefsLength || 0;\n            while (++i < n) {\n                stack[count++] = node[__ref + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/updateBackReferenceVersions.js","var now = require(\"./../support/now\");\nvar expiresNow = require(\"../values/expires-now\");\n\nvar atomSize = 50;\n\nvar clone = require(\"./../support/clone\");\nvar isArray = Array.isArray;\nvar getSize = require(\"./../support/getSize\");\nvar getExpires = require(\"./../support/getExpires\");\nvar atomType = require(\"./../types/atom\");\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node.ツmodelCreated;\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node.ツprev = undefined;\n        node.ツnext = undefined;\n        node.ツmodelCreated = modelCreated || false;\n    } else {\n        node = {\n            $type: atomType,\n            value: value,\n            ツprev: undefined,\n            ツnext: undefined,\n            ツmodelCreated: true\n        };\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/wrapNode.js","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   3.3.0\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  return typeof x === 'function' || typeof x === 'object' && x !== null;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (!Array.isArray) {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n} else {\n  _isArray = Array.isArray;\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  return function () {\n    vertxNext(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = r('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  _resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        _resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      _reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      _reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    _reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return _resolve(promise, value);\n    }, function (reason) {\n      return _reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$) {\n  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$ === GET_THEN_ERROR) {\n      _reject(promise, GET_THEN_ERROR.error);\n    } else if (then$$ === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$)) {\n      handleForeignThenable(promise, maybeThenable, then$$);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction _resolve(promise, value) {\n  if (promise === value) {\n    _reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction _reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      _reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      _resolve(promise, value);\n    } else if (failed) {\n      _reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      _reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      _resolve(promise, value);\n    }, function rejectPromise(reason) {\n      _reject(promise, reason);\n    });\n  } catch (e) {\n    _reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this._input = input;\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate();\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    _reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n};\n\nEnumerator.prototype._enumerate = function () {\n  var length = this.length;\n  var _input = this._input;\n\n  for (var i = 0; this._state === PENDING && i < length; i++) {\n    this._eachEntry(_input[i], i);\n  }\n};\n\nEnumerator.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$ = c.resolve;\n\n  if (resolve$$ === resolve) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$) {\n        return resolve$$(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$(entry), i);\n  }\n};\n\nEnumerator.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      _reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  _reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = resolve;\nPromise.reject = reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\nPromise.prototype = {\n  constructor: Promise,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nfunction polyfill() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise;\n}\n\npolyfill();\n// Strange compat..\nPromise.polyfill = polyfill;\nPromise.Promise = Promise;\n\nreturn Promise;\n\n})));\n//# sourceMappingURL=es6-promise.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/es6-promise/dist/es6-promise.js\n// module id = 65\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 66\n// module chunks = 0","\"use strict\";\n\nvar Model = require(\"./Model\");\n\nfunction falcor(opts) {\n    return new Model(opts);\n}\n\nfalcor.Model = Model;\n\nmodule.exports = falcor;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","var toPaths = require('./toPaths');\nvar toTree = require('./toTree');\n\nmodule.exports = function collapse(paths) {\n    var collapseMap = paths.\n        reduce(function(acc, path) {\n            var len = path.length;\n            if (!acc[len]) {\n                acc[len] = [];\n            }\n            acc[len].push(path);\n            return acc;\n        }, {});\n\n    Object.\n        keys(collapseMap).\n        forEach(function(collapseKey) {\n            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n        });\n\n    return toPaths(collapseMap);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/collapse.js\n// module id = 68\n// module chunks = 0","/*eslint-disable*/\nmodule.exports = {\n    innerReferences: 'References with inner references are not allowed.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/errors/index.js\n// module id = 69\n// module chunks = 0","var cloneArray = require('./support/cloneArray');\nvar $ref = require('./support/types').$ref;\nvar errors = require('./errors');\n\n/**\n * performs the simplified cache reference follow.  This\n * differs from get as there is just following and reporting,\n * not much else.\n *\n * @param {Object} cacheRoot\n * @param {Array} ref\n */\nmodule.exports = function followReference(cacheRoot, ref, maxRefFollow) {\n    var current = cacheRoot;\n    var refPath = ref;\n    var depth = -1;\n    var length = refPath.length;\n    var key, next, type;\n    var referenceCount = 0;\n\n    while (++depth < length) {\n        key = refPath[depth];\n        next = current[key];\n        type = next && next.$type;\n\n        if (!next || type && type !== $ref) {\n            current = next;\n            break;\n        }\n\n        // Show stopper exception.  This route is malformed.\n        if (type && type === $ref && depth + 1 < length) {\n            var err = new Error(errors.innerReferences);\n            err.throwToNext = true;\n            throw err;\n        }\n\n        // potentially follow reference\n        if (depth + 1 === length) {\n            if (type === $ref) {\n                depth = -1;\n                refPath = next.value;\n                length = refPath.length;\n                next = cacheRoot;\n                referenceCount++;\n            }\n\n            if (referenceCount > maxRefFollow) {\n                throw new Error(errors.circularReference);\n            }\n        }\n        current = next;\n    }\n\n    return [current, cloneArray(refPath)];\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/followReference.js\n// module id = 70\n// module chunks = 0","var iterateKeySet = require('./iterateKeySet');\nvar cloneArray = require('./support/cloneArray');\nvar catAndSlice = require('./support/catAndSlice');\nvar $types = require('./support/types');\nvar $ref = $types.$ref;\nvar followReference = require('./followReference');\n\n/**\n * The fastest possible optimize of paths.\n *\n * What it does:\n * - Any atom short-circuit / found value will be removed from the path.\n * - All paths will be exploded which means that collapse will need to be\n *   ran afterwords.\n * - Any missing path will be optimized as much as possible.\n */\nmodule.exports = function optimizePathSets(cache, paths, maxRefFollow) {\n    var optimized = [];\n    paths.forEach(function(p) {\n        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n    });\n\n    return optimized;\n};\n\n\n/**\n * optimizes one pathSet at a time.\n */\nfunction optimizePathSet(cache, cacheRoot, pathSet,\n                         depth, out, optimizedPath, maxRefFollow) {\n\n    // at missing, report optimized path.\n    if (cache === undefined) {\n        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n        return;\n    }\n\n    // all other sentinels are short circuited.\n    // Or we found a primitive (which includes null)\n    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n            (typeof cache !== 'object')) {\n        return;\n    }\n\n    // If the reference is the last item in the path then do not\n    // continue to search it.\n    if (cache.$type === $ref && depth === pathSet.length) {\n        return;\n    }\n\n    var keySet = pathSet[depth];\n    var isKeySet = typeof keySet === 'object';\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet(keySet, iteratorNote);\n    }\n    var next, nextOptimized;\n    do {\n        next = cache[key];\n        var optimizedPathLength = optimizedPath.length;\n        if (key !== null) {\n            optimizedPath[optimizedPathLength] = key;\n        }\n\n        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n            var refResults =\n                followReference(cacheRoot, next.value, maxRefFollow);\n            next = refResults[0];\n\n            // must clone to avoid the mutation from above destroying the cache.\n            nextOptimized = cloneArray(refResults[1]);\n        } else {\n            nextOptimized = optimizedPath;\n        }\n\n        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n                        out, nextOptimized, maxRefFollow);\n        optimizedPath.length = optimizedPathLength;\n\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (iteratorNote && !iteratorNote.done);\n}\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/optimizePathSets.js\n// module id = 71\n// module chunks = 0","\"use strict\";\n\n/**\n * Helper for getPathCount. Used to determine the size of a key or range.\n * @function\n * @param {Object} rangeOrKey\n * @return The size of the key or range passed in.\n */\nfunction getRangeOrKeySize(rangeOrKey) {\n    if (rangeOrKey == null) {\n        return 1;\n    } else if (Array.isArray(rangeOrKey)) {\n        throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n    } else if (typeof rangeOrKey === \"object\") {\n        return getRangeSize(rangeOrKey);\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Returns the size (number of items) in a Range,\n * @function\n * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n * @return The number of items in the range.\n */\nfunction getRangeSize(range) {\n\n    var to = range.to;\n    var length = range.length;\n\n    if (to != null) {\n        if (isNaN(to) || parseInt(to, 10) !== to) {\n            throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n        }\n        var from = range.from || 0;\n        if (isNaN(from) || parseInt(from, 10) !== from) {\n            throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n        }\n        if (from <= to) {\n            return (to - from) + 1;\n        } else {\n            return 0;\n        }\n    } else if (length != null) {\n        if (isNaN(length) || parseInt(length, 10) !== length) {\n            throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n        } else {\n            return length;\n        }\n    } else {\n        throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n    }\n}\n\n/**\n * Returns a count of the number of paths this pathset\n * represents.\n *\n * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n * would represent 11 paths (0 to 10, inclusive), and\n * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n *\n * @function\n * @param {Object[]} pathSet the path set.\n *\n * @return The number of paths this represents\n */\nfunction getPathCount(pathSet) {\n    if (pathSet.length === 0) {\n        throw new Error(\"All paths must have length larger than zero.\");\n    }\n\n    var numPaths = 1;\n\n    for (var i = 0; i < pathSet.length; i++) {\n        var segment = pathSet[i];\n\n        if (Array.isArray(segment)) {\n\n            var numKeys = 0;\n\n            for (var j = 0; j < segment.length; j++) {\n                var keySet = segment[j];\n\n                numKeys += getRangeOrKeySize(keySet);\n            }\n\n            numPaths *= numKeys;\n\n        } else {\n            numPaths *= getRangeOrKeySize(segment);\n        }\n    }\n\n    return numPaths;\n}\n\n\nmodule.exports = getPathCount;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/pathCount.js\n// module id = 72\n// module chunks = 0","var hasIntersection = require('./hasIntersection');\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromLengthTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = paths[i];\n        if (!hasIntersection(tree[path.length], path, 0, path.length)) {\n            out[++outLength] = path;\n        }\n    }\n    return out;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/pathsComplementFromLengthTree.js\n// module id = 73\n// module chunks = 0","var hasIntersection = require('./hasIntersection');\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        if (!hasIntersection(tree, paths[i], 0, paths[i].length)) {\n            out[++outLength] = paths[i];\n        }\n    }\n    return out;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/pathsComplementFromTree.js\n// module id = 74\n// module chunks = 0","module.exports = function catAndSlice(a, b, slice) {\n    var next = [], i, j, len;\n    for (i = 0, len = a.length; i < len; ++i) {\n        next[i] = a[i];\n    }\n\n    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n        next[i] = b[j];\n    }\n\n    return next;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@graphistry/falcor-path-utils/lib/support/catAndSlice.js\n// module id = 75\n// module chunks = 0","var ModelRoot = require(\"./ModelRoot\");\nvar ModelDataSourceAdapter = require(\"./ModelDataSourceAdapter\");\n\nvar RequestQueue = require(\"./request/RequestQueue\");\nvar ModelResponse = require(\"./response/ModelResponse\");\nvar CallResponse = require(\"./response/CallResponse\");\nvar InvalidateResponse = require(\"./response/InvalidateResponse\");\n\nvar TimeoutScheduler = require(\"./schedulers/TimeoutScheduler\");\nvar ImmediateScheduler = require(\"./schedulers/ImmediateScheduler\");\n\nvar collectLru = require(\"./lru/collect\");\n\nvar getSize = require(\"./support/getSize\");\nvar isObject = require(\"./support/isObject\");\nvar isFunction = require(\"./support/isFunction\");\nvar isPrimitive = require(\"./support/isPrimitive\");\nvar isJSONEnvelope = require(\"./support/isJSONEnvelope\");\nvar isJSONGraphEnvelope = require(\"./support/isJSONGraphEnvelope\");\n\nvar setCache = require(\"./set/setPathMaps\");\nvar setJSONGraphs = require(\"./set/setJSONGraphs\");\nvar validateInput = require(\"./support/validateInput\");\nvar noOp = function() {};\nvar getCache = require(\"./get/getCache\");\nvar get = require(\"./get\");\nvar GET_VALID_INPUT = require(\"./response/get/validInput\");\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(o) {\n\n    var options = o || {};\n    this._root = options._root || new ModelRoot(options, this);\n    this._path = options.path || options._path || [];\n    this._source = options.source || options._source;\n    this._request = options.request || options._request || new RequestQueue(\n        this, options.scheduler || new ImmediateScheduler()\n    );\n\n    if (typeof options.maxSize === \"number\") {\n        this._maxSize = options.maxSize;\n    } else {\n        this._maxSize = options._maxSize || Model.prototype._maxSize;\n    }\n\n    if (typeof options.collectRatio === \"number\") {\n        this._collectRatio = options.collectRatio;\n    } else {\n        this._collectRatio = options._collectRatio || Model.prototype._collectRatio;\n    }\n\n    if (options.boxed || options.hasOwnProperty(\"_boxed\")) {\n        this._boxed = options.boxed || options._boxed;\n    }\n\n    if (options.materialized || options.hasOwnProperty(\"_materialized\")) {\n        this._materialized = options.materialized || options._materialized;\n    }\n\n    if (typeof options.treatErrorsAsValues === \"boolean\") {\n        this._treatErrorsAsValues = options.treatErrorsAsValues;\n    } else if (options.hasOwnProperty(\"_treatErrorsAsValues\")) {\n        this._treatErrorsAsValues = options._treatErrorsAsValues;\n    }\n\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame ||\n        options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\nModel.prototype._materialized = false;\nModel.prototype._boxed = false;\nModel.prototype._progressive = false;\nModel.prototype._treatErrorsAsValues = false;\nModel.prototype._maxSize = Math.pow(2, 53) - 1;\nModel.prototype._collectRatio = 0.75;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = require(\"./response/get\");\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = require(\"./response/set\");\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    var out = validateInput(arguments, GET_VALID_INPUT, \"preload\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get.apply(self, args).subscribe(function() {\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\nModel.prototype.call = function call() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        var arg = arguments[argsIdx];\n        args[argsIdx] = arg;\n        var argType = typeof arg;\n        if (argsIdx > 1 && !Array.isArray(arg) ||\n            argsIdx === 0 && !Array.isArray(arg) && argType !== \"string\" ||\n            argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Invalid argument\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    return new CallResponse(this, args[0], args[1], args[2], args[3]);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n        if (!Array.isArray(args[argsIdx])) {\n            throw new Error(\"Invalid argument\");\n        }\n    }\n\n    // creates the obs, subscribes and will throw the errors if encountered.\n    (new InvalidateResponse(this, args)).\n        subscribe(noOp, function(e) {\n            throw e;\n        });\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = require(\"./deref\");\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = require(\"./deref/hasValidParentReference\");\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = require(\"./get/getValue\");\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = require(\"./set/setValue\");\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        var out;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (out) {\n            get.getWithPathsAsPathMap(this, out, []);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache(...paths) {\n\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var result = [{}];\n    var path = this._path;\n    get.getWithPathsAsJSONGraph(this, paths, result);\n    this._path = path;\n    return result[0].jsonGraph;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path = []) {\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\nModel.prototype._syncCheck = function syncCheck(name) {\n    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {\n        throw new Error(\"Model#\" + name + \" may only be called within the context of a request selector.\");\n    }\n    return true;\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    for (var key in opts) {\n        var value = opts[key];\n        if (value === \"delete\") {\n            delete clone[key];\n        } else {\n            clone[key] = value;\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === \"number\") {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (isFunction(schedulerOrDelay.schedule)) {\n        scheduler = schedulerOrDelay;\n    } else if (isFunction(schedulerOrDelay)) {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, scheduler);\n\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, new ImmediateScheduler());\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({\n        _treatErrorsAsValues: true\n    });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this._path\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._getVersion = require(\"./get/getVersion\");\nModel.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;\nModel.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;\n\nModel.prototype._setPathValues = require(\"./set/setPathValues\");\nModel.prototype._setPathMaps = require(\"./set/setPathMaps\");\nModel.prototype._setJSONGs = require(\"./set/setJSONGraphs\");\nModel.prototype._setCache = require(\"./set/setPathMaps\");\n\nModel.prototype._invalidatePathValues = require(\"./invalidate/invalidatePathSets\");\nModel.prototype._invalidatePathMaps = require(\"./invalidate/invalidatePathMaps\");\n\n\n\n// WEBPACK FOOTER //\n// ./lib/Model.js","function ModelDataSourceAdapter(model) {\n    this._model = model._materialize().boxValues().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    var params = [path, args, suffixes].concat(paths);\n    return this._model.call.apply(this._model, params)._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelDataSourceAdapter.js","var hasOwn = require(\"./support/hasOwn\");\nvar isFunction = require(\"./support/isFunction\");\nvar toJSONWithHashCodes = require(\"./get/toJSONWithHashCodes\");\n\nfunction ModelRoot(o, topLevelModel) {\n\n    var options = o || {};\n\n    this.version = 0;\n    this.syncRefCount = 0;\n    this.expired = options.expired || [];\n    this.unsafeMode = options.unsafeMode || false;\n    this.cache = {};\n    this.topLevelModel = topLevelModel;\n\n    if (isFunction(options.comparator)) {\n        this.comparator = options.comparator;\n    }\n\n    if (options.JSONWithHashCodes === true) {\n        this.branchSelector = toJSONWithHashCodes;\n    } else if (isFunction(options.branchSelector)) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (isFunction(options.errorSelector)) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (isFunction(options.branchSelector)) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (isFunction(options.onChange)) {\n        this.onChange = options.onChange;\n    }\n\n    if (isFunction(options.onChangesCompleted)) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\n\nModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value &&\n            cacheNode.$type === messageNode.$type &&\n            cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelRoot.js","var objectTypes = {\n    \"boolean\": false,\n    \"function\": true,\n    \"object\": true,\n    \"number\": false,\n    \"string\": false,\n    \"undefined\": false\n};\n\n/*eslint-disable */\nvar _root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nvar freeGlobal = objectTypes[typeof global] && global;\n\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    _root = freeGlobal;\n}\n/*eslint-enable */\n\nvar _id = 0;\n\nfunction ensureSymbol(root) {\n    if (!root.Symbol) {\n        root.Symbol = function symbolFuncPolyfill(description) {\n            return \"@@Symbol(\" + description + \"):\" + (_id++) + \"}\";\n        };\n    }\n    return root.Symbol;\n}\n\nfunction ensureObservable(Symbol) {\n    /* eslint-disable dot-notation */\n    if (!Symbol.observable) {\n        if (typeof Symbol.for === \"function\") {\n            Symbol[\"observable\"] = Symbol.for(\"observable\");\n        } else {\n            Symbol[\"observable\"] = \"@@observable\";\n        }\n    }\n    /* eslint-disable dot-notation */\n}\n\nfunction symbolForPolyfill(key) {\n    return \"@@\" + key;\n}\n\nfunction ensureFor(Symbol) {\n    /* eslint-disable dot-notation */\n    if (!Symbol.for) {\n        Symbol[\"for\"] = symbolForPolyfill;\n    }\n    /* eslint-enable dot-notation */\n}\n\n\nfunction polyfillSymbol(root) {\n    var Symbol = ensureSymbol(root);\n    ensureObservable(Symbol);\n    ensureFor(Symbol);\n    return Symbol;\n}\n\nmodule.exports = polyfillSymbol(_root);\n\n\n\n// WEBPACK FOOTER //\n// ./lib/SymbolShim.js","module.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference.ツparent === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference.ツinvalidated) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/hasValidParentReference.js","var CONTAINER_DOES_NOT_EXIST = \"e\";\nvar $ref = require(\"./../types/ref\");\nvar getCachePosition = require(\"../get/getCachePosition\");\nvar InvalidDerefInputError = require(\"./../errors/InvalidDerefInputError\");\n\nmodule.exports = function deref(boundJSONArg) {\n\n    var referenceContainer, currentRefPath, i, len;\n    var absolutePath = boundJSONArg && boundJSONArg.$__path;\n    var originalRefPath = boundJSONArg && boundJSONArg.$__refPath;\n    var toReference = boundJSONArg && boundJSONArg.$__toReference;\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    if (absolutePath) {\n        var cacheRoot = this._root.cache;\n        var cacheNode = getCachePosition(cacheRoot, absolutePath);\n        var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n        if (absolutePath.length === 0) {\n            return this._clone({\n                _path: absolutePath,\n                _referenceContainer: true\n            });\n        }\n\n        if (toReference) {\n\n            validContainer = false;\n\n            i = -1;\n            len = toReference.length;\n            referenceContainer = cacheRoot;\n            while (++i < len) {\n                referenceContainer = referenceContainer[toReference[i]];\n                if (!referenceContainer || referenceContainer.$type) {\n                    break;\n                }\n            }\n\n            // If the reference container is still a sentinel value then compare\n            // the reference value with refPath.  If they are the same, then the\n            // model is still valid.\n            if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n                i = 0;\n                len = originalRefPath.length;\n                currentRefPath = referenceContainer.value;\n\n                validContainer = true;\n                for (; validContainer && i < len; ++i) {\n                    if (currentRefPath[i] !== originalRefPath[i]) {\n                        validContainer = false;\n                    }\n                }\n                if (validContainer === false) {\n                    cacheNode = undefined;\n                }\n            }\n        }\n\n        // Signal to the deref'd model that it has been disconnected from the\n        // graph or there is no _fromWhenceYouCame\n        if (!validContainer) {\n            referenceContainer = false;\n        }\n\n        // The container did not exist, therefore there is no reference\n        // container and fromWhenceYouCame should always return true.\n        else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n            referenceContainer = true;\n        }\n\n        return this._clone({\n            _node: cacheNode,\n            _path: absolutePath,\n            _referenceContainer: referenceContainer\n        });\n    }\n\n    throw new InvalidDerefInputError();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/index.js","var NAME = \"BoundJSONGraphModelError\";\nvar MESSAGE = \"It is not legal to use the JSON Graph \" +\n    \"format from a bound Model. JSON Graph format\" +\n    \" can only be used from a root model.\";\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = this.name;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nBoundJSONGraphModelError.prototype = Object.create(Error.prototype);\nBoundJSONGraphModelError.prototype.name = NAME;\nBoundJSONGraphModelError.message = MESSAGE;\n\nmodule.exports = BoundJSONGraphModelError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/BoundJSONGraphModelError.js","var NAME = \"InvalidDerefInputError\";\nvar MESSAGE = \"Deref can only be used with a non-primitive object from get, set, or call.\";\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidDerefInputError() {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidDerefInputError.prototype = Object.create(Error.prototype);\nInvalidDerefInputError.prototype.name = NAME;\nInvalidDerefInputError.message = MESSAGE;\n\nmodule.exports = InvalidDerefInputError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidDerefInputError.js","var NAME = \"InvalidModelError\";\nvar MESSAGE = \"The boundPath of the model is not valid since a value or error was found before the path end.\";\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidModelError(boundPath, shortedPath) {\n    var err = Error.call(this, MESSAGE);\n    err.name = NAME;\n    this.stack = err.stack;\n    this.message = err.message;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n    return this;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidModelError.prototype = Object.create(Error.prototype);\nInvalidModelError.prototype.name = NAME;\nInvalidModelError.message = MESSAGE;\n\nmodule.exports = InvalidModelError;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidModelError.js","var isInternalKey = require(\"./../support/isInternalKey\");\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    Object.\n        keys(node).\n        filter(function(k) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return !isInternalKey(k) && node[k] !== undefined;\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n                var isUserCreatedcacheNext = !cacheNext.ツmodelCreated;\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext, key);\n        });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/getCache.js","var ModelResponse = require(\"./../response/ModelResponse\");\n\nmodule.exports = function getValue(path) {\n    var pathIdx = 0;\n    var pathLen = path.length;\n    while (++pathIdx < pathLen) {\n        if (typeof path[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get(path).subscribe(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = path.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[path[depth]];\n            }\n            obs.onNext(curr);\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/getValue.js","var getBoundCacheNode = require(\"./../get/getBoundCacheNode\");\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node.ツversion;\n    return (version == null) ? -1 : version;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/getVersion.js","var walkPathAndBuildOutput = require(\"./walkPath\");\nvar getBoundCacheNode = require(\"./../getBoundCacheNode\");\nvar InvalidModelError = require(\"./../../errors/InvalidModelError\");\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, values) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength = boundPath.length;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return {\n                criticalError: new InvalidModelError(boundPath, boundPath)\n            };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame,\n\n        seed = values[0],\n        json = seed && seed.json,\n        results = { values: values },\n        path, pathsIndex = -1, pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        requestedLength = path.length;\n        json = walkPathAndBuildOutput(cache, node, json, path,\n                                   /* depth = */ 0, seed, results,\n                                      requestedPath, requestedLength,\n                                      optimizedPath, optimizedLength,\n                     /* fromReference = */ false, referenceContainer,\n                                      modelRoot, expired, branchSelector,\n                                      boxValues, materialized, hasDataSource,\n                                      treatErrorsAsValues, allowFromWhenceYouCame);\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/json/getJSON.js","var arr = new Array(3);\nvar $ref = require(\"./../../types/ref\");\nvar promote = require(\"./../../lru/promote\");\nvar isExpired = require(\"./../../support/isExpired\");\nvar createHardlink = require(\"./../../support/createHardlink\");\nvar CircularReferenceError = require(\"./../../errors/CircularReferenceError\");\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        followedRefsCount = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref.ツcontext)) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (DEBUG) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\n                                \"Followed \" + followedRefsCount + \" references. \" +\n                                \"This might indicate the presence of an indirect \" +\n                                \"circular reference chain.\"\n                            );\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = ((\n                                    typeof console.warn === \"function\" && console.warn) || (\n                                    typeof console.log === \"function\" && console.log));\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/json/getReferenceTarget.js","var clone = require(\"./../clone\");\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results,\n                 requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/json/onError.js","var clone = require(\"./../clone\");\nvar onError = require(\"./onError\");\nvar $atom = require(\"./../../types/atom\");\nvar $error = require(\"./../../types/error\");\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results,\n                     requestedPath, optimizedPath, optimizedLength,\n                     fromReference, boxValues, materialized,\n                     treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath,\n                       fromReference, boxValues);\n    }\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            results.hasValue = true;\n            return { $type: $atom };\n        }\n        return undefined;\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    if (boxValues) {\n        return clone(node);\n    }\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/json/onValue.js","var isArray = Array.isArray;\nvar $ref = require(\"./../../types/ref\");\nvar onValue = require(\"./onValue\");\nvar onMissing = require(\"./../onMissing\");\nvar onValueType = require(\"./../onValueType\");\nvar isExpired = require(\"./../../support/isExpired\");\nvar getReferenceTarget = require(\"./getReferenceTarget\");\nvar NullInPathError = require(\"./../../errors/NullInPathError\");\nvar InvalidKeySetError = require(\"./../../errors/InvalidKeySetError\");\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, json, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, branchSelector,\n                                boxValues, materialized, hasDataSource,\n                                treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired,\n                           boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        nextJSON, nextReferenceContainer,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return json;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next)) {\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextReferenceContainer = refTarget[2];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n            }\n\n            // Continue following the path\n\n            nextJSON = walkPathAndBuildOutput(\n                cacheRoot, next, nextJSON, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, nextReferenceContainer,\n                modelRoot, expired, branchSelector, boxValues, materialized,\n                hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n            );\n\n            // Inspect the return value from the step and determine whether to\n            // create or write into the JSON branch at this level.\n            //\n            // 1. If the next node was a leaf value, nextJSON is the value.\n            // 2. If the next node was a missing path, nextJSON is undefined.\n            // 3. If the next node was a branch, then nextJSON will either be an\n            //    Object or undefined. If nextJSON is undefined, all paths under\n            //    this step resolved to missing paths. If it's an Object, then\n            //    at least one path resolved to a successful leaf value.\n            //\n            // This check defers creating branches until we see at least one\n            // cache hit. Otherwise, don't waste the cycles creating a branch\n            // if everything underneath is a cache miss.\n\n            if (undefined !== nextJSON) {\n                // The json value will initially be undefined. If we're here,\n                // then at least one leaf value was encountered, so create a\n                // branch to contain it.\n                if (undefined === json) {\n                    // Enable developers to instrument branch node creation by\n                    // providing a custom function. If they do, delegate branch\n                    // node creation to them.\n                    if (branchSelector) {\n\n                        // branchSelector = (\n                        //     nodeKey: String|Number|null,\n                        //     nodePath: Array|null,\n                        //     nodeVersion: Number,\n                        //     requestedPath: Array,\n                        //     requestedDepth: Number,\n                        //     referencePath: Array|null,\n                        //     pathToReference: Array|null\n                        // ) => Object { $__path?, $__refPath?, $__toReference? }\n\n                        json = branchSelector(node.ツkey,\n                                              node.ツabsolutePath,\n                                              node.ツversion, path, depth,\n                                              allowFromWhenceYouCame && referenceContainer &&\n                                                  referenceContainer.value || undefined,\n                                              allowFromWhenceYouCame && referenceContainer &&\n                                                  referenceContainer.ツabsolutePath || undefined);\n\n                    }\n                    // Otherwise, create a branch ourselves and assign the required metadata\n                    else {\n                        json = {};\n                        // Only assign the $__path if this isn't the top-level\n                        // branch (e.g. { json: {} <-- this one }).\n                        if (depth > 0) {\n                            json.$__path = node.ツabsolutePath;\n                        }\n                        if (allowFromWhenceYouCame && referenceContainer) {\n                            json.$__refPath = referenceContainer.value;\n                            json.$__toReference = referenceContainer.ツabsolutePath;\n                        }\n                    }\n                }\n\n                // Set the reported branch or leaf into this branch.\n                json[nextKey] = nextJSON;\n            }\n\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will either be a branch, or undefined if all paths were cache misses\n    return json;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/json/walkPath.js","var walkPathAndBuildOutput = require(\"./walkPath\");\nvar BoundJSONGraphModelError = require(\"./../../errors/BoundJSONGraphModelError\");\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, values) {\n\n    var node, cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength = boundPath.length;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return {\n            criticalError: new BoundJSONGraphModelError()\n        };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n\n        seed = values[0],\n        results = { values: values },\n        path, pathsIndex = -1, pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n                            /* depth = */ 0, seed, results,\n                               requestedPath, requestedLength,\n                               optimizedPath, optimizedLength,\n              /* fromReference = */ false, modelRoot, expired,\n                               boxValues, materialized, hasDataSource,\n                               treatErrorsAsValues);\n    }\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/jsonGraph/getJSONGraph.js","var arr = new Array(2);\nvar clone = require(\"./../clone\");\nvar $ref = require(\"./../../types/ref\");\nvar inlineValue = require(\"./inlineValue\");\nvar promote = require(\"./../../lru/promote\");\nvar isExpired = require(\"./../../support/isExpired\");\nvar createHardlink = require(\"./../../support/createHardlink\");\nvar CircularReferenceError = require(\"./../../errors/CircularReferenceError\");\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, boxValues, materialized) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        followedRefsCount = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref.ツcontext)) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                if (DEBUG) {\n                    // If we follow too many references, we might have an indirect\n                    // circular reference chain. Warn about this (but don't throw).\n                    if (++followedRefsCount % 50 === 0) {\n                        try {\n                            throw new Error(\n                                \"Followed \" + followedRefsCount + \" references. \" +\n                                \"This might indicate the presence of an indirect \" +\n                                \"circular reference chain.\"\n                            );\n                        } catch (e) {\n                            if (console) {\n                                var reportFn = ((\n                                    typeof console.warn === \"function\" && console.warn) || (\n                                    typeof console.log === \"function\" && console.log));\n                                if (reportFn) {\n                                    reportFn.call(console, e.toString());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/jsonGraph/getReferenceTarget.js","var clone = require(\"./../clone\");\nvar $ref = require(\"./../../types/ref\");\nvar $atom = require(\"./../../types/atom\");\nvar $error = require(\"./../../types/error\");\nvar inlineValue = require(\"./inlineValue\");\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results,\n                          requestedPath, optimizedPath, optimizedLength,\n                          fromReference, boxValues, materialized) {\n\n    var value = node && node.value;\n    var requiresMaterializedToReport = type && value === undefined;\n\n    if (requiresMaterializedToReport) {\n        if (materialized) {\n            value = { $type: $atom };\n        } else {\n            return undefined;\n        }\n    }\n    // boxValues always clones the node\n    else if (boxValues ||\n            /*\n             * JSON Graph should always clone errors, refs, atoms we didn't\n             * create, and atoms we created to wrap Object values.\n             */\n             $ref === type ||\n             $error === type ||\n             !node.ツmodelCreated ||\n             \"object\" === typeof value) {\n        value = clone(node);\n    }\n\n    if (results && requestedPath) {\n        results.hasValue = true;\n        inlineValue(value, optimizedPath, optimizedLength,\n                    seed, boxValues, materialized);\n        (seed.paths || (seed.paths = [])).push(\n            requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n        );\n    }\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/jsonGraph/onValue.js","var isArray = Array.isArray;\nvar clone = require(\"./../clone\");\nvar $ref = require(\"./../../types/ref\");\nvar onValue = require(\"./onValue\");\nvar onMissing = require(\"./../onMissing\");\nvar inlineValue = require(\"./inlineValue\");\nvar onValueType = require(\"./../onValueType\");\nvar isExpired = require(\"./../../support/isExpired\");\nvar getReferenceTarget = require(\"./getReferenceTarget\");\nvar NullInPathError = require(\"./../../errors/NullInPathError\");\nvar InvalidKeySetError = require(\"./../../errors/InvalidKeySetError\");\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(cacheRoot, node, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, modelRoot, expired,\n                                boxValues, materialized, hasDataSource,\n                                treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired,\n                           boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing);\n    }\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (\"object\" !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            keyset = keysOrRanges[keysetIndex];\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(cacheRoot, next, modelRoot, seed, boxValues, materialized);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(\n                cacheRoot, next, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, modelRoot, expired,\n                boxValues, materialized, hasDataSource, treatErrorsAsValues\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/jsonGraph/walkPath.js","module.exports = toJSONWithHashCodes;\n\n/**\n * branchSelector = (\n *     nodeKey: String|Number|null,\n *     nodePath: Array|null,\n *     nodeVersion: Number,\n *     requestedPath: Array,\n *     requestedDepth: Number,\n *     referencePath: Array|null,\n *     pathToReference: Array|null\n * ) => Object { $__path?, $__refPath?, $__toReference? }\n */\n\nfunction toJSONWithHashCodes(nodeKey = '$__cache__$',\n                             nodePath = [],\n                             nodeVersion = 0,\n                             requestedPath = [],\n                             requestedDepth = 0,\n                             referencePath, pathToReference) {\n\n    var json = {\n        __proto__: JSONProto,\n        $__key: nodeKey,\n        $__path: nodePath,\n        $__version: nodeVersion,\n        $__keysPath: requestedPath,\n        $__keyDepth: requestedDepth\n    };\n\n    if (referencePath && pathToReference) {\n        json.$__refPath = referencePath;\n        json.$__toReference = pathToReference;\n    }\n\n    return json;\n}\n\nvar isArray = Array.isArray;\nvar JSONProto = Object.create(Object.prototype, Object.assign(\n    {\n        $__name: { value: 'falcor-node' },\n        $__hash: {\n            enumerable: false,\n            get() {\n                var $__hash__$ = this.$__hash__$;\n                if ($__hash__$ === undefined) {\n                    $__hash__$ = this.$__hash__$ = `${\n                        getHashCode(`${\n                        computeHashCodeForKeys('$__cache__$', this.$__path, 0)}${\n                        computeHashCodeForKeys(this.$__key, this.$__keysPath, this.$__keyDepth)\n                    }`)}`;\n                }\n                return $__hash__$;\n            }\n        }\n    },\n    arrayProtoMethods().reduce((jsonProto, methodName) => {\n            var method = Array.prototype[methodName];\n            jsonProto[methodName] = {\n                writable: true, enumerable: false, value() {\n                    return method.apply(this, arguments);\n                }\n            };\n            return jsonProto;\n        }, {})\n    )\n);\n\nfunction arrayProtoMethods() {\n    return [\n        'concat', 'copyWithin', 'entries', 'every', 'fill', 'filter', 'find',\n        'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'keys',\n        'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight',\n        'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'unshift', 'values'\n    ];\n}\n\nfunction computeHashCodeForKeys(key, path, depth) {\n\n    var code = `${getHashCode(`${key}`)}`;\n\n    if (depth === path.length) {\n        return code;\n    }\n\n    var nextDepth = depth + 1;\n    var keyset, keysetIndex = -1, keysetLength = 0;\n    var nextKey, keyIsRange, rangeEnd, keysOrRanges;\n\n    keyset = path[depth];\n\n    if (keyset === null) {\n        return code;\n    }\n\n    iteratingKeyset: do {\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                break iteratingKeyset;\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (\"number\" !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        do {\n            code = `${\n                getHashCode(`${code}${\n                computeHashCodeForKeys(nextKey, path, nextDepth)\n            }`)}`;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return code;\n}\n\nfunction getHashCode(str) {\n    var hash = 5381, i = str.length;\n    while (i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    // JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n    // integers. Since we want the results to be always positive, convert the\n    // signed int to an unsigned by doing an unsigned bitshift.\n    return hash >>> 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/get/toJSONWithHashCodes.js","var createHardlink = require(\"../support/createHardlink\");\nvar __prefix = require(\"./../internal/unicodePrefix\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar getBoundCacheNode = require(\"./../get/getBoundCacheNode\");\n\nvar promote = require(\"./../lru/promote\");\nvar getSize = require(\"./../support/getSize\");\nvar hasOwn = require(\"./../support/hasOwn\");\nvar isObject = require(\"./../support/isObject\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar removeNodeAndDescendants = require(\"./../support/removeNodeAndDescendants\");\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var comparator = modelRoot._comparator;\n    var errorSelector = modelRoot._errorSelector;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isPrimitive(pathMap) || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (key[0] !== __prefix && key[0] !== \"$\" && hasOwn(pathMap, key)) {\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n            var results = invalidateNode(\n                root, parent, node,\n                key, child, branch, false,\n                version, expired, lru, comparator, errorSelector\n            );\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node.ツcontext;\n\n    if (node != null) {\n        parent = node.ツparent || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, value, branch, true,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container.ツcontext !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, value, branch, reference,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node.ツkey;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/invalidate/invalidatePathMaps.js","var __ref = require(\"./../internal/ref\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar getBoundCacheNode = require(\"./../get/getBoundCacheNode\");\n\nvar promote = require(\"./../lru/promote\");\nvar getSize = require(\"./../support/getSize\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar iterateKeySet = require(\"@graphistry/falcor-path-utils\").iterateKeySet;\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar removeNodeAndDescendants = require(\"./../support/removeNodeAndDescendants\");\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version++;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n    var parent = node.ツparent || cache;\n    var initialVersion = cache.ツversion;\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru\n        );\n    }\n\n    var newVersion = cache.ツversion;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        var results = invalidateNode(\n            root, parent, node,\n            key, branch, false,\n            version, expired, lru\n        );\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru\n                );\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node.ツcontext;\n\n    if (node != null) {\n        parent = node.ツparent || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, branch, true,\n                version, expired, lru\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container.ツcontext !== node) {\n            var backRefs = node.ツrefsLength || 0;\n            node.ツrefsLength = backRefs + 1;\n            node[__ref + backRefs] = container;\n            container.ツcontext = node;\n            container.ツrefIndex = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, branch, reference,\n    version, expired, lru) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(root, node, version, expired, lru);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node.ツkey;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/invalidate/invalidatePathSets.js","var complement = require(\"./complement\");\nvar flushGetRequest = require(\"./flushGetRequest\");\nvar REQUEST_ID = 0;\nvar GetRequestType = require(\"./RequestTypes\").GetRequest;\nvar setJSONGraphs = require(\"./../set/setJSONGraphs\");\nvar setPathValues = require(\"./../set/setPathValues\");\nvar noop = require(\"./../support/noop\");\nvar $error = require(\"./../types/error\");\nvar emptyArray = [];\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\n\n/**\n * Creates a new GetRequest.  This GetRequest takes a scheduler and\n * the request queue.  Once the scheduler fires, all batched requests\n * will be sent to the server.  Upon request completion, the data is\n * merged back into the cache and all callbacks are notified.\n *\n * @param {Scheduler} scheduler -\n * @param {RequestQueue} requestQueue -\n */\nvar GetRequest = function(scheduler, requestQueue) {\n    this.sent = false;\n    this.scheduled = false;\n    this.requestQueue = requestQueue;\n    this.id = ++REQUEST_ID;\n    this.type = GetRequestType;\n\n    this._scheduler = scheduler;\n    this._pathMap = {};\n    this._optimizedPaths = [];\n    this._requestedPaths = [];\n    this._callbacks = [];\n    this._count = 0;\n    this._disposable = null;\n    this._collapsed = null;\n    this._disposed = false;\n};\n\nGetRequest.prototype = {\n    /**\n     * batches the paths that are passed in.  Once the request is complete,\n     * all callbacks will be called and the request will be removed from\n     * parent queue.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} callback -\n     */\n    batch: function(requestedPaths, optimizedPaths, callback) {\n        var self = this;\n        var oPaths = self._optimizedPaths;\n        var rPaths = self._requestedPaths;\n        var callbacks = self._callbacks;\n        var idx = oPaths.length;\n\n        // If its not sent, simply add it to the requested paths\n        // and callbacks.\n        oPaths[idx] = optimizedPaths;\n        rPaths[idx] = requestedPaths;\n        callbacks[idx] = callback;\n        ++self._count;\n\n        // If it has not been scheduled, then schedule the action\n        if (!self.scheduled) {\n            self.scheduled = true;\n\n            var flushedDisposable;\n            var scheduleDisposable = self._scheduler.schedule(function() {\n                self._disposable = flushedDisposable = interopDisposable(\n                    flushGetRequest(self, oPaths, function(err, data) {\n                        var i, fn, len;\n                        self.requestQueue.removeRequest(self);\n                        self._disposed = true;\n\n                        if (err instanceof InvalidSourceError) {\n                            for (i = 0, len = callbacks.length; i < len; ++i) {\n                                fn = callbacks[i];\n                                if (fn) {\n                                    fn(err);\n                                }\n                            }\n                            return;\n                        }\n\n                        // If there is at least one callback remaining, then\n                        // callback the callbacks.\n                        if (self._count) {\n                            self._merge(rPaths, err, data);\n\n                            // Call the callbacks.  The first one inserts all\n                            // the data so that the rest do not have consider\n                            // if their data is present or not.\n                            for (i = 0, len = callbacks.length; i < len; ++i) {\n                                fn = callbacks[i];\n                                if (fn) {\n                                    fn(err, data);\n                                }\n                            }\n                        }\n                    }));\n            });\n\n            // There is a race condition here. If the scheduler is sync then it\n            // exposes a condition where the flush request cannot be disposed.\n            // To correct this issue, if there is no flushedDisposable, then the\n            // scheduler is async and should use scheduler disposable, else use\n            // the flushedDisposable.\n            self._disposable = interopDisposable(flushedDisposable || scheduleDisposable);\n        }\n\n        // Disposes this batched request.  This does not mean that the\n        // entire request has been disposed, but just the local one, if all\n        // requests are disposed, then the outer disposable will be removed.\n        return createDisposable(self, idx);\n    },\n\n    /**\n     * Attempts to add paths to the outgoing request.  If there are added\n     * paths then the request callback will be added to the callback list.\n     *\n     * @returns {Array} - the remaining paths in the request.\n     */\n    add: function(requested, optimized, callback) {\n        // uses the length tree complement calculator.\n        var self = this;\n        var complementTuple = complement(requested, optimized, self._pathMap);\n        var optimizedComplement;\n        var requestedComplement;\n\n        if (complementTuple) {\n            requestedComplement = complementTuple[2];\n            optimizedComplement = complementTuple[1];\n        } else {\n            requestedComplement = requested;\n            optimizedComplement = optimized;\n        }\n\n        var inserted = false;\n        var disposable = false;\n\n        // If the out paths is less than the passed in paths, then there\n        // has been an intersection and the complement has been returned.\n        // Therefore, this can be deduped across requests.\n        if (optimizedComplement.length < optimized.length) {\n            inserted = true;\n            var idx = self._callbacks.length;\n            self._callbacks[idx] = callback;\n            self._requestedPaths[idx] = complementTuple[0];\n            self._optimizedPaths[idx] = [];\n            ++self._count;\n\n            disposable = createDisposable(self, idx);\n        }\n\n        return [inserted, requestedComplement, optimizedComplement, disposable];\n    },\n\n    /**\n     * merges the response into the model\"s cache.\n     */\n    _merge: function(requested, err, data) {\n        var self = this;\n        var model = self.requestQueue.model;\n        var modelRoot = model._root;\n        var errorSelector = modelRoot.errorSelector;\n        var comparator = modelRoot.comparator;\n        var boundPath = model._path;\n\n        model._path = emptyArray;\n\n        // flatten all the requested paths, adds them to the\n        var nextPaths = flattenRequestedPaths(requested);\n\n        // Insert errors in every requested position.\n        if (err) {\n            var error = err;\n\n            // Converts errors to objects, a more friendly storage\n            // of errors.\n            if (error instanceof Error) {\n                error = {\n                    message: error.message\n                };\n            }\n            // Not all errors are value $types.\n            else if (!error.$type) {\n                error = {\n                    $type: $error,\n                    value: error\n                };\n            }\n\n            var pathValues = nextPaths.map(function(x) {\n                return {\n                    path: x,\n                    value: error\n                };\n            });\n            setPathValues(model, pathValues, errorSelector, comparator);\n        }\n\n        // Insert the jsonGraph from the dataSource.\n        else {\n            setJSONGraphs(model, [{\n                paths: nextPaths,\n                jsonGraph: data.jsonGraph\n            }], errorSelector, comparator);\n        }\n\n        // return the model\"s boundPath\n        model._path = boundPath;\n    }\n};\n\n// Creates a more efficient closure of the things that are\n// needed.  So the request and the idx.  Also prevents code\n// duplication.\nfunction createDisposable(request, idx) {\n    var disposed = false;\n    return function() {\n        if (disposed || request._disposed) {\n            return;\n        }\n\n        disposed = true;\n        request._callbacks[idx] = null;\n        request._optimizedPaths[idx] = [];\n        request._requestedPaths[idx] = [];\n\n        // If there are no more requests, then dispose all of the request.\n        var count = --request._count;\n        if (count === 0) {\n            request._disposable.dispose();\n            request.requestQueue.removeRequest(request);\n        }\n    };\n}\n\nfunction flattenRequestedPaths(requested) {\n    var out = [];\n    var outLen = -1;\n    for (var i = 0, len = requested.length; i < len; ++i) {\n        var paths = requested[i];\n        for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {\n            out[++outLen] = paths[j];\n        }\n    }\n    return out;\n}\n\nfunction interopDisposable(disposable) {\n    if (!disposable) {\n        return { dispose: noop, unsubscribe: noop };\n    }\n    if (!disposable.unsubscribe) {\n        disposable.unsubscribe = disposable.dispose;\n    } else if (!disposable.dispose) {\n        disposable.dispose = disposable.unsubscribe;\n    }\n    return disposable;\n}\n\nmodule.exports = GetRequest;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/GetRequest.js","var RequestTypes = require(\"./RequestTypes\");\nvar sendSetRequest = require(\"./sendSetRequest\");\nvar GetRequest = require(\"./GetRequest\");\nvar collapse = require(\"@graphistry/falcor-path-utils\").collapse;\n\n/**\n * The request queue is responsible for queuing the operations to\n * the model\"s dataSource.\n *\n * @param {Model} model -\n * @param {Scheduler} scheduler -\n */\nfunction RequestQueue(model, scheduler) {\n    this.model = model;\n    this.scheduler = scheduler;\n    this.requests = this._requests = [];\n}\n\nRequestQueue.prototype = {\n    /**\n     * Sets the scheduler, but will not affect any current requests.\n     */\n    setScheduler: function(scheduler) {\n        this.scheduler = scheduler;\n    },\n\n    /**\n     * performs a set against the dataSource.  Sets, though are not batched\n     * currently could be batched potentially in the future.  Since no batching\n     * is required the setRequest action is simplified significantly.\n     *\n     * @param {JSONGraphEnvelope) jsonGraph -\n     */\n    set: function(jsonGraph, cb) {\n        jsonGraph.paths = collapse(jsonGraph.paths);\n        return sendSetRequest(jsonGraph, this.model, cb);\n    },\n\n    /**\n     * Creates a get request to the dataSource.  Depending on the current\n     * scheduler is how the getRequest will be flushed.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} cb -\n     */\n    get: function(requestedPaths, optimizedPaths, cb) {\n        var self = this;\n        var disposables = [];\n        var count = 0;\n        var requests = self._requests;\n        var i, len;\n        var oRemainingPaths = optimizedPaths;\n        var rRemainingPaths = requestedPaths;\n        var disposed = false;\n        var request;\n\n        for (i = 0, len = requests.length; i < len; ++i) {\n            request = requests[i];\n            if (request.type !== RequestTypes.GetRequest) {\n                continue;\n            }\n\n            // The request has been sent, attempt to jump on the request\n            // if possible.\n            if (request.sent) {\n                var results = request.add(\n                    rRemainingPaths, oRemainingPaths, refCountCallback);\n\n                // Checks to see if the results were successfully inserted\n                // into the outgoing results.  Then our paths will be reduced\n                // to the complement.\n                if (results[0]) {\n                    rRemainingPaths = results[1];\n                    oRemainingPaths = results[2];\n                    disposables[disposables.length] = results[3];\n                    ++count;\n                }\n            }\n\n            // If there is a non sent request, then we can batch and leave.\n            else {\n                request.batch(\n                    rRemainingPaths, oRemainingPaths, refCountCallback);\n                oRemainingPaths = [];\n                rRemainingPaths = [];\n                ++count;\n            }\n\n            // If there are no more remaining paths then exit the loop.\n            if (!oRemainingPaths.length) {\n                break;\n            }\n        }\n\n        // After going through all the available requests if there are more\n        // paths to process then a new request must be made.\n        if (oRemainingPaths.length) {\n            request = new GetRequest(self.scheduler, self);\n            requests[requests.length] = request;\n            ++count;\n            var disposable = request.batch(\n                rRemainingPaths, oRemainingPaths, refCountCallback);\n            disposables[disposables.length] = disposable;\n        }\n\n        // This is a simple refCount callback.\n        function refCountCallback(err) {\n            if (disposed) {\n                return;\n            }\n\n            --count;\n\n            // If the count becomes 0, then its time to notify the\n            // listener that the request is done.\n            if (count === 0) {\n                cb(err);\n            }\n        }\n\n        // When disposing the request all of the outbound requests will be\n        // disposed of.\n        return function() {\n            if (disposed || count === 0) {\n                return;\n            }\n\n            disposed = true;\n            var length = disposables.length;\n            for (var idx = 0; idx < length; ++idx) {\n                disposables[idx]();\n            }\n        };\n    },\n\n    /**\n     * Removes the request from the request\n     */\n    removeRequest: function(request) {\n        var requests = this._requests;\n        var i = requests.length;\n        while (--i >= 0) {\n            if (requests[i].id === request.id) {\n                requests.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\nmodule.exports = RequestQueue;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/RequestQueue.js","var hasIntersection = require(\"@graphistry/falcor-path-utils\").hasIntersection;\n\n/**\n * creates the complement of the requested and optimized paths\n * based on the provided tree.\n *\n * If there is no complement then this is just a glorified\n * array copy.\n */\nmodule.exports = function complement(requested, optimized, tree) {\n    var optimizedComplement = [];\n    var requestedComplement = [];\n    var requestedIntersection = [];\n    var intersectionLength = -1, complementLength = -1;\n    var intersectionFound = false;\n\n    for (var i = 0, len = optimized.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = optimized[i];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n\n        // If there is no subtree to look into or there is no intersection.\n        if (!subTree || !hasIntersection(subTree, path, 0, pathLen)) {\n\n            if (intersectionFound) {\n                optimizedComplement[++complementLength] = path;\n                requestedComplement[complementLength] = requested[i];\n            }\n        } else {\n            // If there has been no intersection yet and\n            // i is bigger than 0 (meaning we have had only complements)\n            // then we need to update our complements to match the current\n            // reality.\n            if (!intersectionFound && i > 0) {\n                requestedComplement = requested.slice(0, i);\n                optimizedComplement = optimized.slice(0, i);\n            }\n\n            requestedIntersection[++intersectionLength] = requested[i];\n            intersectionFound = true;\n        }\n    }\n\n    if (!intersectionFound) {\n        return null;\n    }\n\n    return [requestedIntersection, optimizedComplement, requestedComplement];\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/complement.js","var pathUtils = require(\"@graphistry/falcor-path-utils\");\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\n\n/**\n * Flushes the current set of requests.  This will send the paths to the\n * dataSource.  * The results of the dataSource will be sent to callback which\n * should perform the zip of all callbacks.\n * @param {GetRequest} request -\n * @param {Array} listOfPaths -\n * @param {Function} callback -\n * @private\n */\nmodule.exports = function flushGetRequest(request, listOfPaths, callback) {\n    if (request._count === 0) {\n        request.requestQueue.removeRequest(request);\n        return null;\n    }\n\n    request.sent = true;\n    request.scheduled = false;\n\n    // TODO: Move this to the collapse algorithm,\n    // TODO: we should have a collapse that returns the paths and\n    // TODO: the trees.\n\n    // Take all the paths and add them to the pathMap by length.\n    // Since its a list of paths\n    var pathMap = request._pathMap;\n    var listKeys = Object.keys(listOfPaths);\n    var listIdx = 0, listLen = listKeys.length;\n    for (; listIdx < listLen; ++listIdx) {\n        var paths = listOfPaths[listIdx];\n        for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {\n            var pathSet = paths[j];\n            var len = pathSet.length;\n\n            if (!pathMap[len]) {\n                pathMap[len] = [pathSet];\n            } else {\n                var pathSetsByLength = pathMap[len];\n                pathSetsByLength[pathSetsByLength.length] = pathSet;\n            }\n        }\n    }\n\n    // now that we have them all by length, convert each to a tree.\n    var pathMapKeys = Object.keys(pathMap);\n    var pathMapIdx = 0, pathMapLen = pathMapKeys.length;\n    for (; pathMapIdx < pathMapLen; ++pathMapIdx) {\n        var pathMapKey = pathMapKeys[pathMapIdx];\n        pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);\n    }\n\n    // Take the pathMapTree and create the collapsed paths and send those\n    // off to the server.\n    var collapsedPaths = request._collasped = toPaths(pathMap);\n    var jsonGraphData;\n\n    // Make the request.\n    // You are probably wondering why this is not cancellable.  If a request\n    // goes out, and all the requests are removed, the request should not be\n    // cancelled.  The reasoning is that another request could come in, after\n    // all callbacks have been removed and be deduped.  Might as well keep this\n    // around until it comes back.  If at that point there are no requests then\n    // we cancel at the callback above.\n    var getRequest;\n    try {\n        getRequest = request.\n            requestQueue.\n            model._source.\n            get(collapsedPaths);\n    } catch (e) {\n        callback(new InvalidSourceError());\n        return null;\n    }\n\n    // Ensures that the disposable is available for the outside to cancel.\n    var disposable = getRequest.\n        subscribe(function(data) {\n            jsonGraphData = data;\n        }, function(err) {\n            callback(err, jsonGraphData);\n        }, function() {\n            callback(null, jsonGraphData);\n        });\n\n    return disposable;\n};\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/flushGetRequest.js","var setJSONGraphs = require(\"./../set/setJSONGraphs\");\nvar setPathValues = require(\"./../set/setPathValues\");\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\n\nvar emptyArray = [];\nvar emptyDisposable = {dispose: function() {}};\n\n/**\n * A set request is not an object like GetRequest.  It simply only needs to\n * close over a couple values and its never batched together (at least not now).\n *\n * @private\n * @param {JSONGraphEnvelope} jsonGraph -\n * @param {Model} model -\n * @param {Function} callback -\n */\nvar sendSetRequest = function(originalJsonGraph, model, callback) {\n    var paths = originalJsonGraph.paths;\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var comparator = modelRoot.comparator;\n    var boundPath = model._path;\n    var resultingJsonGraphEnvelope;\n\n    // This is analogous to GetRequest _merge / flushGetRequest\n    // SetRequests are just considerably simplier.\n    var setObservable;\n    try {\n        setObservable = model._source.\n            set(originalJsonGraph);\n    } catch (e) {\n        callback(new InvalidSourceError());\n        return emptyDisposable;\n    }\n\n    var disposable = setObservable.\n        subscribe(function onNext(jsonGraphEnvelope) {\n            // When disposed, no data is inserted into.  This can sync resolve\n            // and if thats the case then its undefined.\n            if (disposable && disposable.disposed) {\n                return;\n            }\n\n            // onNext will insert all data into the model then save the json\n            // envelope from the incoming result.\n            model._path = emptyArray;\n\n            var successfulPaths = setJSONGraphs(model, [{\n                paths: paths,\n                jsonGraph: jsonGraphEnvelope.jsonGraph\n            }], errorSelector, comparator);\n\n            jsonGraphEnvelope.paths = successfulPaths[1];\n\n            model._path = boundPath;\n            resultingJsonGraphEnvelope = jsonGraphEnvelope;\n        }, function onError(dataSourceError) {\n            if (disposable && disposable.disposed) {\n                return;\n            }\n            model._path = emptyArray;\n\n            setPathValues(model, paths.map(function(path) {\n                return {\n                    path: path,\n                    value: dataSourceError\n                };\n            }), errorSelector, comparator);\n\n            model._path = boundPath;\n\n            callback(dataSourceError);\n        }, function onCompleted() {\n            callback(null, resultingJsonGraphEnvelope);\n        });\n\n    return disposable;\n};\n\nmodule.exports = sendSetRequest;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/sendSetRequest.js","var SetResponse = require(\"./../response/set/SetResponse\");\nvar ModelResponse = require(\"./../response/ModelResponse\");\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\nvar __version = require(\"./../internal/version\");\n\n/**\n * @private\n * @augments ModelResponse\n */\nfunction CallResponse(model, callPath, args, suffix, paths) {\n    this.callPath = callPath;\n    this.args = args;\n\n    if (paths) {\n        this.paths = paths;\n    }\n    if (suffix) {\n        this.suffix = suffix;\n    }\n    this.model = model;\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n}\n\nCallResponse.prototype = Object.create(ModelResponse.prototype);\nCallResponse.prototype._subscribe = function _subscribe(observer) {\n    var callPath = this.callPath;\n    var callArgs = this.args;\n    var suffixes = this.suffix;\n    var extraPaths = this.paths;\n    var model = this.model;\n    var rootModel = model._clone({\n        _path: []\n    });\n    var boundPath = model._path;\n    var boundCallPath = boundPath.concat(callPath);\n    var initialCacheVersion = this.initialCacheVersion;\n\n    /* eslint-disable consistent-return */\n    // Precisely the same error as the router when a call function does not\n    // exist.\n    if (!model._source) {\n        observer.onError(new Error(\"function does not exist\"));\n        return;\n    }\n\n    var response, obs;\n    try {\n        obs = model._source.\n            call(boundCallPath, callArgs, suffixes, extraPaths);\n    } catch (e) {\n        observer.onError(new InvalidSourceError(e));\n        return;\n    }\n\n    return obs.\n        subscribe(function(res) {\n            response = res;\n        }, function(err) {\n            observer.onError(err);\n        }, function() {\n\n            // Run the invalidations first then the follow up JSONGraph set.\n            var invalidations = response.invalidated;\n            if (invalidations && invalidations.length) {\n                // Increment `syncRefCount` here to block calling the _root's\n                // onChangesCompleted handler.\n                ++model._root.syncRefCount;\n                rootModel.invalidate.apply(rootModel, invalidations);\n                --model._root.syncRefCount;\n            }\n\n            // Use the SetResponse directly so we can specify the\n            // initialCacheVersion from before the call operation was invoked.\n            return new SetResponse(rootModel.withoutDataSource(), [response],\n                false, false, initialCacheVersion).subscribe(function(x) {\n                    observer.onNext(x);\n                }, function(err) {\n                    observer.onError(err);\n                }, function() {\n                    observer.onCompleted();\n                });\n        });\n    /* eslint-enable consistent-return */\n};\n\nmodule.exports = CallResponse;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/CallResponse.js","var isArray = Array.isArray;\nvar ModelResponse = require(\"./ModelResponse\");\nvar isPathValue = require(\"./../support/isPathValue\");\nvar isJSONEnvelope = require(\"./../support/isJSONEnvelope\");\nvar noop = require(\"./../support/noop\");\nvar empty = { dispose: noop, unsubscribe: noop };\nvar __version = require(\"./../internal/version\");\nvar isFunction = require(\"./../support/isFunction\");\n\nfunction InvalidateResponse(model, args, initialCacheVersion) {\n    // TODO: This should be removed.  There should only be 1 type of arguments\n    // coming in, but we have strayed from documentation.\n    this._model = model;\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    var currentVersion = model._root.cache[__version];\n\n    if (typeof initialCacheVersion === \"number\") {\n        this.initialCacheVersion = initialCacheVersion;\n    } else if (typeof currentVersion === \"number\") {\n        this.initialCacheVersion = currentVersion;\n    } else {\n        this.initialCacheVersion = model._root.version;\n    }\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg)) {\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        } else {\n            throw new Error(\"Invalid Input\");\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n}\n\nInvalidateResponse.prototype = Object.create(ModelResponse.prototype);\nInvalidateResponse.prototype.progressively = function progressively() {\n    return this;\n};\nInvalidateResponse.prototype._toJSONG = function _toJSONG() {\n    return this;\n};\n\nInvalidateResponse.prototype._subscribe = function _subscribe(observer) {\n\n    var model = this._model;\n    this._groups.forEach(function(group) {\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n        var operationName = \"_invalidate\" + inputType;\n        var operationFunc = model[operationName];\n        operationFunc(model, methodArgs);\n    });\n    observer.onCompleted();\n\n    var modelRoot = model._root;\n    var modelCache = modelRoot.cache;\n    var currentVersion = modelCache[__version];\n    var initialCacheVersion = this.initialCacheVersion;\n    var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n    if (initialCacheVersion !== currentVersion && (\n        modelRoot.syncRefCount <= 0) &&\n        isFunction(rootOnChangesCompletedHandler)) {\n        rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n    }\n\n    return empty;\n};\n\nmodule.exports = InvalidateResponse;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/InvalidateResponse.js","var checkCacheAndReport = require(\"./checkCacheAndReport\");\nvar MaxRetryExceededError = require(\"./../../errors/MaxRetryExceededError\");\nvar collectLru = require(\"./../../lru/collect\");\nvar getSize = require(\"./../../support/getSize\");\nvar AssignableDisposable = require(\"./../AssignableDisposable\");\nvar InvalidSourceError = require(\"../../errors/InvalidSourceError\");\nvar isFunction = require(\"./../../support/isFunction\");\n\n/**\n * The get request cycle for checking the cache and reporting\n * values.  If there are missing paths then the async request cycle to\n * the data source is performed until all paths are resolved or max\n * requests are made.\n * @param {GetResponse} getResponse -\n * @param {Model} model - The model that the request was made with.\n * @param {Object} results -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @private\n */\nmodule.exports = function getRequestCycle(getResponse, model, results, observer,\n                                          errors, count, initialCacheVersion) {\n    // we have exceeded the maximum retry limit.\n    if (count === 10) {\n        throw new MaxRetryExceededError();\n    }\n\n    var requestQueue = model._request;\n    var requestedMissingPaths = results.requestedMissingPaths;\n    var optimizedMissingPaths = results.optimizedMissingPaths;\n    var disposable = new AssignableDisposable();\n\n    // We need to prepend the bound path to all requested missing paths and\n    // pass those into the requestQueue.\n    var boundRequestedMissingPaths = [];\n    var boundPath = model._path;\n    if (boundPath.length) {\n        for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {\n            boundRequestedMissingPaths[i] =\n                fastCat(boundPath, requestedMissingPaths[i]);\n        }\n    }\n\n    // No bound path, no array copy and concat.\n    else {\n        boundRequestedMissingPaths = requestedMissingPaths;\n    }\n\n    var currentRequestDisposable = requestQueue.\n        get(boundRequestedMissingPaths, optimizedMissingPaths, function(err) {\n\n            if (err instanceof InvalidSourceError) {\n                observer.onError(err);\n                return;\n            }\n\n            // Once the request queue finishes, check the cache and bail if\n            // we can.\n            var nextResults = checkCacheAndReport(model, requestedMissingPaths,\n                                                  observer,\n                                                  getResponse.isProgressive,\n                                                  getResponse.isJSONGraph,\n                                                  results.values, errors);\n\n            // If there are missing paths coming back form checkCacheAndReport\n            // the its reported from the core cache check method.\n            if (nextResults) {\n\n                // update the which disposable to use.\n                disposable.currentDisposable =\n                    getRequestCycle(getResponse, model, nextResults, observer,\n                                    errors, count + 1, initialCacheVersion);\n            }\n\n            // We have finished.  Since we went to the dataSource, we must\n            // collect on the cache.\n            else {\n\n                var modelRoot = model._root;\n                var modelCache = modelRoot.cache;\n                var currentVersion = modelCache.ツversion;\n\n                collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                        model._maxSize, model._collectRatio, currentVersion);\n\n                var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n                if (initialCacheVersion !== currentVersion && (\n                    modelRoot.syncRefCount <= 0) &&\n                    isFunction(rootOnChangesCompletedHandler)) {\n                    rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n                }\n            }\n\n        });\n    disposable.currentDisposable = currentRequestDisposable;\n    return disposable;\n};\n\nfunction fastCat(arr1, arr2) {\n    var a = [], i, len, j;\n    for (i = 0, len = arr1.length; i < len; i++) {\n        a[i] = arr1[i];\n    }\n    for (j = 0, len = arr2.length; j < len; j++) {\n        a[i++] = arr2[j];\n    }\n    return a;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/get/getRequestCycle.js","var ModelResponse = require(\"./../ModelResponse\");\nvar GET_VALID_INPUT = require(\"./validInput\");\nvar validateInput = require(\"./../../support/validateInput\");\nvar GetResponse = require(\"./GetResponse\");\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nmodule.exports = function get(...paths) {\n    // Validates the input.  If the input is not pathSets or strings then we\n    // will onError.\n    var out = validateInput(paths, GET_VALID_INPUT, \"get\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n\n    return new GetResponse(this, paths);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/get/index.js","module.exports = mergeInto;\n\n/* eslint-disable camelcase */\nfunction mergeInto(dest, node) {\n\n    var destValue, nodeValue,\n        key, keys = Object.keys(node),\n        index = -1, length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key !== \"$__path\" &&\n            key !== \"$__refPath\" &&\n            key !== \"$__toReference\") {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (destValue === undefined || \"object\" !== typeof nodeValue) {\n                    dest[key] = nodeValue;\n                }\n                else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    var $__path = node.$__path;\n\n    if ($__path) {\n        dest.$__path = $__path;\n        var $__refPath = node.$__refPath;\n        var $__toReference = node.$__toReference;\n        if ($__refPath && $__toReference) {\n            dest.$__refPath = $__refPath;\n            dest.$__toReference = $__toReference;\n        }\n    }\n\n    return dest;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/get/mergeInto.js","var setValidInput = require(\"./setValidInput\");\nvar validateInput = require(\"./../../support/validateInput\");\nvar SetResponse = require(\"./SetResponse\");\nvar ModelResponse = require(\"./../ModelResponse\");\n\nmodule.exports = function set() {\n    var out = validateInput(arguments, setValidInput, \"set\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    var args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n    }\n    return new SetResponse(this, args);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/set/index.js","var arrayFlatMap = require(\"./../../support/array-flat-map\");\n\n/**\n * Takes the groups that are created in the SetResponse constructor and sets\n * them into the cache.\n */\nmodule.exports = function setGroupsIntoCache(model, groups) {\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var groupIndex = -1;\n    var groupCount = groups.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var returnValue = {\n        requestedPaths: requestedPaths,\n        optimizedPaths: optimizedPaths\n    };\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = groups[groupIndex];\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n\n        if (methodArgs.length > 0) {\n            var operationName = \"_set\" + inputType;\n            var operationFunc = model[operationName];\n            var successfulPaths = operationFunc(model, methodArgs, errorSelector);\n\n            optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);\n\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));\n            } else if (inputType === \"JSONGs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, successfulPaths[0]);\n            }\n        }\n    }\n\n    return returnValue;\n};\n\nfunction pluckPath(pathValue) {\n    return pathValue.path;\n}\n\nfunction pluckEnvelopePaths(jsonGraphEnvelope) {\n    return jsonGraphEnvelope.paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/set/setGroupsIntoCache.js","var emptyArray = [];\nvar AssignableDisposable = require(\"./../AssignableDisposable\");\nvar GetResponse = require(\"./../get/GetResponse\");\nvar setGroupsIntoCache = require(\"./setGroupsIntoCache\");\nvar getWithPathsAsPathMap = require(\"./../../get\").getWithPathsAsPathMap;\nvar InvalidSourceError = require(\"./../../errors/InvalidSourceError\");\nvar MaxRetryExceededError = require(\"./../../errors/MaxRetryExceededError\");\n\n/**\n * The request cycle for set.  This is responsible for requesting to dataSource\n * and allowing disposing inflight requests.\n */\nmodule.exports = function setRequestCycle(model, observer, groups,\n                                          isJSONGraph, isProgressive, count,\n                                          initialCacheVersion) {\n    // we have exceeded the maximum retry limit.\n    if (count === 10) {\n        throw new MaxRetryExceededError();\n    }\n\n    var requestedAndOptimizedPaths = setGroupsIntoCache(model, groups);\n    var optimizedPaths = requestedAndOptimizedPaths.optimizedPaths;\n    var requestedPaths = requestedAndOptimizedPaths.requestedPaths;\n    var isMaster = model._source === undefined;\n\n    // Local set only.  We perform a follow up get.  If performance is ever\n    // a requirement simply requiring in checkCacheAndReport and use get request\n    // internals.  Figured this is more \"pure\".\n    if (isMaster) {\n        return subscribeToFollowupGet(model, observer, requestedPaths,\n                              isJSONGraph, isProgressive, initialCacheVersion);\n    }\n\n\n    // Progressively output the data from the first set.\n    if (isProgressive) {\n        var results = getWithPathsAsPathMap(model, requestedPaths, [{}]);\n        if (results.criticalError) {\n            observer.onError(results.criticalError);\n            return null;\n        }\n        observer.onNext(results.values[0]);\n    }\n\n    var currentJSONGraph = getJSONGraph(model, optimizedPaths);\n    var disposable = new AssignableDisposable();\n\n    // Sends out the setRequest.  The Queue will call the callback with the\n    // JSONGraph envelope / error.\n    var requestDisposable = model._request.\n        // TODO: There is error handling that has not been addressed yet.\n\n        // If disposed before this point then the sendSetRequest will not\n        // further any callbacks.  Therefore, if we are at this spot, we are\n        // not disposed yet.\n        set(currentJSONGraph, function(error, jsonGraphEnv) {\n            if (typeof error === InvalidSourceError) {\n                observer.onError(error);\n                return;\n            }\n\n            // TODO: This seems like there are errors with this approach, but\n            // for sanity sake I am going to keep this logic in here until a\n            // rethink can be done.\n            var isCompleted = false;\n            if (error || optimizedPaths.length === jsonGraphEnv.paths.length) {\n                isCompleted = true;\n            }\n\n            // Happy case.  One request to the dataSource will fulfill the\n            // required paths.\n            if (isCompleted) {\n                disposable.currentDisposable =\n                    subscribeToFollowupGet(model, observer, requestedPaths,\n                                          isJSONGraph, isProgressive, initialCacheVersion);\n            }\n\n            // TODO: The unhappy case.  I am unsure how this can even be\n            // achieved.\n            else {\n                // We need to restart the setRequestCycle.\n                setRequestCycle(model, observer, groups, isJSONGraph,\n                                isProgressive, count + 1, initialCacheVersion);\n            }\n        });\n\n    // Sets the current disposable as the requestDisposable.\n    disposable.currentDisposable = requestDisposable;\n\n    return disposable;\n};\n\nfunction getJSONGraph(model, optimizedPaths) {\n    var boundPath = model._path;\n    var envelope = {};\n    model._path = emptyArray;\n    model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);\n    model._path = boundPath;\n\n    return envelope;\n}\n\nfunction subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph,\n                               isProgressive, initialCacheVersion) {\n\n    // Creates a new response and subscribes to it with the original observer.\n    // Also sets forceCollect to true, incase the operation is synchronous and\n    // exceeds the cache limit size\n    var response = new GetResponse(model, requestedPaths, isJSONGraph,\n                                   isProgressive, true, initialCacheVersion);\n    return response.subscribe(observer);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/set/setRequestCycle.js","module.exports = {\n    pathValue: true,\n    pathSyntax: true,\n    json: true,\n    jsonGraph: true\n};\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/response/set/setValidInput.js","var empty = {dispose: function() {}};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/ImmediateScheduler.js","function TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    var id = setTimeout(action, this.delay);\n    return new TimerDisposable(id);\n};\n\nTimerDisposable.prototype.dispose = function() {\n    if (this.disposed) {\n        return;\n    }\n\n    clearTimeout(this.id);\n    this.disposed = true;\n};\n\nmodule.exports = TimeoutScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/TimeoutScheduler.js","var ModelResponse = require(\"./../response/ModelResponse\");\nvar isPathValue = require(\"./../support/isPathValue\");\n\nmodule.exports = function setValue(pathArg, valueArg) {\n    var value = isPathValue(pathArg) ? pathArg : { path: pathArg, value: valueArg };\n    var pathIdx = 0;\n    var path = value.path;\n    var pathLen = path.length;\n    while (++pathIdx < pathLen) {\n        if (typeof path[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.set(value).subscribe(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = path.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[path[depth]];\n            }\n            obs.onNext(curr);\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/set/setValue.js","module.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/array-flat-map.js","var unicodePrefix = require(\"./../internal/unicodePrefix\");\nvar hasOwn = require(\"./../support/hasOwn\");\nvar isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function clone(value) {\n    var dest = value;\n    if (isObject(dest)) {\n        dest = isArray(value) ? [] : {};\n        var src = value;\n        for (var key in src) {\n            if (key.charAt(0) === unicodePrefix || !hasOwn(src, key)) {\n                continue;\n            }\n            dest[key] = src[key];\n        }\n    }\n    return dest;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/clone.js","var isObject = require(\"./isObject\");\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getExpires.js","var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getType.js","var now = require(\"./../support/now\");\nvar $now = require(\"./../values/expires-now\");\nvar $never = require(\"./../values/expires-never\");\n\nmodule.exports = function isAlreadyExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never) && (\n        exp !== $now) && (\n        exp < now());\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isAlreadyExpired.js","var unicodePrefix = require(\"./../internal/unicodePrefix\");\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nmodule.exports = function isInternalKey(x) {\n    return x === \"$size\" ||\n        x === \"$modelCreated\" ||\n        x.charAt(0) === unicodePrefix;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isInternalKey.js","var $ref = require(\"./../types/ref\");\nvar $error = require(\"./../types/error\");\nvar getSize = require(\"./../support/getSize\");\nvar getTimestamp = require(\"./../support/getTimestamp\");\nvar isObject = require(\"./../support/isObject\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\n\nvar wrapNode = require(\"./../support/wrapNode\");\nvar insertNode = require(\"./../support/insertNode\");\nvar expireNode = require(\"./../support/expireNode\");\nvar replaceNode = require(\"./../support/replaceNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar reconstructPath = require(\"./../support/reconstructPath\");\n\nmodule.exports = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n\n        // The messange and cache are both undefined, therefore return null.\n        else if (message === undefined) {\n            return message;\n        }\n\n        else {\n            cIsObject = isObject(node);\n            if (cIsObject) {\n                // Is the cache node a branch? If so, return the cache branch.\n                cType = node.$type;\n                if (cType == null) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node.ツparent == null) {\n                        insertNode(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n            }\n        }\n    } else {\n        cIsObject = isObject(node);\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty, leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node.ツparent != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n\n        if (mType === $error && isFunction(errorSelector)) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n        }\n\n        if (mType && node === message) {\n            if (node.ツparent == null) {\n                node = wrapNode(node, cType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            if ((cType && !isExpired(node)) || !cIsObject) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                //\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n                // If at least one of the cache/message are sentinels, compare them.\n                if (isDistinct && (cType || mType) && isFunction(comparator)) {\n                    isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (isDistinct) {\n                message = wrapNode(message, mType, mType ? message.value : message);\n                sizeOffset = getSize(node) - getSize(message);\n                node = replaceNode(node, message, parent, key, lru, version);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node)) {\n            expireNode(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode(message, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/mergeJSONGraphNode.js","var __ref = require(\"./../internal/ref\");\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode.ツrefsLength || 0,\n        destNodeRefsLength = destNode.ツrefsLength || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[__ref + i];\n        if (ref !== void 0) {\n            ref.ツcontext = destNode;\n            destNode[__ref + (destNodeRefsLength + i)] = ref;\n            fromNode[__ref + i] = void 0;\n        }\n    }\n    destNode.ツrefsLength = fromNodeRefsLength + destNodeRefsLength;\n    fromNode.ツrefsLength = void 0;\n    return destNode;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/transferBackReferences.js","var __ref = require(\"./../internal/ref\");\n\nmodule.exports = function unlinkBackReferences(node) {\n    var i = -1, n = node.ツrefsLength || 0;\n    while (++i < n) {\n        var ref = node[__ref + i];\n        if (ref != null) {\n            ref.ツcontext = ref.ツrefIndex = node[__ref + i] = void 0;\n        }\n    }\n    node.ツrefsLength = void 0;\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/unlinkBackReferences.js","var __ref = require(\"./../internal/ref\");\n\nmodule.exports = function unlinkForwardReference(reference) {\n    var destination = reference.ツcontext;\n    if (destination) {\n        var i = (reference.ツrefIndex || 0) - 1,\n            n = (destination.ツrefsLength || 0) - 1;\n        while (++i <= n) {\n            destination[__ref + i] = destination[__ref + (i + 1)];\n        }\n        destination.ツrefsLength = n;\n        reference.ツrefIndex = reference.ツcontext = destination = void 0;\n    }\n    return reference;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/unlinkForwardReference.js","/**\n * FromEsObserverAdapter is an adpater from an ES Observer to an Rx 2 Observer\n * @constructor FromEsObserverAdapter\n*/\nfunction FromEsObserverAdapter(esObserver) {\n    this.esObserver = esObserver;\n}\n\nFromEsObserverAdapter.prototype = {\n    onNext: function onNext(value) {\n        if (typeof this.esObserver.next === \"function\") {\n            this.esObserver.next(value);\n        }\n    },\n    onError: function onError(error) {\n        if (typeof this.esObserver.error === \"function\") {\n            this.esObserver.error(error);\n        }\n    },\n    onCompleted: function onCompleted() {\n        if (typeof this.esObserver.complete === \"function\") {\n            this.esObserver.complete();\n        }\n    }\n};\n\n/**\n * ToEsSubscriptionAdapter is an adpater from the Rx 2 subscription to the ES subscription\n * @constructor ToEsSubscriptionAdapter\n*/\nfunction ToEsSubscriptionAdapter(subscription) {\n    this.subscription = subscription;\n}\n\nToEsSubscriptionAdapter.prototype.unsubscribe = function unsubscribe() {\n    this.subscription.dispose();\n};\n\n\nfunction toEsObservable(_self) {\n    return {\n        subscribe: function subscribe(observer) {\n            return new ToEsSubscriptionAdapter(_self.subscribe(new FromEsObserverAdapter(observer)));\n        }\n    };\n}\n\nmodule.exports = toEsObservable;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/toEsObservable.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 129\n// module chunks = 0"],"sourceRoot":""}