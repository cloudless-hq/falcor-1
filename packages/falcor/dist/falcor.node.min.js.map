{"version":3,"sources":["webpack:///falcor.node.min.js","webpack:///webpack/bootstrap 80d04bf5c7888396eb8e","webpack:///./lib/cache/isExpired.js","webpack:///./lib/cache/expireNode.js","webpack:///./lib/cache/get/json/FalcorJSON.js","webpack:///./lib/errors/NullInPathError.js","webpack:///./lib/errors/createErrorClass.js","webpack:///./lib/support/isObject.js","webpack:///./lib/cache/clone.js","webpack:///./lib/cache/createHardlink.js","webpack:///./lib/support/getSize.js","webpack:///./lib/cache/getCachePosition.js","webpack:///./lib/cache/updateNodeAncestors.js","webpack:///./lib/errors/InvalidKeySetError.js","webpack:///./lib/lru/promote.js","webpack:///./lib/request/Subscriber.js","webpack:///./lib/request/Subscription.js","webpack:///./lib/cache/get/onValueType.js","webpack:///./lib/cache/getBoundCacheNode.js","webpack:///./lib/cache/set/setJSONGraphs.js","webpack:///./lib/cache/set/setPathMaps.js","webpack:///./lib/support/isInternalKey.js","webpack:///external \"@graphistry/falcor-path-utils/lib/support/materializedAtom\"","webpack:///./lib/cache/get/json/index.js","webpack:///./lib/cache/get/jsonGraph/index.js","webpack:///./lib/cache/get/jsonGraph/inlineValue.js","webpack:///./lib/cache/get/onMissing.js","webpack:///./lib/cache/invalidate/invalidatePathSets.js","webpack:///./lib/cache/removeNodeAndDescendants.js","webpack:///./lib/cache/set/setPathValues.js","webpack:///./lib/cache/updateBackReferenceVersions.js","webpack:///./lib/internal/isInternal.js","webpack:///./lib/support/getTimestamp.js","webpack:///./lib/values/expires-now.js","webpack:///(webpack)/buildin/global.js","webpack:///external \"@graphistry/falcor-path-utils/lib/iterateKeySet\"","webpack:///./lib/cache/get/json/getJSON.js","webpack:///./lib/cache/get/json/getReferenceTarget.js","webpack:///./lib/cache/get/json/onValue.js","webpack:///./lib/cache/get/jsonGraph/getJSONGraph.js","webpack:///./lib/cache/get/onMaterialize.js","webpack:///./lib/cache/groupCacheArguments.js","webpack:///./lib/cache/insertNode.js","webpack:///./lib/cache/invalidate/invalidatePathMaps.js","webpack:///./lib/cache/mergeValueOrInsertBranch.js","webpack:///./lib/cache/reconstructPath.js","webpack:///./lib/cache/replaceNode.js","webpack:///./lib/cache/wrapNode.js","webpack:///./lib/errors/CircularReferenceError.js","webpack:///./lib/errors/InvalidSourceError.js","webpack:///./lib/lru/splice.js","webpack:///./lib/request/Source.js","webpack:///./lib/schedulers/ImmediateScheduler.js","webpack:///./lib/support/isJSONEnvelope.js","webpack:///./lib/support/isJSONGraphEnvelope.js","webpack:///./lib/support/now.js","webpack:///./lib/values/expires-never.js","webpack:///external \"@graphistry/falcor-path-utils/lib/collapse\"","webpack:///./lib/index.js","webpack:///./lib/Model.js","webpack:///./lib/ModelDataSourceAdapter.js","webpack:///./lib/ModelRoot.js","webpack:///./lib/cache/call/index.js","webpack:///./lib/cache/get/index.js","webpack:///./lib/cache/get/json/onError.js","webpack:///./lib/cache/get/json/walkFlatBuffer.js","webpack:///./lib/cache/get/json/walkPath.js","webpack:///./lib/cache/get/jsonGraph/getReferenceTarget.js","webpack:///./lib/cache/get/jsonGraph/onValue.js","webpack:///./lib/cache/get/jsonGraph/walkPath.js","webpack:///./lib/cache/get/onMaterializeFlatBuffer.js","webpack:///./lib/cache/getCache.js","webpack:///./lib/cache/getVersion.js","webpack:///./lib/cache/invalidate/index.js","webpack:///./lib/cache/mergeJSONGraphNode.js","webpack:///./lib/cache/set/index.js","webpack:///./lib/cache/transferBackReferences.js","webpack:///./lib/cache/unlinkBackReferences.js","webpack:///./lib/cache/unlinkForwardReference.js","webpack:///./lib/deref/hasValidParentReference.js","webpack:///./lib/deref/index.js","webpack:///./lib/errors/BoundJSONGraphModelError.js","webpack:///./lib/errors/InvalidDerefInputError.js","webpack:///./lib/errors/InvalidModelError.js","webpack:///./lib/errors/MaxRetryExceededError.js","webpack:///./lib/internal/f_.js","webpack:///./lib/lru/collect.js","webpack:///./lib/request/Call.js","webpack:///./lib/request/Queue.js","webpack:///./lib/request/Request.js","webpack:///./lib/request/Subject.js","webpack:///./lib/schedulers/TimeoutScheduler.js","webpack:///./lib/support/clone.js","webpack:///./lib/support/getExpires.js","webpack:///./lib/support/getType.js","webpack:///./lib/support/isPathValue.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/lib/index.js","webpack:///./~/symbol-observable/lib/ponyfill.js","webpack:///(webpack)/buildin/module.js","webpack:///external \"@graphistry/falcor-path-utils/lib/computeFlatBufferHash\"","webpack:///external \"@graphistry/falcor-path-utils/lib/flatBufferToPaths\"","webpack:///external \"@graphistry/falcor-path-utils/lib/getHashCode\"","webpack:///external \"@graphistry/falcor-path-utils/lib/hasIntersection\"","webpack:///external \"@graphistry/falcor-path-utils/lib/toCollapseMap\"","webpack:///external \"@graphistry/falcor-path-utils/lib/toCollapseTrees\"","webpack:///external \"@graphistry/falcor-path-utils/lib/toFlatBuffer\"","webpack:///external \"@graphistry/falcor-path-utils/lib/toPaths\""],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","o","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","now","$now","$never","module.exports","node","expireImmediate","exp","undefined","splice","expired","lru","global","FalcorJSON","f_meta","getInst","inst","typeofInst","argsLen","arguments","typeofString","typeofObject","toJSON","serialize","toString","includeMetadata","includeStatus","JSON","toProps","f_meta_inst","f_meta_json","version","json","serializer","createWithProto","count","total","keys","key","xs","isArray","$code","status","abs_path","deref_to","deref_from","ys","protoBlacklist","length","constructor","toLocaleString","protoDescriptors","$__hash","$__path","$__status","$__version","Array","descriptors","fn","Function","bindArrayMethod","writable","createErrorClass","message","MESSAGE","init","E","Error","stack","E.is","x","isObject","isInternal","clone","index","from","to","backRefs","getCachePosition","cache","path","type","depth","maxDepth","removeNodeAndDescendants","updateBackReferenceVersions","updateNodeAncestors","offset","curr","next","keysOrRanges","mesage","EXPIRES_NEVER","root","head","prev","Subscriber","destination","parent","onCompleted","Subscription","error","onError","onNext","complete","Subscriber.prototype.onNext","dest","Subscriber.prototype.onError","signaled","dispose","Subscriber.prototype.onCompleted","Subscriber.prototype.unsubscribe","subscriptions","Subscription.prototype.add","subscription","push","Subscription.prototype.remove","indexOf","Subscription.prototype.unsubscribe","isExpired","expireNode","lruPromote","onValueType","seed","results","requestedPath","requestedLength","optimizedPath","optimizedLength","fromReference","modelRoot","branchSelector","boxValues","materialized","reportMissing","treatErrorsAsValues","onValue","onMissing","onMaterialize","reportMaterialized","getBoundCacheNode","model","setJSONGraphPathSet","messageRoot","messageParent","requestedPaths","optimizedPaths","comparator","errorSelector","note","branch","keySet","iterateKeySet","optimizedIndex","setNode","nextNode","nextParent","nextOptimizedPath","reference","container","createHardlink","arr","NullInPathError","mergeJSONGraphNode","jsonGraphEnvelopes","jsonGraphEnvelopeIndex","jsonGraphEnvelopeCount","jsonGraphEnvelope","paths","jsonGraph","pathIndex","pathCount","setPathMap","pathMap","itr","isInternalKey","keyIndex","keyCount","child","mergeValueOrInsertBranch","pathMapEnvelopes","bound","pathMapIndex","pathMapCount","pathMapEnvelope","require","inlineJSONGraphValue","keyset","restPathIndex","restPath","restPathCount","isEmptyKeySet","rangeEnd","mPath","lastKeyIsNull","isRequestedPath","missingPaths","missTotal","missingPath","missDepth","Number","invalidatePathSet","invalidateNode","getSize","invalidatePathSets","key2","lruSplice","unlinkForwardReference","unlinkBackReferences","setPathSet","pathValues","pathValueIndex","pathValueCount","pathValue","nodeArg","ref","f_","regexp","RegExp","g","eval","e","window","walkPathAndBuildOutput","walkFlatBufferAndBuildOutput","InvalidModelError","toFlatBuffer","computeFlatBufferHash","getJSON","progressive","referenceContainer","boundPath","isFlatBuffer","data","recycleJSON","hasDataSource","Boolean","allowFromWhenceYouCame","pathsIndex","pathsCount","requested","boundRequested","len","promote","CircularReferenceError","getReferenceTarget","context","copy","onJSONValue","BoundJSONGraphModelError","getJSONGraph","materializedAtom","nextDepth","keysetIndex","keysetLength","iteratingKeyset","nextKey","keyIsRange","InvalidKeySetError","typeofNumber","isPathValue","isJSONEnvelope","isJSONGraphEnvelope","groupCacheArguments","args","groups","argIndex","argCount","group","groupType","arg","argType","inputType","invalidatePathMap","invalidatePathMaps","getType","getTimestamp","wrapNode","insertNode","replaceNode","reconstructPath","cType","mType","sizeOffset","currentPath","transferBackReferences","replacement","getExpires","expiresNow","typeArg","size","modelCreated","$type","atomSize","expires","referencePath","Source","subscribe","source","$$observable","default","Source.prototype.operator","Source.prototype.subscribe","y","operator","Source.prototype.then","_promise","resolve","reject","values","rejected","errors","then","ImmediateScheduler","empty","unsubscribe","ImmediateScheduler.prototype.schedule","action","envelope","Date","falcor","opts","Model","options","_node","_path","_source","_root","ModelRoot","_recycleJSON","_scheduler","_seed","_treatErrorsAsValues","__proto__","_boxed","_materialized","_allowFromWhenceYouCame","setCache","Call","ModelDataSourceAdapter","TimeoutScheduler","collapse","setJSONGraphs","getCache","Model.prototype.get","_len","_key","_toJSON","Model.prototype.set","_len2","_key2","Model.prototype.preload","_len3","_key3","Model.prototype.call","_len4","_key4","Model.prototype.invalidate","_len5","_key5","Model.prototype.getValue","lift","subscriber","Model.prototype.setValue","Model.prototype.setCache","cacheOrJSONGraphEnvelope","rootOnChangeHandler","Model.prototype.getCache","env","Model.prototype.getVersion","concat","_getVersion","Model.prototype._clone","Model.prototype.batch","schedulerOrDelay","scheduler","Math","scheudle","_clone","Model.prototype.unbatch","Model.prototype.treatErrorsAsValues","Model.prototype.asDataSource","Model.prototype._materialize","Model.prototype._dematerialize","Model.prototype.boxValues","Model.prototype.unboxValues","Model.prototype.withoutDataSource","Model.prototype.inspect","getVersion","join","Model.prototype.toJSON","getPath","Model.prototype.getPath","slice","Model.prototype._fromWhenceYouCame","allow","Model.prototype._optimizePath","_model","ModelDataSourceAdapter.prototype.get","pathSets","apply","_toJSONG","ModelDataSourceAdapter.prototype.set","jsongResponse","set","ModelDataSourceAdapter.prototype.call","suffixes","syncRefCount","maxRetryCount","topLevelModel","requests","Requests","collectRatio","maxSize","functionTypeof","onChange","onChangesCompleted","defaultCompare","_args","hasValue","missing","thisPaths","fragments","errorPath","errorValue","refTarget","f_old_keys","f_new_keys","f_code","nextJSON","nextReferenceContainer","nextOptimizedLength","optimizedLengthNext","refContainerAbsPath","refContainerRefPath","nodeAbsPath","jsonAbsPath","arrayEqual","keysIndex","keysLength","nextPath","nextPathKey","hasMissingPath","getHashCode","tmp","flatBufferToPaths","rPath","originalOnMissing","inlineValue","onJSONGraphValue","isLeaf","onMaterializeFlatBuffer","_copyCache","out","fromKey","cacheNext","outNext","isUserCreatedcacheNext","clonedValue","boxedValue","invalidate","changed","groupIndex","groupCount","groupedArgs","pluckPaths","operation","rootChangeHandler","invalidatePathValues","cIsObject","mIsObject","cTimestamp","mTimestamp","isDistinct","setGroupsIntoCache","arrayFlatMap","optimized","array","selector","array2","array3","j","k","jsong","relative","setPathMaps","setPathValues","fromNode","destNode","fromNodeRefsLength","destNodeRefsLength","hasValidParentReference","_referenceContainer","cacheRoot","absolutePath","originalRefPath","originalAbsPath","cacheNode","validContainer","CONTAINER_DOES_NOT_EXIST","currentRefPath","shortedPath","printPaths","absolute","String","totalArg","max","ratioArg","ratio","targetSize","CallOperator","CallSubscriber","retryCount","completed","tryOnNext","tryOnError","self","err","mergeInto","destValue","nodeValue","lruCollect","InvalidSourceError","MaxRetryExceededError","Call.prototype.lift","Call.prototype.operator","_subscribe","Call.prototype._subscribe","Call.prototype._toJSON","Call.prototype._toJSONG","Call.prototype.retry","progresive","Call.prototype.progressively","CallOperator.prototype.call","CallSubscriber.prototype.onNext","started","seedIsImmutable","operations","CallSubscriber.prototype.onError","errored","CallSubscriber.prototype.onCompleted","request","CallSubscriber.prototype.unsubscribe","rootOnChangesCompletedHandler","Queue","Dedupe","queue","dataSource","Request","isolateSet","isolateCall","callArgs","batchAndDedupeGet","Dedupe.prototype.subscribe","requestsIndex","requestsCount","batch","Subject","tree","responded","active","disposable","flush","obs","toPaths","toCollapseTrees","reduce","collapseMap","toCollapseMap","filterPathsBoundTo","boundLength","filtered","filteredIndex","outer","invalidatePaths","hasIntersection","Request.prototype.onNext","invalidated","observers","forEach","observer","Request.prototype.onError","errorPathValues","Request.prototype.onCompleted","Request.prototype.remove","Request.prototype.unsubscribe","Request.prototype.connect","scheduledDisposable","schedule","Request.prototype.batch","requestedComplements","optimizedComplements","requestedIntersection","optimizedIntersection","complementIndex","intersectionIndex","optTotal","reqTotal","pathLen","subTree","Subject.prototype.onError","Subject.prototype.onCompleted","Subject.prototype.subscribe","Subject.prototype.unsubscribe","delay","TimerDisposable","id","disposed","TimeoutScheduler.prototype.schedule","setTimeout","TimerDisposable.prototype.unsubscribe","clearTimeout","anyType","_ponyfill","_ponyfill2","result","symbolObservablePonyfill","_Symbol","Symbol","observable","webpackPolyfill","deprecate","module.deprecate","children"],"mappings":"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","file":"falcor.node.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 106);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar now = __webpack_require__(53);\nvar $now = __webpack_require__(31);\nvar $never = __webpack_require__(54);\n\nmodule.exports = function isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar splice = __webpack_require__(48);\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[\"\u001eƒ_invalidated\"]) {\n        node[\"\u001eƒ_invalidated\"] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {function FalcorJSON(f_meta) {\n    if (!f_meta) {\n        this[\"\u001eƒ_meta\"] = {};\n    } else if (!(this[\"\u001eƒ_meta\"] = f_meta[\"\u001eƒ_meta\"])) {\n        this[\"\u001eƒ_meta\"] = f_meta;\n    }\n}\n\nvar protoBlacklist = {\n    length: true,\n    toString: true,\n    constructor: true,\n    toLocaleString: true\n};\n\nvar protoDescriptors = {\n    toJSON: { enumerable: false, value: toJSON },\n    toProps: { enumerable: false, value: toProps },\n    toString: { enumerable: false, value: toString },\n    toLocaleString: { enumerable: false, value: toString },\n    $__hash: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta['$code'] || '';\n        }\n    },\n    $__path: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta[\"abs_path\"] || [];\n        }\n    },\n    $__status: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta[\"status\"] || 'resolved';\n        }\n    },\n    $__version: {\n        enumerable: false,\n        get: function () {\n            var f_meta = this[\"\u001eƒ_meta\"];\n            return f_meta && f_meta[\"version\"] || 0;\n        }\n    }\n};\n\nObject.defineProperties(FalcorJSON.prototype, Object.getOwnPropertyNames(Array.prototype).reduce(function (descriptors, name) {\n    if (!protoBlacklist.hasOwnProperty(name)) {\n        var fn = Array.prototype[name];\n        if (typeof fn === 'function') {\n            descriptors[name] = {\n                value: bindArrayMethod(name, fn),\n                writable: true, enumerable: false\n            };\n        }\n    }\n    return descriptors;\n}, protoDescriptors));\n\nfunction bindArrayMethod(name, fn) {\n    return new Function('fn', 'return function ' + name + ' () {' + 'return fn.apply(this, arguments);' + '};')(fn);\n}\n\nvar isArray = Array.isArray;\nvar typeofObject = 'object';\nvar typeofString = 'string';\n\nfunction getInst(inst) {\n    var typeofInst = typeof inst;\n    var argsLen = arguments.length;\n    if (argsLen === 0) {\n        inst = this;\n    } else if (typeofInst !== typeofString) {\n        if (!inst || typeofInst !== typeofObject) {\n            return inst;\n        }\n    } else if (argsLen !== 1) {\n        return inst;\n    } else {\n        inst = this;\n    }\n    return inst === global ? undefined : inst;\n}\n\nfunction toJSON() {\n    return serialize(getInst.apply(this, arguments), toJSON);\n}\n\nfunction toString(includeMetadata, includeStatus) {\n    return JSON.stringify(serialize(getInst.call(this, this), serialize, includeMetadata === true, false, includeStatus === true));\n}\n\nfunction toProps(inst) {\n\n    inst = getInst.apply(this, arguments);\n\n    var f_meta_inst,\n        f_meta_json,\n        version = 0;\n    var json = serialize(inst, toProps, true, true);\n\n    if (inst && (f_meta_inst = inst[\"\u001eƒ_meta\"])) {\n        version = f_meta_inst[\"version\"];\n    }\n\n    if (!(!json || typeof json !== typeofObject)) {\n        if (f_meta_json = json[\"\u001eƒ_meta\"]) {\n            f_meta_json[\"version\"] = version;\n        }\n    }\n\n    return json;\n}\n\nfunction serialize(inst, serializer, includeMetadata, createWithProto, includeStatus) {\n\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    }\n\n    var count, total, f_meta, keys, key, xs, ys;\n\n    if (isArray(inst)) {\n        xs = inst;\n    } else {\n\n        count = -1;\n        keys = Object.keys(inst);\n        total = keys.length;\n        xs = {};\n\n        if (createWithProto) {\n            xs.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (includeMetadata && (f_meta = inst[\"\u001eƒ_meta\"])) {\n\n            var $code = f_meta['$code'];\n            var status = f_meta[\"status\"];\n            var abs_path = f_meta[\"abs_path\"];\n            var deref_to = f_meta[\"deref_to\"];\n            var deref_from = f_meta[\"deref_from\"];\n\n            f_meta = {};\n            $code && (f_meta['$code'] = $code);\n            abs_path && (f_meta[\"abs_path\"] = abs_path);\n            deref_to && (f_meta[\"deref_to\"] = deref_to);\n            deref_from && (f_meta[\"deref_from\"] = deref_from);\n            includeStatus && status && (f_meta[\"status\"] = status);\n\n            xs[\"\u001eƒ_meta\"] = f_meta;\n\n            if (createWithProto) {\n                ys = {};\n                ys.__proto__ = xs;\n                xs = ys;\n            }\n        }\n\n        while (++count < total) {\n            if ((key = keys[count]) !== \"\u001eƒ_meta\") {\n                xs[key] = serializer(inst[key], serializer, includeMetadata, createWithProto, includeStatus);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = '`null` is not allowed in branch key positions.';\n\n/**\n * Do not allow null in path.\n */\nmodule.exports = createErrorClass('NullInPathError', function () {\n  this.message = MESSAGE;\n});\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = createErrorClass;\n\nfunction createErrorClass(name, init) {\n    function E(message) {\n        this.message = message;\n        init && init.apply(this, arguments);\n        if (!Error.captureStackTrace) {\n            this.stack = new Error().stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    E.prototype = Object.create(Error.prototype);\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    E.is = function (x) {\n        return x.name === name;\n    };\n    return E;\n}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = isObject;\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternal = __webpack_require__(29);\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key,\n        keys = Object.keys(node),\n        json = {},\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (isInternal(key)) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[\"\u001eƒ_refs_length\"] || 0;\n    to[\"\u001eƒ_ref\" + backRefs] = from;\n    to[\"\u001eƒ_refs_length\"] = backRefs + 1;\n\n    // create a hard reference\n    from[\"\u001eƒ_ref_index\"] = backRefs;\n    from[\"\u001eƒ_context\"] = to;\n};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type,\n        depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === \"ref\") {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar removeNodeAndDescendants = __webpack_require__(26);\nvar updateBackReferenceVersions = __webpack_require__(28);\n\nmodule.exports = updateNodeAncestors;\n\nfunction updateNodeAncestors(node, offset, lru, version) {\n    var curr = node,\n        next = curr[\"\u001eƒ_parent\"];\n    do {\n        if ((curr.$size = (curr.$size || 0) - offset) > 0) {\n            if (!(next = curr[\"\u001eƒ_parent\"])) {\n                curr[\"\u001eƒ_version\"] = version;\n            } else if (curr[\"\u001eƒ_version\"] !== version) {\n                updateBackReferenceVersions(curr, version);\n            }\n        } else if (next = curr[\"\u001eƒ_parent\"]) {\n            removeNodeAndDescendants(curr, next, curr[\"\u001eƒ_key\"], lru, version);\n        }\n    } while (curr = next);\n    return node;\n}\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidKeySetError', function (path, keysOrRanges) {\n  this.mesage = '' + 'The KeySet ' + JSON.stringify(keysOrRanges) + ' in path ' + JSON.stringify(path) + ' contains a KeySet. ' + 'Keysets can only contain Keys or Ranges';\n});\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EXPIRES_NEVER = __webpack_require__(54);\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root[\"\u001eƒ_head\"];\n\n    // Nothing is in the cache.\n    if (!head) {\n        root[\"\u001eƒ_head\"] = root[\"\u001eƒ_tail\"] = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[\"\u001eƒ_prev\"];\n    var next = object[\"\u001eƒ_next\"];\n    if (next) {\n        next[\"\u001eƒ_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\u001eƒ_next\"] = next;\n    }\n    object[\"\u001eƒ_prev\"] = undefined;\n\n    // Insert into head position\n    root[\"\u001eƒ_head\"] = object;\n    object[\"\u001eƒ_next\"] = head;\n    head[\"\u001eƒ_prev\"] = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root[\"\u001eƒ_tail\"]) {\n        root[\"\u001eƒ_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscription = __webpack_require__(14);\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' || typeof parent === 'function' || typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        };\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next = Subscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n};\n\nSubscriber.prototype.error = Subscriber.prototype.onError = function onError(error) {\n    var signaled = false;\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            signaled = true;\n            dest.onError(error);\n        } else if (dest.error) {\n            signaled = true;\n            dest.error(error);\n        }\n        this.dispose();\n    }\n    if (!signaled) {\n        throw error;\n    }\n};\n\nSubscriber.prototype.complete = Subscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n};\n\nSubscriber.prototype.dispose = Subscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function (subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n};\n\nSubscription.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n};\n\nSubscription.prototype.dispose = Subscription.prototype.unsubscribe = function () {\n    var subscription,\n        subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) && subscription.dispose && subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar lruPromote = __webpack_require__(12);\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, reportMissing, treatErrorsAsValues, onValue, onMissing, onMaterialize) {\n\n    var reportMaterialized = reportMissing;\n\n    if (type) {\n        if (isExpired(node, expireImmediate)) {\n            if (!node[\"\u001eƒ_invalidated\"]) {\n                expireNode(node, expired, modelRoot);\n            }\n        } else {\n            lruPromote(modelRoot, node);\n            if (node.value === undefined) {\n                reportMissing = false;\n                reportMaterialized = materialized;\n            } else {\n                if (seed) {\n                    if (fromReference) {\n                        requestedPath[depth] = null;\n                    }\n                    return onValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues);\n                }\n                return undefined;\n            }\n        }\n    }\n\n    if (materialized) {\n        seed && (results.hasValue = true);\n    } else if (!reportMaterialized) {\n        return undefined;\n    }\n\n    return onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, materialized, json, branchSelector, boxValues, onMaterialize, modelRoot);\n}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getCachePosition = __webpack_require__(9);\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[\"\u001eƒ_parent\"] === undefined || node[\"\u001eƒ_invalidated\"]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(5);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar createHardlink = __webpack_require__(7);\nvar mergeJSONGraphNode = __webpack_require__(72);\nvar NullInPathError = __webpack_require__(3);\nvar iterateKeySet = __webpack_require__(33);\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    if (cache[\"\u001eƒ_version\"] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, results[3], results[2], requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            node = results[0];\n            optimizedPath = results[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[\"\u001eƒ_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, messageRoot, messageParent, message, key, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isArray = Array.isArray;\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar createHardlink = __webpack_require__(7);\nvar getCachePosition = __webpack_require__(9);\nvar isInternalKey = __webpack_require__(19);\nvar NullInPathError = __webpack_require__(3);\nvar mergeValueOrInsertBranch = __webpack_require__(42);\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, modelRoot, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[\"\u001eƒ_version\"] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[\"\u001eƒ_context\"];\n\n        if (node != null) {\n            parent = node[\"\u001eƒ_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\u001eƒ_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = 'length';\n        }\n        for (var key in pathMap) {\n            if (isInternalKey(key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return undefined;\n}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nmodule.exports = isInternalKey;\n\nvar isInternal = __webpack_require__(29);\n\nfunction isInternalKey(key) {\n  return key && key[0] === '$' || isInternal(key);\n}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/support/materializedAtom\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(34);\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(37);\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nmodule.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key,\n        depth = 0,\n        prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nvar isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, json, branchSelector, boxValues, onMaterialize, modelRoot) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        return onMaterialize(json, mPath, missDepth, missTotal, branchSelector, boxValues, modelRoot);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if ('object' !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if ('number' !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar lruPromote = __webpack_require__(12);\nvar getSize = __webpack_require__(8);\nvar createHardlink = __webpack_require__(7);\nvar getBoundCacheNode = __webpack_require__(16);\nvar updateNodeAncestors = __webpack_require__(10);\nvar iterateKeySet = __webpack_require__(33);\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = invalidatePathSets;\n\nfunction invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(path, 0, cache, parent, node, version, expired, lru, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[\"\u001eƒ_version\"] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathSet(path, depth, root, parent, node, version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        arr = invalidateNode(root, parent, node, key, branch, false, version, expired, lru, expireImmediate);\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru, expireImmediate);\n            } else {\n                updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\u001eƒ_context\"];\n\n    if (node != null) {\n        parent = node[\"\u001eƒ_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(root, parent, node, key, branch, true, version, expired, lru, expireImmediate);\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[\"\u001eƒ_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(root, parent, node, key, branch, reference, version, expired, lru, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        arr = invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar lruSplice = __webpack_require__(48);\nvar isInternalKey = __webpack_require__(19);\nvar unlinkBackReferences = __webpack_require__(75);\nvar unlinkForwardReference = __webpack_require__(76);\nvar updateBackReferenceVersions = __webpack_require__(28);\n\nmodule.exports = removeNodeAndDescendants;\n\nfunction removeNodeAndDescendants(node, parent, key, lru, version) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type === undefined) {\n            for (var key2 in node) {\n                if (!isInternalKey(key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru, version);\n                }\n            }\n        } else {\n            if (type === \"ref\") {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(updateBackReferenceVersions(node, version));\n        parent[key] = node[\"\u001eƒ_parent\"] = undefined;\n        return true;\n    }\n    return false;\n}\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar createHardlink = __webpack_require__(7);\nvar getCachePosition = __webpack_require__(9);\nvar NullInPathError = __webpack_require__(3);\nvar iterateKeySet = __webpack_require__(33);\nvar mergeValueOrInsertBranch = __webpack_require__(42);\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, modelRoot, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[\"\u001eƒ_version\"] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[\"\u001eƒ_context\"];\n\n        if (node != null) {\n            parent = node[\"\u001eƒ_parent\"] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[\"\u001eƒ_context\"] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate);\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = updateBackReferenceVersions;\n\nfunction updateBackReferenceVersions(nodeArg, version) {\n    var node = nodeArg,\n        stack = [],\n        count = 0,\n        ref,\n        i,\n        n;\n    do {\n        i = -1;\n        ref = node[\"\u001eƒ_parent\"];\n        node[\"\u001eƒ_version\"] = version;\n        n = node[\"\u001eƒ_refs_length\"] || 0;\n        do {\n            if (ref && ref[\"\u001eƒ_version\"] !== version) {\n                stack[count++] = ref;\n            }\n            if (++i < n) {\n                ref = node[\"\u001eƒ_ref\" + i];\n                continue;\n            }\n            break;\n        } while (true);\n    } while (node = stack[--count]);\n    return nodeArg;\n}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * Determined if the key passed in is an f_ internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nvar f_ = __webpack_require__(83);\nvar regexp = new RegExp('^' + f_, 'i', 'g');\n\nmodule.exports = regexp.test.bind(regexp);\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\nmodule.exports = 0;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/iterateKeySet\");\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar walkPathAndBuildOutput = __webpack_require__(64);\nvar walkFlatBufferAndBuildOutput = __webpack_require__(63);\nvar getBoundCacheNode = __webpack_require__(16);\nvar InvalidModelError = __webpack_require__(81);\nvar toFlatBuffer = __webpack_require__(104);\nvar computeFlatBufferHash = __webpack_require__(98);\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        results = { data: seed },\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        materialized = seed && model._materialized,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    var arr,\n        path,\n        pathsIndex = 0,\n        pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n\n        if (recycleJSON) {\n            isFlatBuffer = true;\n            if (pathsCount > 1 || isArray(paths[0])) {\n                pathsCount = 1;\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n        }\n\n        do {\n            path = paths[pathsIndex];\n            if (isFlatBuffer) {\n                arr = walkFlatBufferAndBuildOutput(cache, node, json, paths[0], 0, seed, results, requestedPath, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            } else {\n                requestedLength = path.length;\n                arr = walkPathAndBuildOutput(cache, node, json, path,\n                /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n                /* fromReference = */false, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n            }\n            json = arr[0];\n            arr[0] = undefined;\n            arr[1] = undefined;\n        } while (++pathsIndex < pathsCount);\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(3);\nvar promote = __webpack_require__(12);\nvar isExpired = __webpack_require__(0);\nvar createHardlink = __webpack_require__(7);\nvar CircularReferenceError = __webpack_require__(46);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\u001eƒ_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === \"ref\") {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(6);\nvar onError = __webpack_require__(62);\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized, treatErrorsAsValues) {\n\n    if (\"error\" === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath, fromReference, boxValues);\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    return !boxValues ? node.value : clone(node);\n}\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar walkPathAndBuildOutput = __webpack_require__(67);\nvar BoundJSONGraphModelError = __webpack_require__(79);\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath,\n        requestedLength,\n        optimizedPath,\n        optimizedLength = boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        results = { data: seed },\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n        /* depth = */0, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength,\n        /* fromReference = */false, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args = results.relative = results.requested;\n\n    return results;\n}\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = __webpack_require__(6);\nvar FalcorJSON = __webpack_require__(2);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(11);\nvar materializedAtom = __webpack_require__(20);\n\nmodule.exports = onMaterialize;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterialize(json, path, depth, length, branchSelector, boxValues, modelRoot) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (depth === length) {\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta;\n\n    var nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0;\n\n    keyset = path[depth];\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[\"\u001eƒ_meta\"])) {\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n    } else {\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = path.slice(0, depth);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            // insert the materialized branch\n            json[nextKey] = onMaterialize(json[nextKey], path, nextDepth, length, branchSelector, boxValues, modelRoot);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isPathValue = __webpack_require__(93);\nvar isJSONEnvelope = __webpack_require__(51);\nvar isJSONGraphEnvelope = __webpack_require__(52);\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = 'PathValues';\n        } else if (isPathValue(arg)) {\n            argType = 'PathValues';\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = 'JSONGraphs';\n        } else if (isJSONEnvelope(arg)) {\n            argType = 'PathMaps';\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node[\"\u001eƒ_key\"] = key;\n    node[\"\u001eƒ_parent\"] = parent;\n\n    if (version !== undefined) {\n        node[\"\u001eƒ_version\"] = version;\n    }\n    if (!node[\"\u001eƒ_abs_path\"]) {\n        node[\"\u001eƒ_abs_path\"] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar lruPromote = __webpack_require__(12);\nvar getSize = __webpack_require__(8);\nvar createHardlink = __webpack_require__(7);\nvar getBoundCacheNode = __webpack_require__(16);\nvar isInternalKey = __webpack_require__(19);\nvar updateNodeAncestors = __webpack_require__(10);\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = invalidatePathMaps;\n\nfunction invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathMapIndex = -1;\n    var parent = node[\"\u001eƒ_parent\"] || cache;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, expireImmediate);\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[\"\u001eƒ_version\"] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (!isInternalKey(key)) {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            arr = invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, expireImmediate);\n            var nextNode = arr[0];\n            var nextParent = arr[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, expireImmediate);\n                } else {\n                    updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[\"\u001eƒ_context\"];\n\n    if (node != null) {\n        parent = node[\"\u001eƒ_parent\"] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, expireImmediate);\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[\"\u001eƒ_context\"] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(root, parent, node, key, value, branch, reference, version, expired, lru, comparator, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === \"ref\") {\n\n        arr = invalidateReference(value, root, node, version, expired, lru, comparator, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[\"\u001eƒ_key\"];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar $now = __webpack_require__(31);\nvar getType = __webpack_require__(92);\nvar getSize = __webpack_require__(8);\nvar getTimestamp = __webpack_require__(30);\n\nvar wrapNode = __webpack_require__(45);\nvar isExpired = __webpack_require__(0);\nvar expireNode = __webpack_require__(1);\nvar insertNode = __webpack_require__(40);\nvar replaceNode = __webpack_require__(44);\nvar reconstructPath = __webpack_require__(43);\nvar updateNodeAncestors = __webpack_require__(10);\nvar removeNodeAndDescendants = __webpack_require__(26);\n\nmodule.exports = function mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var cType = getType(node, reference);\n\n    if (branch || reference) {\n        if (cType && isExpired(node,\n        /* expireImmediate:\n         * force true so the node is marked as\n         * expired but keep using it for the merge if it expires immediately\n         */\n        true)) {\n            expireNode(node, expired, lru);\n            cType = node.$expires === $now ? cType : 'expired';\n        }\n        if (cType && cType !== \"ref\" || !node || typeof node !== 'object') {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var isDistinct = true;\n        var mType = getType(message);\n\n        // If both the cache and message are primitives,\n        // insert the message into the cache.\n        if (!cType && !mType) {\n            isDistinct = true;\n        }\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        else if (comparator) {\n                isDistinct = !(comparator.length < 3 ? comparator(node, message) : comparator(node, message, optimizedPath.slice(0, optimizedPath.index)));\n            } else {\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n            }\n\n        if (isDistinct) {\n\n            if (errorSelector && mType === \"error\") {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            var sizeOffset = getSize(node) - getSize(message = wrapNode(message, mType, mType ? message.value : message));\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n  var path = currentPath.slice(0, currentPath.depth);\n  path[path.length] = key;\n\n  return path;\n};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar transferBackReferences = __webpack_require__(74);\nvar removeNodeAndDescendants = __webpack_require__(26);\nvar updateBackReferenceVersions = __webpack_require__(28);\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar now = __webpack_require__(53);\nvar clone = __webpack_require__(90);\nvar getSize = __webpack_require__(8);\nvar getExpires = __webpack_require__(91);\nvar expiresNow = __webpack_require__(31);\n\nvar atomSize = 50;\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[\"\u001eƒ_wrapped_value\"];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[\"\u001eƒ_prev\"] = undefined;\n        node[\"\u001eƒ_next\"] = undefined;\n        node[\"\u001eƒ_wrapped_value\"] = modelCreated || false;\n    } else {\n        node = { $type: \"atom\", value: value };\n        node[\"\u001eƒ_prev\"] = undefined;\n        node[\"\u001eƒ_next\"] = undefined;\n        node[\"\u001eƒ_wrapped_value\"] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case 'object':\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case 'string':\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === 'number' && expires < expiresNow) {\n        node.$expires = now() + expires * -1;\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\n\nmodule.exports = createErrorClass('CircularReferenceError', function (referencePath) {\n    this.message = 'Encountered circular reference ' + JSON.stringify(referencePath);\n});\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'An exception was thrown when making a request';\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidSourceError', function (error) {\n  this.message = MESSAGE + ':\\n\\t' + error;\n});\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object[\"\u001eƒ_prev\"];\n    var next = object[\"\u001eƒ_next\"];\n    if (next) {\n        next[\"\u001eƒ_prev\"] = prev;\n    }\n    if (prev) {\n        prev[\"\u001eƒ_next\"] = next;\n    }\n    object[\"\u001eƒ_prev\"] = object[\"\u001eƒ_next\"] = undefined;\n\n    if (object === root[\"\u001eƒ_head\"]) {\n        root[\"\u001eƒ_head\"] = next;\n    }\n    if (object === root[\"\u001eƒ_tail\"]) {\n        root[\"\u001eƒ_tail\"] = prev;\n    }\n};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var Subscriber = __webpack_require__(13);\nvar Subscription = __webpack_require__(14);\nvar $$observable = __webpack_require__(94).default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function () {\n    return this;\n};\n\nSource.prototype.operator = function (destination) {\n    return this.subscribe(destination);\n};\n\n// Unused\n// Source.prototype.lift = function(operator, source) {\n//     source = new Source(source || this);\n//     source.operator = operator;\n//     source._promise = this._promise;\n//     return source;\n// }\n\nSource.prototype.subscribe = function (destination, x, y) {\n    return new Subscription([this.operator.call(this.source, !(destination instanceof Subscriber) ? new Subscriber(destination, x, y) : destination)]);\n};\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function (resolve, reject) {\n            var values = [],\n                rejected = false;\n            source.subscribe({\n                next: function (value) {\n                    values[values.length] = value;\n                },\n                error: function (errors) {\n                    (rejected = true) && reject(errors);\n                },\n                complete: function () {\n                    !rejected && resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\nvar empty = {\n    dispose: function () {},\n    unsubscribe: function () {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && 'json' in envelope;\n};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));\n};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\nmodule.exports = Date.now;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\nmodule.exports = 1;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/collapse\");\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Model = __webpack_require__(57);\nvar FalcorJSON = __webpack_require__(2);\n\nfunction falcor(opts) {\n    if (!(this instanceof Model)) {\n        return new Model(opts);\n    }\n    Model.call(this, opts);\n}\n\nfalcor.prototype = Object.create(Model.prototype);\n\nfalcor['Model'] = Model;\nfalcor['FalcorJSON'] = FalcorJSON;\nfalcor['toProps'] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Call = __webpack_require__(85);\nvar ModelRoot = __webpack_require__(59);\nvar FalcorJSON = __webpack_require__(2);\nvar ModelDataSourceAdapter = __webpack_require__(58);\nvar TimeoutScheduler = __webpack_require__(89);\nvar ImmediateScheduler = __webpack_require__(50);\nvar collapse = __webpack_require__(55);\n\nvar getSize = __webpack_require__(8);\nvar isObject = __webpack_require__(5);\nvar isJSONEnvelope = __webpack_require__(51);\nvar getCachePosition = __webpack_require__(9);\nvar isJSONGraphEnvelope = __webpack_require__(52);\n\nvar setCache = __webpack_require__(18);\nvar setJSONGraphs = __webpack_require__(17);\n\nvar getJSON = __webpack_require__(21);\nvar getCache = __webpack_require__(69);\nvar getJSONGraph = __webpack_require__(22);\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n/**\n* This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n* @callback Model~errorSelector\n* @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n* @returns {Object} the JSONGraph Error object to store in the Model cache.\n*/\n\n/**\n* This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n* @callback Model~comparator\n* @param {Object} existingValue - the current value in the Model cache.\n* @param {Object} newValue - the value about to be set into the Model cache.\n* @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n*/\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._treatErrorsAsValues = true;\n        this._seed = {};\n        this._seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get() {\n    var seed = this._seed;\n    if (!seed) {\n        seed = {};\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    return new Call('get', this, args)._toJSON(seed, []);\n};\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set() {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n    }\n\n    return new Call('set', this, args)._toJSON(seed, []);\n};\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n    }\n\n    return new Call('get', this, args)._toJSON(null, []);\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call() {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n    }\n\n    return new Call('call', this, args)._toJSON(seed, []);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n    }\n\n    return new Call('invalidate', this, args)._toJSON(null, null).then();\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.deref = __webpack_require__(78);\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = __webpack_require__(77);\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return new Call('get', this, [path])._toJSON({}, []).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : { path: path, value: value };\n    return new Call('set', this, [value])._toJSON({}, []).lift(function (subscriber) {\n        return this.subscribe({\n            onNext: function (data) {\n                var depth = -1;\n                var x = data.json;\n                var length = path.length;\n                while (x && !x.$type && ++depth < length) {\n                    x = x[path[depth]];\n                }\n                subscriber.onNext(x);\n            },\n            onError: subscriber.onError.bind(subscriber),\n            onCompleted: subscriber.onCompleted.bind(subscriber)\n        });\n    });\n};\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n\n    var modelRoot = this._root;\n    var cache = modelRoot.cache;\n\n    if (cacheOrJSONGraphEnvelope !== cache) {\n\n        var options = {\n            _path: [],\n            _boxed: false,\n            _root: modelRoot,\n            _materialized: false,\n            _treatErrorsAsValues: false\n        };\n\n        modelRoot.cache = this._node = {};\n\n        if (typeof cache !== 'undefined') {\n            modelRoot.expired = [];\n            modelRoot[\"\u001eƒ_head\"] = undefined;\n            modelRoot[\"\u001eƒ_tail\"] = undefined;\n            if (this._recycleJSON) {\n                this._seed = {};\n                this._seed.__proto__ = FalcorJSON.prototype;\n            }\n        }\n\n        var results, rootOnChangeHandler;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setJSONGraphs(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [{ json: cacheOrJSONGraphEnvelope }]);\n        }\n\n        if (results) {\n            // performs promotion without producing output.\n            if (results[0].length) {\n                getJSON(options, results[0], null, false, false);\n            }\n            if (results[2] && (rootOnChangeHandler = modelRoot.onChange)) {\n                rootOnChangeHandler();\n            }\n        }\n    } else if (typeof cache === 'undefined') {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache('genreLists[0...10][0...10].boxshot')));\n */\nModel.prototype.getCache = function _getCache() {\n\n    var paths = Array.prototype.slice.call(arguments, 0);\n\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    var env = getJSONGraph({\n        _path: [],\n        _root: this._root,\n        _boxed: this._boxed,\n        _materialized: this._materialized,\n        _treatErrorsAsValues: this._treatErrorsAsValues\n    }, paths, seed).data;\n\n    env.paths = collapse(paths);\n\n    return env;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path) {\n    path = path || [];\n    if (Array.isArray(path) === false) {\n        throw new Error('Model#getVersion must be called with an Array path.');\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === 'delete') {\n                delete clone[key];\n            } else if (key === '_path') {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty('_node')) {\n                    delete clone['_node'];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === 'number') {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: 'Steve',\n                surname: 'McGuire'\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints 'Steve'\nproxyModel.getValue('user.name').\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: 'delete'\n    });\n};\n\n/* implement inspect method for node's inspect utility */\nModel.prototype.inspect = function inspect() {\n    return '{ v: ' + this.getVersion() + ' p: [' + this._path.join(', ') + '] }';\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: 'ref',\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[\"\u001eƒ_abs_path\"] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = __webpack_require__(70);\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = __webpack_require__(27);\nModel.prototype._setPathMaps = __webpack_require__(18);\nModel.prototype._setJSONGs = __webpack_require__(17);\nModel.prototype._setCache = __webpack_require__(18);\n\nModel.prototype._invalidatePathValues = __webpack_require__(25);\nModel.prototype._invalidatePathMaps = __webpack_require__(41);\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\nfunction ModelDataSourceAdapter(model) {\n    this._model = model\n    // .boxValues()\n    ._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [path, args, suffixes].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar functionTypeof = 'function';\nvar Requests = __webpack_require__(86);\nvar getTimestamp = __webpack_require__(30);\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = -1;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nfunction defaultCompare(node, message) {\n    var cType = node && node.$type;\n    var mType = message && message.$type;\n    if (cType) {\n        // If the cache has a type, but the message is a primitive,\n        // the message might be the primitive response from the datasource.\n        // If so, return true, so we don't update the back-reference versions.\n        if (!mType) {\n            return node.value === message;\n        }\n        // If the message is older than the cache node, then isDistinct = false\n        else if (getTimestamp(message) < getTimestamp(node) === true) {\n                return true; // isDistinct = false\n            }\n        // Otherwise they are the same if all the following fields are the same.\n        return !(cType !== mType || node.value !== message.value || node.$expires !== message.$expires);\n    }\n    // If cache doesn't have a type but the message\n    // does, they must be different.\n    else if (mType) {\n            return false;\n        }\n    return node === message;\n}\n\nModelRoot.comparator = ModelRoot.prototype.comparator = defaultCompare;\n\nmodule.exports = ModelRoot;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(21);\nvar getJSONGraph = __webpack_require__(22);\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [path, args, suffixes, thisPaths]\n    };\n}\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n    json: __webpack_require__(34),\n    jsonGraph: __webpack_require__(37)\n};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(6);\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results, requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = __webpack_require__(36);\nvar FalcorJSON = __webpack_require__(2);\nvar isExpired = __webpack_require__(0);\nvar onValueType = __webpack_require__(15);\nvar originalOnMissing = __webpack_require__(24);\nvar getReferenceTarget = __webpack_require__(35);\nvar onMaterialize = __webpack_require__(68);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(11);\nvar getHashCode = __webpack_require__(100);\nvar flatBufferToPaths = __webpack_require__(99);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node || undefined !== (type = node.$type) || undefined === path) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json, path, depth, seed, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta,\n        f_old_keys,\n        f_new_keys,\n        f_code = '';\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        keys = path['$keys'],\n        nodeAbsPath,\n        jsonAbsPath,\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextJSON,\n        nextReferenceContainer,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\u001eƒ_abs_path\"];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[\"\u001eƒ_meta\"]) {\n\n        nodeAbsPath = node[\"\u001eƒ_abs_path\"];\n        jsonAbsPath = f_meta[\"abs_path\"];\n\n        if (!branchSelector && !(json instanceof FalcorJSON)) {\n            json.__proto__ = {};\n            json.__proto__[\"\u001eƒ_meta\"] = f_meta;\n            json.__proto__.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (!arrayEqual(nodeAbsPath, jsonAbsPath)) {\n            f_meta['$code'] = '';\n            f_meta[\"status\"] = 'pending';\n            f_meta[\"abs_path\"] = nodeAbsPath;\n            f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n            refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n            refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n            if (f_old_keys = f_meta[\"keys\"]) {\n                f_meta[\"keys\"] = Object.create(null);\n                for (nextKey in f_old_keys) {\n                    if (f_old_keys[nextKey]) {\n                        delete json[nextKey];\n                    }\n                }\n            }\n            arr[0] = json;\n            arr[1] = true;\n            return arr;\n        } else if (!(f_meta[\"version\"] !== node[\"\u001eƒ_version\"] || f_meta['$code'] !== path['$code'])) {\n            results.hasValue = true;\n            arr[0] = json;\n            arr[1] = false;\n            return arr;\n        }\n\n        f_old_keys = f_meta[\"keys\"];\n        f_meta[\"abs_path\"] = nodeAbsPath;\n        f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n        refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n    }\n\n    f_new_keys = Object.create(null);\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath,\n        nextPathKey,\n        hasMissingPath = false;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = '' + getHashCode('' + f_code + 'null');\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n                nextPathKey = nextKey;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                    nextPathKey = '[' + nextKey + '..' + rangeEnd + ']';\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextPath === undefined) {\n\n                arr = walkPathAndBuildOutput(root, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            } else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                arr = walkPathAndBuildOutput(root, next, nextJSON, nextPath, nextDepth, seed, results, requestedPath, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n                f_meta[\"abs_path\"] = node[\"\u001eƒ_abs_path\"];\n                refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n                json = {};\n                json[\"\u001eƒ_meta\"] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                } else {\n                    var tmp = json;\n                    json = {};\n                    json.__proto__ = tmp;\n                    tmp = undefined;\n                }\n            }\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && nextKey in f_old_keys) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        f_code = '' + getHashCode('' + f_code + (!hasMissingPath ? nextPathKey : '') + (nextPath ? nextPath['$code'] : ''));\n    }\n\n    if (f_meta) {\n        f_meta['$code'] = f_code;\n        f_meta[\"keys\"] = f_new_keys;\n        f_meta[\"status\"] = hasMissingPath && 'pending' || 'resolved';\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, json, branchSelector, boxValues, onMaterialize, modelRoot) {\n\n    if (reportMaterialized) {\n        return onMaterialize(json, path, depth, depth, branchSelector, boxValues, modelRoot, results, requestedPath, optimizedPath, optimizedLength, fromReference, reportMissing, onMissing);\n    }\n\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n\n    return paths.forEach(function (restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, false, json, branchSelector, boxValues, onMaterialize, modelRoot);\n    });\n}\n\nfunction arrayEqual(xs, ys) {\n    if (xs === ys) {\n        return true;\n    }\n    var len = xs.length;\n    if (len !== ys.length) {\n        return false;\n    }\n    while (~--len) {\n        if (xs[len] !== ys[len]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = __webpack_require__(36);\nvar onMissing = __webpack_require__(24);\nvar FalcorJSON = __webpack_require__(2);\nvar onValueType = __webpack_require__(15);\nvar isExpired = __webpack_require__(0);\nvar onMaterialize = __webpack_require__(38);\nvar getReferenceTarget = __webpack_require__(35);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(11);\nvar materializedAtom = __webpack_require__(20);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, referenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta;\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        nextJSON,\n        nextReferenceContainer,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath,\n        refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        arr[0] = json;\n        arr[1] = false;\n        return arr;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[\"\u001eƒ_abs_path\"];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[\"\u001eƒ_meta\"]) {\n        f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n        f_meta[\"abs_path\"] = node[\"\u001eƒ_abs_path\"];\n        refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    var hasMissingPath = false;\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                keyset = keysOrRanges[keysetIndex];\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextDepth === requestedLength) {\n\n                arr = walkPathAndBuildOutput(root, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    continue;\n                }\n            } else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                arr = walkPathAndBuildOutput(root, next, nextJSON, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, nextReferenceContainer, modelRoot, expired, expireImmediate, branchSelector, boxValues, materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame);\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[\"version\"] = node[\"\u001eƒ_version\"];\n                f_meta[\"abs_path\"] = node[\"\u001eƒ_abs_path\"];\n                refContainerRefPath && (f_meta[\"deref_to\"] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[\"deref_from\"] = refContainerAbsPath);\n                json = {};\n                json[\"\u001eƒ_meta\"] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                if (branchSelector) {\n                    json = branchSelector(json);\n                }\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    if (f_meta) {\n        f_meta[\"status\"] = hasMissingPath && 'pending' || 'resolved';\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar arr = new Array(2);\nvar clone = __webpack_require__(6);\nvar inlineValue = __webpack_require__(23);\nvar promote = __webpack_require__(12);\nvar isExpired = __webpack_require__(0);\nvar createHardlink = __webpack_require__(7);\nvar CircularReferenceError = __webpack_require__(46);\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key,\n        type,\n        depth = 0,\n        node = root,\n        path = ref.value,\n        copy = path,\n        length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[\"\u001eƒ_context\"])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                    throw new CircularReferenceError(path);\n                }\n                // If the node we land on isn't the existing ref context,\n                // create a hard-link between the reference and the node\n                // it points to.\n                else if (node !== context) {\n                        createHardlink(ref, node);\n                    }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === \"ref\") {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar typeofObject = 'object';\nvar clone = __webpack_require__(6);\nvar inlineValue = __webpack_require__(23);\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results, requestedPath, optimizedPath, optimizedLength, fromReference, boxValues, materialized) {\n\n    var value = node.value;\n\n    // boxValues always clones the node\n    if (boxValues || !(\n    /**\n     * JSON Graph should always clone:\n     * - refs\n     * - errors\n     * - atoms we didn't create\n     * - atoms we created to wrap Objects\n     **/\n    \"ref\" !== type && \"error\" !== type && node[\"\u001eƒ_wrapped_value\"] && typeofObject !== typeof value)) {\n        value = clone(node);\n    }\n\n    results.hasValue = true;\n    inlineValue(value, optimizedPath, optimizedLength, seed);\n    (seed.paths || (seed.paths = [])).push(requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n    );\n\n    return value;\n}\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar clone = __webpack_require__(6);\nvar onValue = __webpack_require__(66);\nvar inlineValue = __webpack_require__(23);\nvar isExpired = __webpack_require__(0);\nvar onValueType = __webpack_require__(15);\nvar onMaterialize = __webpack_require__(38);\nvar originalOnMissing = __webpack_require__(24);\nvar getReferenceTarget = __webpack_require__(65);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(11);\nvar materializedAtom = __webpack_require__(20);\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (type = node.$type) || depth === requestedLength) {\n        return onValueType(node, type, seed, path, depth, seed, results, requestedPath, requestedLength, optimizedPath, optimizedLength, fromReference, modelRoot, expired, expireImmediate, undefined, boxValues, materialized, hasDataSource, treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var next,\n        nextKey,\n        keyset,\n        keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd,\n        keysOrRanges,\n        keysetIndex = -1,\n        keysetLength = 0,\n        nextOptimizedLength,\n        nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n                // If we've already encountered an Array keyset, throw an error.\n                if (keysOrRanges !== undefined) {\n                    throw new InvalidKeySetError(path, keysOrRanges);\n                }\n                keysetIndex = 0;\n                keysOrRanges = keyset;\n                keysetLength = keyset.length;\n                // If an Array of keys or ranges is empty, terminate the graph walk\n                // and return the json constructed so far. An example of an empty\n                // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n                // without building missing paths.\n                if (0 === keysetLength) {\n                    break iteratingKeyset;\n                }\n                keyset = keysOrRanges[keysetIndex];\n                // Assign `keyset` to the first value in the Keyset. Re-entering the\n                // outer loop mimics a singly-recursive function call.\n                continue iteratingKeyset;\n            }\n            // If the Keyset isn't a primitive or Array, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if ('number' !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next && nextDepth < requestedLength &&\n            // If the reference is expired, it will be invalidated and\n            // reported as missing in the next call to walkPath below.\n            next.$type === \"ref\" && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(root, next, modelRoot, seed, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(root, next, path, nextDepth, seed, results, requestedPath, requestedLength, nextOptimizedPath, nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate, boxValues, materialized, hasDataSource, treatErrorsAsValues);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, reportMaterialized, seed, branchSelector, boxValues, onMaterialize, modelRoot) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push((isLeaf = 0 === requestedLength - depth) &&\n        // depth + 1 if fromReference === true\n        requestedPath.slice(0, depth + !!fromReference) || requestedPath.slice(0, depth).concat(path.slice(depth, requestedLength + !!fromReference)));\n\n        json = inlineValue(isLeaf && clone(materializedAtom) || undefined, optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results, requestedPath, requestedLength, fromReference, optimizedPath, optimizedLength, reportMissing, !isLeaf && reportMaterialized, json, branchSelector, true, onMaterialize, modelRoot);\n}\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = __webpack_require__(6);\nvar onValueType = __webpack_require__(15);\nvar FalcorJSON = __webpack_require__(2);\nvar NullInPathError = __webpack_require__(3);\nvar InvalidKeySetError = __webpack_require__(11);\nvar materializedAtom = __webpack_require__(20);\n\nmodule.exports = onMaterializeFlatBuffer;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterializeFlatBuffer(json, path, depth, length, branchSelector, boxValues, modelRoot, results, requestedPath, optimizedPath, optimizedLength, fromReference, reportMissing, onMissing) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === path) {\n        onValueType(undefined, undefined, json, path, depth, undefined, results, requestedPath, depth, optimizedPath, optimizedLength, fromReference, modelRoot, undefined, false, branchSelector, boxValues, false, reportMissing, false, undefined, onMissing, undefined);\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta, f_old_keys, f_new_keys;\n\n    var nextKey,\n        keyset,\n        keyIsRange,\n        keys = path['$keys'],\n        nextDepth = depth + 1,\n        rangeEnd,\n        nextOptimizedLength = optimizedLength + 1;\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[\"\u001eƒ_meta\"])) {\n        json[\"\u001eƒ_meta\"] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n    } else {\n        f_old_keys = f_meta[\"keys\"];\n        f_meta['$code'] = '';\n        f_meta[\"status\"] = 'resolved';\n        f_meta[\"version\"] = modelRoot.version;\n        f_meta[\"abs_path\"] = optimizedPath.slice(0, optimizedLength);\n    }\n\n    f_new_keys = Object.create(null);\n\n    var nextPath;\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    iteratingKeyset: while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n                nextKey = keyset;\n                rangeEnd = undefined;\n                keyIsRange = false;\n            }\n            // If the Keyset isn't null or primitive, then it must be a Range.\n            else {\n                    rangeEnd = keyset.to;\n                    nextKey = keyset.from || 0;\n                    if (typeofNumber !== typeof rangeEnd) {\n                        rangeEnd = nextKey + (keyset.length || 0) - 1;\n                    }\n                    if (rangeEnd - nextKey < 0) {\n                        break iteratingKeyset;\n                    }\n                    keyIsRange = true;\n                }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && nextKey in f_old_keys) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // insert the materialized branch\n            json[nextKey] = onMaterializeFlatBuffer(json[nextKey], nextPath, nextDepth, nextDepth, branchSelector, boxValues, modelRoot, results, requestedPath, optimizedPath, nextOptimizedLength, fromReference, reportMissing, onMissing);\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n    }\n\n    f_meta[\"keys\"] = f_new_keys;\n    if (f_old_keys) {\n        for (nextKey in f_old_keys) {\n            if (f_old_keys[nextKey]) {\n                delete json[nextKey];\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isInternalKey = __webpack_require__(19);\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (key === '$type' || !isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    // only copy objects\n    if (!node || typeof node !== 'object') {\n        return;\n    }\n\n    Object.keys(node).filter(function (key) {\n        // Its not an internal key and the node has a value.  In the cache\n        // there are 3 possibilities for values.\n        // 1: A branch node.\n        // 2: A $type-value node.\n        // 3: undefined\n        // We will strip out 3\n        return (key === '$type' || !isInternalKey(key)) && node[key] !== undefined;\n    }).forEach(function (key) {\n        var cacheNext = node[key];\n        var outNext = out[key];\n\n        if (!outNext) {\n            outNext = out[key] = {};\n        }\n\n        // Paste the node into the out cache.\n        if (cacheNext.$type) {\n            var isObject = cacheNext.value && typeof cacheNext.value === 'object';\n            var isUserCreatedcacheNext = !cacheNext[\"\u001eƒ_wrapped_value\"];\n            var value;\n            if (isObject || isUserCreatedcacheNext) {\n                value = cloneBoxedValue(cacheNext);\n            } else {\n                value = cacheNext.value;\n            }\n\n            out[key] = value;\n            return;\n        }\n\n        _copyCache(cacheNext, outNext, key);\n    });\n}\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getBoundCacheNode = __webpack_require__(16);\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[\"\u001eƒ_version\"];\n    return version == null ? -1 : version;\n};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar groupCacheArguments = __webpack_require__(39);\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n    invalidatePathMaps: __webpack_require__(41),\n    invalidatePathValues: __webpack_require__(25)\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    if (invalidateArgumentGroups(model, groupCacheArguments(args), expireImmediate)) {\n        var rootChangeHandler = model._root.onChange;\n        rootChangeHandler && rootChangeHandler();\n    }\n    return {};\n}\n\nfunction invalidateArgumentGroups(model, xs, expireImmediate) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            if (inputType === 'PathValues') {\n                groupedArgs = groupedArgs.map(pluckPaths);\n            }\n            var operation = module.exports['invalidate' + inputType];\n            if (operation(model, groupedArgs, expireImmediate)) {\n                changed = true;\n            }\n        }\n    }\n    return changed;\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar wrapNode = __webpack_require__(45);\nvar isExpired = __webpack_require__(0);\nvar insertNode = __webpack_require__(40);\nvar expireNode = __webpack_require__(1);\nvar replaceNode = __webpack_require__(44);\nvar getSize = __webpack_require__(8);\nvar reconstructPath = __webpack_require__(43);\nvar getTimestamp = __webpack_require__(30);\nvar updateNodeAncestors = __webpack_require__(10);\n\nmodule.exports = function mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n\n    var cType, mType, cIsObject, mIsObject, cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // The message and cache are both undefined, return undefined.\n        if (message === undefined) {\n            return message;\n        }\n        // There should not be undefined values. Those should always be\n        // wrapped in an $atom\n        else if (message === null) {\n                node = wrapNode(message, undefined, message);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, undefined, optimizedPath);\n                return node;\n            }\n            // Is the cache node a branch? If so, return the cache branch.\n            else if ((cIsObject = !(!node || typeof node !== 'object')) && (cType = node.$type) === undefined) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node[\"\u001eƒ_parent\"] === undefined) {\n                        insertNode(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n    } else if (cIsObject = !(!node || typeof node !== 'object')) {\n        cType = node.$type;\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== \"ref\") {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || mIsObject && !mType) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n            // If the cache is a reference, but the message is empty,\n            // leave the cache alone...\n            if (message == null) {\n                // ...unless the cache is an expired reference. In that case, expire\n                // the cache node and return undefined.\n                if (isExpired(node, expireImmediate)) {\n                    expireNode(node, expired, lru);\n                    return void 0;\n                }\n                return node;\n            }\n            mIsObject = !(!message || typeof message !== 'object');\n            if (mIsObject) {\n                mType = message.$type;\n                // If the cache and the message are both references,\n                // check if we need to replace the cache reference.\n                if (mType === \"ref\") {\n                    if (node === message) {\n                        // If the cache and message are the same reference,\n                        // we performed a whole-branch merge of one of the\n                        // grandparents. If we've previously graphed this\n                        // reference, break early. Otherwise, continue to\n                        // leaf insertion below.\n                        if (node[\"\u001eƒ_parent\"] != null) {\n                            return node;\n                        }\n                    } else {\n\n                        cTimestamp = node.$timestamp;\n                        mTimestamp = message.$timestamp;\n\n                        // - If either the cache or message reference is expired,\n                        //   replace the cache reference with the message.\n                        // - If neither of the references are expired, compare their\n                        //   timestamps. If either of them don't have a timestamp,\n                        //   or the message's timestamp is newer, replace the cache\n                        //   reference with the message reference.\n                        // - If the message reference is older than the cache\n                        //   reference, short-circuit.\n                        if (!isExpired(node, expireImmediate) && !isExpired(message, expireImmediate) && mTimestamp < cTimestamp) {\n                            return void 0;\n                        }\n                    }\n                }\n            }\n        }\n\n    // If the cache is a leaf but the message is a branch,\n    // merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, version), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n\n            if (mType === \"error\" && errorSelector) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            // If the cache and the message are the same value, we branch-merged one\n            // of the message's ancestors. If this is the first time we've seen this\n            // leaf, give the message a $size and $type, attach its graph pointers,\n            // and update the cache sizes and versions.\n            if (mType && node === message) {\n                if (!node[\"\u001eƒ_parent\"]) {\n                    node = wrapNode(node, cType, node.value);\n                    parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                    node = insertNode(node, parent, key, version, optimizedPath);\n                }\n            }\n            // If the cache and message are different, the cache value is expired,\n            // or the message is a primitive, replace the cache with the message value.\n            // If the message is a sentinel, clone and maintain its type.\n            // If the message is a primitive value, wrap it in an atom.\n            else {\n                    var isDistinct = true;\n                    // If both the cache and message are primitives, we branch-merged\n                    // one of the message's ancestors. Insert the value into the cache.\n                    if (!cType && !mType) {\n                        isDistinct = true;\n                    }\n                    // If the cache is a branch, but the message is a leaf, replace the\n                    // cache branch with the message leaf.\n                    else if (!cIsObject || !isExpired(node, expireImmediate)) {\n                            // Compare the current cache value with the new value. If either of\n                            // them don't have a timestamp, or the message's timestamp is newer,\n                            // replace the cache value with the message value. If a comparator\n                            // is specified, the comparator takes precedence over timestamps.\n                            if (comparator) {\n                                isDistinct = !(comparator.length < 3 ? comparator(node, message) : comparator(node, message, optimizedPath.slice(0, optimizedPath.index)));\n                            } else {\n                                // Comparing either Number or undefined to undefined always results in false.\n                                isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                            }\n                        }\n                    if (isDistinct) {\n                        sizeOffset = getSize(node) - getSize(message = wrapNode(message, mType, mType ? message.value : message));\n                        node = replaceNode(node, message, parent, key, lru, version);\n                        parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                    }\n                }\n\n            // Promote the message edge in the LRU.\n            if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n                expireNode(node, expired, lru);\n            }\n        } else if (node == null) {\n            node = insertNode(message, parent, key, undefined, optimizedPath);\n        }\n\n    return node;\n};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar getJSON = __webpack_require__(21);\nvar getJSONGraph = __webpack_require__(22);\nvar groupCacheArguments = __webpack_require__(39);\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: __webpack_require__(18),\n    setPathValues: __webpack_require__(27),\n    setJSONGraphs: __webpack_require__(17)\n};\n\nfunction json(model, _args, data, progressive, expireImmediate) {\n\n    var set,\n        get,\n        jsong,\n        changed,\n        relative,\n        optimized,\n        missing,\n        fragments,\n        requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length) {\n\n        if (!(changed = set.changed) || progressive) {\n            get = getJSON(model, relative, data, progressive, expireImmediate);\n        }\n\n        if (changed) {\n\n            jsong = getJSONGraph({\n                _root: model._root,\n                _boxed: model._boxed, _materialized: true,\n                _treatErrorsAsValues: model._treatErrorsAsValues\n            }, set.optimized, {}, progressive, expireImmediate);\n\n            fragments = jsong.data;\n            missing = fragments.paths;\n            requested = jsong.requested;\n\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler();\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: get && get.error,\n        errors: get && get.errors,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive, expireImmediate) {\n\n    var set,\n        jsong,\n        changed,\n        relative,\n        optimized,\n        missing,\n        fragments,\n        requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length && (progressive || (changed = set.changed))) {\n\n        jsong = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed, _materialized: true,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, set.optimized, data, progressive, expireImmediate);\n\n        fragments = jsong.data;\n        missing = fragments.paths;\n        requested = jsong.requested;\n\n        if (changed) {\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler();\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: jsong && jsong.error,\n        hasValue: jsong && jsong.hasValue\n    };\n}\n\nfunction setGroupsIntoCache(model, xs, expireImmediate) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n\n    expireImmediate = expireImmediate && !Boolean(model._source);\n    var comparator = Boolean(model._source) ? null : modelRoot.comparator;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports['set' + inputType];\n            var results = operation(model, groupedArgs, errorSelector, comparator, expireImmediate);\n            changed = changed || results[2];\n            optimizedPaths.push.apply(optimizedPaths, results[1]);\n            if (inputType === 'PathValues') {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === 'JSONGraphs') {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, results[0]);\n            }\n        }\n    }\n\n    return {\n        changed: changed,\n        requested: requestedPaths,\n        optimized: optimizedPaths\n    };\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\nfunction arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n}\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[\"\u001eƒ_refs_length\"] || 0,\n        destNodeRefsLength = destNode[\"\u001eƒ_refs_length\"] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[\"\u001eƒ_ref\" + i];\n        if (ref !== undefined) {\n            ref[\"\u001eƒ_context\"] = destNode;\n            destNode[\"\u001eƒ_ref\" + (destNodeRefsLength + i)] = ref;\n            fromNode[\"\u001eƒ_ref\" + i] = undefined;\n        }\n    }\n    destNode[\"\u001eƒ_refs_length\"] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[\"\u001eƒ_refs_length\"] = undefined;\n    return destNode;\n};\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function unlinkBackReferences(node) {\n    var i = -1,\n        n = node[\"\u001eƒ_refs_length\"] || 0;\n    while (++i < n) {\n        var ref = node[\"\u001eƒ_ref\" + i];\n        if (ref != null) {\n            ref[\"\u001eƒ_context\"] = ref[\"\u001eƒ_ref_index\"] = node[\"\u001eƒ_ref\" + i] = void 0;\n        }\n    }\n    node[\"\u001eƒ_refs_length\"] = void 0;\n    return node;\n};\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = function unlinkForwardReference(reference) {\n    var destination = reference[\"\u001eƒ_context\"];\n    if (destination) {\n        var i = (reference[\"\u001eƒ_ref_index\"] || 0) - 1,\n            n = (destination[\"\u001eƒ_refs_length\"] || 0) - 1;\n        while (++i <= n) {\n            destination[\"\u001eƒ_ref\" + i] = destination[\"\u001eƒ_ref\" + (i + 1)];\n        }\n        destination[\"\u001eƒ_refs_length\"] = n;\n        reference[\"\u001eƒ_ref_index\"] = reference[\"\u001eƒ_context\"] = destination = void 0;\n    }\n    return reference;\n};\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[\"\u001eƒ_parent\"] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[\"\u001eƒ_invalidated\"]) {\n        return false;\n    }\n\n    return true;\n}\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar CONTAINER_DOES_NOT_EXIST = 'e';\nvar FalcorJSON = __webpack_require__(2);\nvar getCachePosition = __webpack_require__(9);\nvar InvalidDerefInputError = __webpack_require__(80);\n\nmodule.exports = function deref(json) {\n\n    var seed, f_meta;\n\n    if (!json || 'object' !== typeof json || !(f_meta = json[\"\u001eƒ_meta\"]) || 'object' !== typeof f_meta) {\n        return null;\n    }\n\n    var cacheRoot = this._root.cache;\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = f_meta[\"abs_path\"];\n    var referenceContainer, currentRefPath, i, len;\n\n    if (!absolutePath) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: undefined,\n            _seed: seed\n        });\n    } else if (absolutePath.length === 0) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: cacheRoot,\n            _path: absolutePath,\n            _referenceContainer: true,\n            _seed: seed\n        });\n    }\n\n    var originalRefPath = f_meta[\"deref_to\"];\n    var originalAbsPath = f_meta[\"deref_from\"];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === \"ref\") {\n            validContainer = true;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n            for (i = 0; i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    cacheNode = undefined;\n                    validContainer = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n            referenceContainer = true;\n        }\n\n    if (recycleJSON) {\n        seed = { json: json };\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    return this._clone({\n        _seed: seed,\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer\n    });\n};\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'It is not legal to use the JSON Graph ' + 'format from a bound Model. JSON Graph format' + ' can only be used from a root model.';\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nmodule.exports = createErrorClass('BoundJSONGraphModelError', function () {\n    this.message = MESSAGE;\n});\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'Deref can only be used with a non-primitive object from get, set, or call.';\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidDerefInputError', function () {\n  this.message = MESSAGE;\n});\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\nvar MESSAGE = 'The boundPath of the model is not valid since a value or error was found before the path end.';\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidModelError', function (boundPath, shortedPath) {\n  this.message = MESSAGE;\n  this.boundPath = boundPath;\n  this.shortedPath = shortedPath;\n});\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar createErrorClass = __webpack_require__(4);\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nmodule.exports = createErrorClass('MaxRetryExceededError', function (maxRetryCount, absolute, relative, optimized) {\n    this.message = '' + 'Exceeded the max retry count (' + maxRetryCount + ') for these paths: \\n' + (absolute && 'absolute: [\\n\\t' + printPaths(absolute) + '\\n]\\n' || '') + (relative && 'relative: [\\n\\t' + printPaths(relative) + '\\n]\\n' || '') + (optimized && 'optimized: [\\n\\t' + printPaths(optimized) + '\\n]\\n' || '');\n});\n\nfunction printPaths(paths) {\n    return paths.map(function (path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n/***/ },\n/* 83 */\n/***/ function(module, exports) {\n\nmodule.exports = String.fromCharCode(30) + 'ƒ_';\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar updateNodeAncestors = __webpack_require__(10);\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== 'number') {\n        ratio = 0.75;\n    }\n\n    var node,\n        size,\n        targetSize = max * ratio;\n\n    while (node = expired.pop()) {\n        total -= size = node.$size || 0;\n        updateNodeAncestors(node, size, lru, version);\n    }\n\n    if (total >= max) {\n        var prev = lru[\"\u001eƒ_tail\"];\n        while (total >= targetSize && (node = prev)) {\n            prev = prev[\"\u001eƒ_prev\"];\n            total -= size = node.$size || 0;\n            updateNodeAncestors(node, size, lru, version);\n        }\n\n        lru[\"\u001eƒ_tail\"] = node;\n        if (node == null) {\n            lru[\"\u001eƒ_head\"] = undefined;\n        } else {\n            node[\"\u001eƒ_next\"] = undefined;\n        }\n    }\n};\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(49);\nvar Subscriber = __webpack_require__(13);\nvar lruCollect = __webpack_require__(84);\nvar FalcorJSON = __webpack_require__(2);\nvar collapse = __webpack_require__(55);\nvar InvalidSourceError = __webpack_require__(47);\nvar MaxRetryExceededError = __webpack_require__(82);\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function (operator, source) {\n    source = new Call(source || this);\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    source.operator = operator;\n    operator.data = operator.data || this.operator.data;\n    operator.errors = operator.errors || this.operator.errors;\n    operator.operation = operator.operation || this.operator.operation;\n    operator.progressive = operator.progressive || this.operator.progressive;\n    operator.maxRetryCount = operator.maxRetryCount || this.operator.maxRetryCount;\n    return source;\n};\n\nCall.prototype.operator = function (subscriber) {\n    return this._subscribe(subscriber);\n};\n\nCall.prototype._subscribe = function (subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n};\n\nCall.prototype._toJSON = function (data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(data, errors || this.operator.errors, 'json', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype._toJSONG = function (data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(data, errors || this.operator.errors, 'jsonGraph', this.operator.progressive, this.operator.maxRetryCount), this.source);\n};\n\nCall.prototype.retry = function (maxRetryCount) {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, this.operator.progresive, maxRetryCount), this.source);\n};\n\nCall.prototype.progressively = function () {\n    return this.lift(new CallOperator(this.operator.data, this.operator.errors, this.operator.operation, true, this.operator.maxRetryCount), this.source);\n};\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function (source, destination) {\n    return source.subscribe(new CallSubscriber(destination, this.data, this.errors, this.operation, this.progressive));\n};\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.hasValue = false;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: __webpack_require__(61),\n    set: __webpack_require__(73),\n    call: __webpack_require__(60),\n    invalidate: __webpack_require__(71)\n};\n\nCallSubscriber.prototype.next = CallSubscriber.prototype.onNext = function (seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    } else if (!this.destination) {\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n    var seedIsImmutable = progressive && data;\n\n    if (model._recycleJSON && this.type === 'get') {\n        seedIsImmutable = false;\n    }\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type][operation](model, args, data, progressive || !model._source, this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            return tryOnError(this, results.error);\n        }\n\n        errors && results.errors && errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n};\n\nCallSubscriber.prototype.error = CallSubscriber.prototype.onError = function (error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n};\n\nCallSubscriber.prototype.complete = CallSubscriber.prototype.onCompleted = function (error) {\n\n    if (!this.destination) {\n        return;\n    }\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && ((data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return tryOnError(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return tryOnError(this, new MaxRetryExceededError(this.retryCount, this.requested, this.relative, this.missing));\n    }\n\n    this.request = this.model._root.requests[this.type](this.model, this.missing, this.relative, this.fragments).subscribe(this);\n};\n\nCallSubscriber.prototype.dispose = CallSubscriber.prototype.unsubscribe = function () {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 && version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot, modelRoot.expired, cache.$size || 0, modelRoot.maxSize, modelRoot.collectRatio, modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n};\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch (e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction tryOnError(self, error) {\n    try {\n        throw error;\n    } catch (err) {\n        Subscriber.prototype.onError.call(self, err);\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue,\n        nodeValue,\n        key,\n        keys = Object.keys(node),\n        index = -1,\n        length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === \"\u001eƒ_meta\") {\n            dest[\"\u001eƒ_meta\"] = node[\"\u001eƒ_meta\"];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (!nodeValue || typeof nodeValue !== 'object') {\n                    if (destValue === undefined) {\n                        dest[key] = nodeValue;\n                    }\n                } else if (destValue === undefined) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Source = __webpack_require__(49);\nvar Request = __webpack_require__(87);\nvar Subscriber = __webpack_require__(13);\nvar Subscription = __webpack_require__(14);\nvar ImmediateScheduler = __webpack_require__(50);\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = env.jsonGraph;\n        request.requested.push(requested);\n        request.optimized.push(optimized);\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, callArgs) {\n    var queue = this;\n    return new Source(function (destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = callArgs;\n        request.boundPath = model._path;\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(this, model._source, model._scheduler, requested, optimized);\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function (destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] = new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n};\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar Subject = __webpack_require__(88);\nvar Subscriber = __webpack_require__(13);\nvar Subscription = __webpack_require__(14);\nvar InvalidSourceError = __webpack_require__(47);\n\nvar setJSONGraphs = __webpack_require__(17);\nvar setPathValues = __webpack_require__(27);\nvar invalidatePaths = __webpack_require__(25);\n\nvar toPaths = __webpack_require__(105);\nvar toCollapseMap = __webpack_require__(102);\nvar toCollapseTrees = __webpack_require__(103);\nvar hasIntersection = __webpack_require__(101);\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.tree = {};\n    this.paths = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next = Request.prototype.onNext = function (env) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    var changed = false;\n    var jsonGraph = env.jsonGraph;\n    var boundPath = this.boundPath;\n    var modelRoot = queue.modelRoot;\n    var invalidated = env.invalidated;\n    var paths = env.paths || this.paths;\n    var requested = this.requested.slice(0);\n    var rootChangeHandler = modelRoot.onChange;\n\n    // Run invalidations first.\n    if (invalidated && invalidated.length) {\n        changed = invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n    }\n\n    if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n        var results = setJSONGraphs({ _root: modelRoot }, [{ paths: paths, jsonGraph: jsonGraph }], modelRoot.errorSelector, modelRoot.comparator, false);\n        paths = results[0];\n        changed = changed || results[2];\n    }\n\n    if (changed && rootChangeHandler) {\n        rootChangeHandler();\n    }\n\n    this.observers.slice(0).forEach(function (observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] || filterPathsBoundTo(boundPath, paths)\n        });\n    });\n};\n\nRequest.prototype.error = Request.prototype.onError = function (error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    error = error || {};\n\n    // Converts errors to object we can insert into the cache.\n    error = !(error instanceof Error) ?\n    // if it's $type error, use it raw\n    error.$type === \"error\" && error ||\n    // Otherwise make it an error\n    { $type: \"error\", value: error } :\n    // If it's instanceof Error, pluck error.message\n    { $type: \"error\", value: { message: error.message } };\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(this.requested.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {}))).map(function (path) {\n        return { path: path, value: error };\n    });\n\n    if (errorPathValues.length) {\n        setPathValues({ _root: modelRoot, _path: [] }, errorPathValues, modelRoot.errorSelector, modelRoot.comparator, false);\n    }\n\n    Subject.prototype.onError.call(this, error);\n};\n\nRequest.prototype.complete = Request.prototype.onCompleted = function () {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n};\n\nRequest.prototype.remove = function (subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n};\n\nRequest.prototype.dispose = Request.prototype.unsubscribe = function () {\n    this.tree = {};\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.boundPath = null;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n};\n\nRequest.prototype.connect = function () {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n};\n\nRequest.prototype.batch = function (requested, optimized, requestedComplements, optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.tree, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            return this;\n        }\n        return null;\n    }\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    return this;\n};\n\nfunction flush() {\n\n    this.active = true;\n\n    var obs,\n        paths = this.paths = toPaths(this.tree = toCollapseTrees(this.optimized.reduce(function (collapseMap, paths) {\n        return toCollapseMap(paths, collapseMap);\n    }, {})));\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = {};\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\n\nfunction findIntersections(tree, requested, optimized, requestedComplements, optimizedComplements, requestedIntersection, optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = -1;\n    var intersectionIndex = -1;\n    var optTotal = optimized.length;\n    var reqTotal = requested.length - 1;\n\n    while (++index < optTotal) {\n        var path = optimized[index];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n        if (subTree && hasIntersection(subTree, path, 0, pathLen)) {\n            optimizedIntersection[++intersectionIndex] = path;\n            requestedIntersection[intersectionIndex] = requested[index < reqTotal ? index : reqTotal];\n        } else {\n            optimizedComplements[++complementIndex] = path;\n            requestedComplements[complementIndex] = requested[index < reqTotal ? index : reqTotal];\n        }\n    }\n\n    return ~intersectionIndex;\n}\n\nfunction filterPathsBoundTo(boundPath, paths) {\n\n    var boundLength;\n\n    if (!boundPath || (boundLength = boundPath.length) === 0) {\n        return paths;\n    }\n\n    var filtered = [],\n        filteredIndex = -1,\n        keyIndex;\n    var path,\n        pathsIndex = -1,\n        pathsCount = paths.length;\n\n    outer: while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        if (path.length > boundLength) {\n            keyIndex = 0;\n            do {\n                if (path[keyIndex] !== boundPath[keyIndex]) {\n                    continue outer;\n                }\n            } while (++keyIndex < boundLength);\n            filtered[++filteredIndex] = path.slice(boundLength);\n        }\n    }\n\n    return filtered;\n}\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscriber = __webpack_require__(13);\nvar Subscription = __webpack_require__(14);\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\n// Unused\n// Subject.prototype.onNext = function(value) {\n//     this.observers.slice(0).forEach(function(observer) {\n//         observer.onNext(value);\n//     });\n// }\n\nSubject.prototype.onError = function (error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onError(error);\n    });\n};\n\nSubject.prototype.onCompleted = function () {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function (observer) {\n        observer.onCompleted();\n    });\n};\n\nSubject.prototype.subscribe = function (subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n};\n\nSubject.prototype.dispose = Subject.prototype.unsubscribe = function () {\n    this.observers = [];\n};\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose = TimerDisposable.prototype.unsubscribe = function () {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isInternal = __webpack_require__(29);\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (isInternal(key)) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return 'branch';\n    }\n    return type;\n};\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isArray = Array.isArray;\nvar isObject = __webpack_require__(5);\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (isArray(pathValue.path) || typeof pathValue.path === 'string');\n};\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(95);\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = __webpack_require__(96);\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32), __webpack_require__(97)(module)))\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/computeFlatBufferHash\");\n\n/***/ },\n/* 99 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/flatBufferToPaths\");\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/getHashCode\");\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/hasIntersection\");\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/toCollapseMap\");\n\n/***/ },\n/* 103 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/toCollapseTrees\");\n\n/***/ },\n/* 104 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/toFlatBuffer\");\n\n/***/ },\n/* 105 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"@graphistry/falcor-path-utils/lib/toPaths\");\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(56);\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// falcor.node.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 106);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 80d04bf5c7888396eb8e","var now = require('../support/now');\nvar $now = require('../values/expires-now');\nvar $never = require('../values/expires-never');\n\nmodule.exports = function isExpired(node, expireImmediate) {\n    var exp = node.$expires;\n    if (exp === undefined || exp === null || exp === $never) {\n        return false;\n    } else if (exp === $now) {\n        return expireImmediate;\n    }\n    return exp < now();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/isExpired.js","var splice = require('./../lru/splice');\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[f_invalidated]) {\n        node[f_invalidated] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/expireNode.js","function FalcorJSON(f_meta) {\n    if (!f_meta) {\n        this[f_meta_data] = {};\n    } else if (!(this[f_meta_data] = f_meta[f_meta_data])) {\n        this[f_meta_data] = f_meta;\n    }\n}\n\nvar protoBlacklist = {\n    length: true,\n    toString: true,\n    constructor: true,\n    toLocaleString: true\n};\n\nvar protoDescriptors = {\n    toJSON: { enumerable: false, value: toJSON },\n    toProps: { enumerable: false, value: toProps },\n    toString: { enumerable: false, value: toString },\n    toLocaleString: { enumerable: false, value: toString },\n    $__hash: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta['$code'] || '';\n        }\n    },\n    $__path: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta[f_meta_abs_path] || [];\n        }\n    },\n    $__status: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta[f_meta_status] || 'resolved';\n        }\n    },\n    $__version: {\n        enumerable: false,\n        get: function() {\n            var f_meta = this[f_meta_data];\n            return f_meta && f_meta[f_meta_version] || 0;\n        }\n    }\n};\n\nObject.defineProperties(FalcorJSON.prototype, Object\n    .getOwnPropertyNames(Array.prototype)\n    .reduce(function (descriptors, name) {\n        if (!protoBlacklist.hasOwnProperty(name)) {\n            var fn = Array.prototype[name];\n            if (typeof fn === 'function') {\n                descriptors[name] = {\n                    value: bindArrayMethod(name, fn),\n                    writable: true, enumerable: false\n                };\n            }\n        }\n        return descriptors;\n    }, protoDescriptors)\n);\n\nfunction bindArrayMethod(name, fn) {\n    return new Function('fn',\n        'return function ' + name + ' () {' +\n            'return fn.apply(this, arguments);' +\n        '};'\n    )(fn);\n}\n\nvar isArray = Array.isArray;\nvar typeofObject = 'object';\nvar typeofString = 'string';\n\nfunction getInst(inst) {\n    var typeofInst = typeof inst;\n    var argsLen = arguments.length;\n    if (argsLen === 0) {\n        inst = this;\n    } else if (typeofInst !== typeofString) {\n        if (!inst || typeofInst !== typeofObject) {\n            return inst;\n        }\n    } else if (argsLen !== 1) {\n        return inst;\n    } else {\n        inst = this;\n    }\n    return inst === global ? undefined : inst;\n}\n\nfunction toJSON() {\n    return serialize(getInst.apply(this, arguments), toJSON);\n}\n\nfunction toString(includeMetadata, includeStatus) {\n    return JSON.stringify(serialize(\n        getInst.call(this, this),\n        serialize,\n        includeMetadata === true,\n        false, includeStatus === true\n    ));\n}\n\nfunction toProps(inst) {\n\n    inst = getInst.apply(this, arguments);\n\n    var f_meta_inst, f_meta_json, version = 0;\n    var json = serialize(inst, toProps, true, true);\n\n    if (inst && (f_meta_inst = inst[f_meta_data])) {\n        version = f_meta_inst[f_meta_version];\n    }\n\n    if (!(!json || typeof json !== typeofObject)) {\n        if (f_meta_json = json[f_meta_data]) {\n            f_meta_json[f_meta_version] = version;\n        }\n    }\n\n    return json;\n}\n\nfunction serialize(inst, serializer, includeMetadata, createWithProto, includeStatus) {\n\n    if (!inst || typeof inst !== typeofObject) {\n        return inst;\n    }\n\n    var count, total, f_meta, keys, key, xs, ys;\n\n    if (isArray(inst)) {\n        xs = inst;\n    } else {\n\n        count = -1;\n        keys = Object.keys(inst);\n        total = keys.length;\n        xs = {};\n\n        if (createWithProto) {\n            xs.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (includeMetadata && (f_meta = inst[f_meta_data])) {\n\n            var $code = f_meta['$code'];\n            var status = f_meta[f_meta_status];\n            var abs_path = f_meta[f_meta_abs_path];\n            var deref_to = f_meta[f_meta_deref_to];\n            var deref_from = f_meta[f_meta_deref_from];\n\n            f_meta = {};\n            $code && (f_meta['$code'] = $code);\n            abs_path && (f_meta[f_meta_abs_path] = abs_path);\n            deref_to && (f_meta[f_meta_deref_to] = deref_to);\n            deref_from && (f_meta[f_meta_deref_from] = deref_from);\n            includeStatus && status && (f_meta[f_meta_status] = status);\n\n            xs[f_meta_data] = f_meta;\n\n            if (createWithProto) {\n                ys = {};\n                ys.__proto__ = xs;\n                xs = ys;\n            }\n        }\n\n        while (++count < total) {\n            if ((key = keys[count]) !== f_meta_data) {\n                xs[key] = serializer(inst[key], serializer, includeMetadata, createWithProto, includeStatus);\n            }\n        }\n    }\n\n    return xs;\n}\n\nmodule.exports = FalcorJSON;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/FalcorJSON.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = '`null` is not allowed in branch key positions.';\n\n/**\n * Do not allow null in path.\n */\nmodule.exports = createErrorClass('NullInPathError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NullInPathError.js","module.exports = createErrorClass;\n\nfunction createErrorClass(name, init) {\n    function E(message) {\n        this.message = message;\n        init && init.apply(this, arguments);\n        if (!Error.captureStackTrace) {\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    E.prototype = Object.create(Error.prototype);\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    E.is = function(x) { return x.name === name; };\n    return E;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/createErrorClass.js","module.exports = isObject;\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isObject.js","var isInternal = require('../internal/isInternal');\n\nmodule.exports = clone;\n\nfunction clone(node) {\n\n    var key, keys = Object.keys(node),\n        json = {}, index = -1, length = keys.length;\n\n    while (++index < length) {\n        key = keys[index];\n        if (isInternal(key)) {\n            continue;\n        }\n        json[key] = node[key];\n    }\n\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/clone.js","module.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[f_refs_length] || 0;\n    to[f_ref + backRefs] = from;\n    to[f_refs_length] = backRefs + 1;\n\n    // create a hard reference\n    from[f_ref_index] = backRefs;\n    from[f_context] = to;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/createHardlink.js","var isObject = require('./../support/isObject');\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getSize.js","/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = getCachePosition;\n\nfunction getCachePosition(cache, path) {\n\n    var node = cache;\n    var type, depth = 0;\n    var maxDepth = path.length;\n\n    if (maxDepth > 0) {\n        do {\n            node = node[path[depth]];\n\n            while (node && (type = node.$type) === $ref) {\n                node = getCachePosition(cache, node.value);\n            }\n        } while (++depth < maxDepth && node && !type);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCachePosition.js","var removeNodeAndDescendants = require('./removeNodeAndDescendants');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = updateNodeAncestors;\n\nfunction updateNodeAncestors(node, offset, lru, version) {\n    var curr = node, next = curr[f_parent];\n    do {\n        if ((curr.$size = (curr.$size || 0) - offset) > 0) {\n            if (!(next = curr[f_parent])) {\n                curr[f_version] = version;\n            } else if (curr[f_version] !== version) {\n                updateBackReferenceVersions(curr, version);\n            }\n        } else if (next = curr[f_parent]) {\n            removeNodeAndDescendants(curr, next, curr[f_key], lru, version);\n        }\n    } while (curr = next);\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateNodeAncestors.js","var createErrorClass = require('./createErrorClass');\n\n/**\n * InvalidKeySetError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidKeySetError', function(path, keysOrRanges) {\n    this.mesage = '' +\n        'The KeySet ' + JSON.stringify(keysOrRanges) +\n        ' in path ' + JSON.stringify(path) + ' contains a KeySet. ' +\n        'Keysets can only contain Keys or Ranges';\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidKeySetError.js","var EXPIRES_NEVER = require('./../values/expires-never');\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    var head = root[f_head];\n\n    // Nothing is in the cache.\n    if (!head) {\n        root[f_head] = root[f_tail] = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[f_prev];\n    var next = object[f_next];\n    if (next) {\n        next[f_prev] = prev;\n    }\n    if (prev) {\n        prev[f_next] = next;\n    }\n    object[f_prev] = undefined;\n\n    // Insert into head position\n    root[f_head] = object;\n    object[f_next] = head;\n    head[f_prev] = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    if (object === root[f_tail]) {\n        root[f_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/promote.js","var Subscription = require('./Subscription');\n\nmodule.exports = Subscriber;\n\nfunction Subscriber(destination, parent, onCompleted) {\n    if (typeof destination === 'function' ||\n             typeof parent === 'function' ||\n        typeof onCompleted === 'function') {\n        Subscription.call(this, []);\n        this.destination = {\n            error: parent,\n            onError: parent,\n            next: destination,\n            onNext: destination,\n            complete: onCompleted,\n            onCompleted: onCompleted\n        }\n    } else {\n        Subscription.call(this, [], parent);\n        this.parent = parent;\n        this.destination = destination;\n    }\n}\n\nSubscriber.prototype = Object.create(Subscription.prototype);\n\nSubscriber.prototype.next =\nSubscriber.prototype.onNext = function onNext(value) {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onNext) {\n            dest.onNext(value);\n        } else if (dest.next) {\n            dest.next(value);\n        }\n    }\n}\n\nSubscriber.prototype.error =\nSubscriber.prototype.onError = function onError(error) {\n    var signaled = false;\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onError) {\n            signaled = true;\n            dest.onError(error);\n        } else if (dest.error) {\n            signaled = true;\n            dest.error(error);\n        }\n        this.dispose();\n    }\n    if (!signaled) {\n        throw error;\n    }\n}\n\nSubscriber.prototype.complete =\nSubscriber.prototype.onCompleted = function onCompleted() {\n    var dest = this.destination;\n    if (dest) {\n        if (dest.onCompleted) {\n            dest.onCompleted();\n        } else if (dest.complete) {\n            dest.complete();\n        }\n        this.dispose();\n    }\n}\n\nSubscriber.prototype.dispose =\nSubscriber.prototype.unsubscribe = function () {\n    this.destination = null;\n    Subscription.prototype.dispose.call(this);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscriber.js","module.exports = Subscription;\n\nfunction Subscription(subscriptions, parent) {\n    this.parent = parent;\n    this.subscriptions = subscriptions || [];\n}\n\nSubscription.prototype.add = function(subscription) {\n    return this.subscriptions.push(subscription) && this || this;\n}\n\nSubscription.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.subscriptions.splice(index, 1);\n    }\n    return this;\n}\n\nSubscription.prototype.dispose =\nSubscription.prototype.unsubscribe = function () {\n    var subscription, subscriptions = this.subscriptions;\n    while (subscriptions.length) {\n        (subscription = subscriptions.pop()) &&\n            subscription.dispose &&\n            subscription.dispose();\n    }\n    var parent = this.parent;\n    if (parent) {\n        this.parent = null;\n        parent.remove && parent.remove(this);\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subscription.js","var isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\n\nmodule.exports = onValueType;\n\nfunction onValueType(node, type, json,\n                     path, depth, seed, results,\n                     requestedPath, requestedLength,\n                     optimizedPath, optimizedLength,\n                     fromReference, modelRoot, expired, expireImmediate,\n                     branchSelector, boxValues, materialized, reportMissing,\n                     treatErrorsAsValues, onValue, onMissing, onMaterialize) {\n\n    var reportMaterialized = reportMissing;\n\n    if (type) {\n        if (isExpired(node, expireImmediate)) {\n            if (!node[f_invalidated]) {\n                expireNode(node, expired, modelRoot);\n            }\n        } else {\n            lruPromote(modelRoot, node);\n            if (node.value === undefined) {\n                reportMissing = false;\n                reportMaterialized = materialized;\n            } else {\n                if (seed) {\n                    if (fromReference) {\n                        requestedPath[depth] = null;\n                    }\n                    return onValue(node, type, depth, seed, results,\n                                   requestedPath, optimizedPath, optimizedLength,\n                                   fromReference, boxValues, materialized, treatErrorsAsValues);\n                }\n                return undefined;\n            }\n        }\n    }\n\n    if (materialized) {\n        seed && (results.hasValue = true);\n    } else if (!reportMaterialized) {\n        return undefined;\n    }\n\n    return onMissing(path, depth, results,\n                     requestedPath, requestedLength, fromReference,\n                     optimizedPath, optimizedLength, reportMissing,\n                     materialized, json, branchSelector,\n                     boxValues, onMaterialize, modelRoot);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onValueType.js","var getCachePosition = require('./getCachePosition');\n\nmodule.exports = getBoundCacheNode;\n\nfunction getBoundCacheNode(model, path) {\n    path = path || model._path;\n    var node = model._node;\n    if (!node || node[f_parent] === undefined || node[f_invalidated]) {\n        model._node = null;\n        if (path.length === 0) {\n            node = model._root.cache;\n        } else {\n            node = getCachePosition(model._root.cache, path);\n            if (path === model._path) {\n                model._node = node;\n            }\n        }\n    }\n    return node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getBoundCacheNode.js","var arr = new Array(5);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar mergeJSONGraphNode = require('../mergeJSONGraphNode');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, expireImmediate\n            );\n        }\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n    arr[3] = undefined;\n    arr[4] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[4];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var messageParent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        messageParent = messageRoot;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var container = node;\n        var count = reference.length - 1;\n        parent = node = root;\n        messageParent = message = messageRoot;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(\n                root, parent, node, messageRoot, messageParent, message,\n                key, branch, true, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n            node = results[0];\n            optimizedPath = results[4];\n            if (!node || typeof node !== 'object') {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n            message = results[2];\n            messageParent = results[3];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        optimizedPath = results[4];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            messageParent = message;\n            node = parent[key];\n            message = messageParent && messageParent[key];\n        }\n\n        node = mergeJSONGraphNode(\n            parent, node, message, key, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = message;\n    arr[3] = messageParent;\n    arr[4] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setJSONGraphs.js","var arr = new Array(3);\nvar isArray = Array.isArray;\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar getCachePosition = require('../getCachePosition');\nvar isInternalKey = require('../../support/isInternalKey');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar mergeValueOrInsertBranch = require('../mergeValueOrInsertBranch');\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[f_parent] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, modelRoot, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath, version,\n                expired, lru, comparator, errorSelector, expireImmediate\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            var nextNode = results[0];\n            var nextParent = results[1];\n            var nextOptimizedPath = results[2];\n            nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                        version, expired, lru, comparator, errorSelector, expireImmediate\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n        var container = node;\n        parent = root;\n\n        node = node[f_context];\n\n        if (node != null) {\n            parent = node[f_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n            optimizedPath.index = index;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[f_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate);\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node && node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction getKeys(pathMap) {\n\n    if (!(!pathMap || typeof pathMap !== 'object') && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = 'length';\n        }\n        for (var key in pathMap) {\n            if (isInternalKey(key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathMaps.js","/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nmodule.exports = isInternalKey;\n\nvar isInternal = require('../internal/isInternal');\n\nfunction isInternalKey(key) {\n    return key && key[0] === '$' || isInternal(key);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isInternalKey.js","module.exports = require(\"@graphistry/falcor-path-utils/lib/support/materializedAtom\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/support/materializedAtom\"\n// module id = 20\n// module chunks = 0","module.exports = require('./getJSON');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/index.js","module.exports = require('./getJSONGraph');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/index.js","module.exports = inlineJSONGraphValue;\n\n/* eslint-disable no-constant-condition */\nfunction inlineJSONGraphValue(node, path, length, seed, branch) {\n\n    var key, depth = 0, prev,\n        curr = seed.jsonGraph;\n\n    if (!curr) {\n        seed.jsonGraph = curr = {};\n    }\n\n    do {\n        prev = curr;\n        key = path[depth++];\n        if (depth >= length) {\n            curr = prev[key] = branch !== true ? node : prev[key] || {};\n            break;\n        }\n        curr = prev[key] || (prev[key] = {});\n    } while (true);\n\n    return curr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/inlineValue.js","var isArray = Array.isArray;\n\nmodule.exports = onMissing;\n\n/* eslint-disable no-constant-condition */\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, json, branchSelector,\n                   boxValues, onMaterialize, modelRoot) {\n\n    if (!reportMissing && !reportMaterialized) {\n        return;\n    }\n\n    var keyset,\n        restPathIndex = -1,\n        restPathCount = requestedLength - depth,\n        restPath = restPathCount && new Array(restPathCount) || undefined;\n\n    while (++restPathIndex < restPathCount) {\n        keyset = path[restPathIndex + depth];\n        if (isEmptyKeySet(keyset)) {\n            return;\n        }\n        restPath[restPathIndex] = keyset;\n    }\n\n    var index, count, mPath;\n    var lastKeyIsNull = keyset === null;\n    var isRequestedPath = reportMissing;\n    var missDepth, missTotal, missingPath, missingPaths;\n\n    if (!reportMissing) {\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } else {\n        missDepth = depth;\n        missTotal = requestedLength;\n        missingPath = requestedPath;\n        missingPaths = results.requested || (results.requested = []);\n    }\n\n    do {\n        if (restPathCount < requestedLength || !isRequestedPath) {\n            index = -1;\n            count = missDepth;\n            mPath = new Array(missTotal);\n            while (++index < count) {\n                mPath[index] = missingPath[index];\n            }\n            restPathIndex = -1;\n            while (index < missTotal) {\n                mPath[index++] = restPath[++restPathIndex];\n            }\n        }\n\n        // break after inserting both requested and optimized missing paths\n        if (isRequestedPath = !isRequestedPath) {\n            if (reportMissing) {\n                missingPaths[missingPaths.length] = mPath;\n            }\n            break;\n        }\n\n        missingPaths[missingPaths.length] = mPath || restPath;\n\n        missDepth = optimizedLength;\n        missingPath = optimizedPath;\n        missingPaths = results.missing || (results.missing = []);\n        missTotal = optimizedLength + restPathCount - Number(lastKeyIsNull);\n    } while (true);\n\n    if (reportMaterialized) {\n        return onMaterialize(json, mPath, missDepth, missTotal, branchSelector, boxValues, modelRoot);\n    }\n}\n/* eslint-enable */\n\nfunction isEmptyKeySet(keyset) {\n\n    // false if the keyset is a primitive\n    if ('object' !== typeof keyset) {\n        return false;\n    } else if (keyset === null) {\n        return false;\n    }\n\n    if (isArray(keyset)) {\n        // return true if the keyset is an empty array\n        return keyset.length === 0;\n    }\n\n    var rangeEnd = keyset.to,\n        from = keyset.from || 0;\n    if ('number' !== typeof rangeEnd) {\n        rangeEnd = from + (keyset.length || 0);\n    }\n\n    // false if trying to request incorrect or empty ranges\n    // e.g. { from: 10, to: 0 } or { from: 5, length: 0 }\n    return from >= rangeEnd;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMissing.js","var arr = new Array(2);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\nvar getSize = require('../../support/getSize');\nvar createHardlink = require('../createHardlink');\nvar getBoundCacheNode = require('../getBoundCacheNode');\nvar updateNodeAncestors = require('../updateNodeAncestors');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = invalidatePathSets;\n\nfunction invalidatePathSets(model, paths, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n    var parent = node[f_parent] || cache;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        arr = invalidateNode(\n            root, parent, node,\n            key, branch, false, version,\n            expired, lru, expireImmediate\n        );\n        var nextNode = arr[0];\n        var nextParent = arr[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru, expireImmediate\n                );\n            } else {\n                updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[f_context];\n\n    if (node != null) {\n        parent = node[f_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(\n                root, parent, node,\n                key, branch, true, version,\n                expired, lru, expireImmediate\n            );\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, branch, reference, version,\n    expired, lru, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        arr = invalidateReference(root, node, version, expired, lru, expireImmediate);\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathSets.js","var lruSplice = require('../lru/splice');\nvar isInternalKey = require('../support/isInternalKey');\nvar unlinkBackReferences = require('./unlinkBackReferences');\nvar unlinkForwardReference = require('./unlinkForwardReference');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = removeNodeAndDescendants;\n\nfunction removeNodeAndDescendants(node, parent, key, lru, version) {\n    if (!(!node || typeof node !== 'object')) {\n        var type = node.$type;\n        if (type === undefined) {\n            for (var key2 in node) {\n                if (!isInternalKey(key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru, version);\n                }\n            }\n        } else {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            lruSplice(lru, node);\n        }\n        unlinkBackReferences(updateBackReferenceVersions(node, version));\n        parent[key] = node[f_parent] = undefined;\n        return true;\n    }\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/removeNodeAndDescendants.js","var arr = new Array(3);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar createHardlink = require('../createHardlink');\nvar getCachePosition = require('../getCachePosition');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar iterateKeySet = require('@graphistry/falcor-path-utils/lib/iterateKeySet');\nvar mergeValueOrInsertBranch = require('../mergeValueOrInsertBranch');\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, errorSelector, comparator, expireImmediate) {\n\n    var modelRoot = model._root;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = getCachePosition(cache, bound);\n\n    if (!node) {\n        return [[], [], false];\n    }\n\n    var parent = node[f_parent] || cache;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, modelRoot, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n    arr[2] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return [requestedPaths, optimizedPaths, true];\n    }\n\n    return [requestedPaths, optimizedPaths, false];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var results = setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n\n        var nextNode = results[0];\n        var nextParent = results[1];\n        var nextOptimizedPath = results[2];\n        nextOptimizedPath[nextOptimizedPath.index++] = key;\n\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, nextOptimizedPath,\n                    version, expired, lru, comparator, errorSelector, expireImmediate\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var parent;\n    var reference = node.value;\n    optimizedPath = reference.slice(0);\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        node = undefined;\n        parent = root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var container = node;\n        parent = root;\n\n        node = node[f_context];\n\n        if (node != null) {\n            parent = node[f_parent] || root;\n            optimizedPath.index = reference.length;\n        } else {\n\n            var index = 0;\n            var count = reference.length - 1;\n\n            parent = node = root;\n\n            do {\n                var key = reference[index];\n                var branch = index < count;\n                optimizedPath.index = index;\n\n                var results = setNode(\n                    root, parent, node, key, value,\n                    branch, true, requestedPath, optimizedPath, version,\n                    expired, lru, comparator, errorSelector, expireImmediate\n                );\n                node = results[0];\n                optimizedPath = results[2];\n                if (!node || typeof node !== 'object') {\n                    optimizedPath.index = index;\n                    return results;\n                }\n                parent = results[1];\n            } while (index++ < count);\n\n            optimizedPath.index = index;\n\n            if (container[f_context] !== node) {\n                createHardlink(container, node);\n            }\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n\n        node = results[0];\n\n        if (!node || typeof node !== 'object') {\n            return results;\n        }\n\n        parent = results[1];\n        optimizedPath = results[2];\n        type = node.$type;\n    }\n\n    if (!branch || type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new NullInPathError();\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n\n        node = mergeValueOrInsertBranch(\n            parent, node, key, value,\n            branch, reference, requestedPath, optimizedPath, version,\n            expired, lru, comparator, errorSelector, expireImmediate\n        );\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n    arr[2] = optimizedPath;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/setPathValues.js","module.exports = updateBackReferenceVersions;\n\nfunction updateBackReferenceVersions(nodeArg, version) {\n    var node = nodeArg, stack = [], count = 0, ref, i, n;\n    do {\n        i = -1;\n        ref = node[f_parent];\n        node[f_version] = version;\n        n = node[f_refs_length] || 0;\n        do {\n            if (ref && ref[f_version] !== version) {\n                stack[count++] = ref;\n            }\n            if (++i < n) {\n                ref = node[f_ref + i];\n                continue;\n            }\n            break;\n        } while (true);\n    } while (node = stack[--count]);\n    return nodeArg;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/updateBackReferenceVersions.js","/**\n * Determined if the key passed in is an f_ internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\n\nvar f_ = require('./f_');\nvar regexp = new RegExp('^' + f_, 'i', 'g');\n\nmodule.exports = regexp.test.bind(regexp);\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/isInternal.js","var isObject = require('./../support/isObject');\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getTimestamp.js","module.exports = 0;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-now.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 32\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/iterateKeySet\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/iterateKeySet\"\n// module id = 33\n// module chunks = 0","var isArray = Array.isArray;\nvar walkPathAndBuildOutput = require('./walkPath');\nvar walkFlatBufferAndBuildOutput = require('./walkFlatBuffer');\nvar getBoundCacheNode = require('../../getBoundCacheNode');\nvar InvalidModelError = require('../../../errors/InvalidModelError');\nvar toFlatBuffer = require('@graphistry/falcor-path-utils/lib/toFlatBuffer');\nvar computeFlatBufferHash = require('@graphistry/falcor-path-utils/lib/computeFlatBufferHash');\n\nmodule.exports = getJSON;\n\nfunction getJSON(model, paths, seed, progressive, expireImmediate) {\n\n    var node,\n        referenceContainer,\n        boundPath = model._path,\n        modelRoot = model._root,\n        cache = modelRoot.cache,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, get the cache position.\n    if (optimizedLength) {\n        node = getBoundCacheNode(model);\n        // If there was a short, then we 'throw an error' to the outside\n        // calling function which will onError the observer.\n        if (node && node.$type) {\n            return { error: new InvalidModelError(boundPath, boundPath) };\n        }\n        // We need to get the new cache position and copy the bound path.\n        optimizedPath = [];\n        for (var i = 0; i < optimizedLength; ++i) {\n            optimizedPath[i] = boundPath[i];\n        }\n        referenceContainer = model._referenceContainer;\n    } else {\n        node = cache;\n        optimizedPath = [];\n    }\n\n    requestedPath = [];\n\n    var isFlatBuffer = false,\n        json = seed && seed.json,\n        results = { data: seed },\n        boxValues = model._boxed,\n        expired = modelRoot.expired,\n        recycleJSON = model._recycleJSON,\n        hasDataSource = Boolean(model._source),\n        branchSelector = modelRoot.branchSelector,\n        materialized = seed && model._materialized,\n        treatErrorsAsValues = model._treatErrorsAsValues,\n        allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    var arr, path, pathsIndex = 0, pathsCount = paths.length;\n\n    if (pathsCount > 0) {\n\n        if (recycleJSON) {\n            isFlatBuffer = true;\n            if (pathsCount > 1 || isArray(paths[0])) {\n                pathsCount = 1;\n                paths = [computeFlatBufferHash(toFlatBuffer(paths, {}))];\n            }\n        }\n\n        do {\n            path = paths[pathsIndex];\n            if (isFlatBuffer) {\n                arr = walkFlatBufferAndBuildOutput(cache, node, json, paths[0], 0, seed, results,\n                                                   requestedPath, optimizedPath, optimizedLength,\n                                                   /* fromReference = */ false, referenceContainer,\n                                                   modelRoot, expired, expireImmediate, branchSelector,\n                                                   boxValues, materialized, hasDataSource,\n                                                   treatErrorsAsValues, allowFromWhenceYouCame);\n            } else {\n                requestedLength = path.length;\n                arr = walkPathAndBuildOutput(cache, node, json, path,\n                                          /* depth = */ 0, seed, results,\n                                             requestedPath, requestedLength,\n                                             optimizedPath, optimizedLength,\n                                             /* fromReference = */ false, referenceContainer,\n                                             modelRoot, expired, expireImmediate, branchSelector,\n                                             boxValues, materialized, hasDataSource,\n                                             treatErrorsAsValues, allowFromWhenceYouCame);\n            }\n            json = arr[0];\n            arr[0] = undefined;\n            arr[1] = undefined;\n        } while (++pathsIndex < pathsCount);\n    }\n\n    var requested = results.requested;\n\n    results.args = isFlatBuffer && paths || requested;\n\n    if (requested && requested.length) {\n        results.relative = results.args;\n        if (optimizedLength) {\n            var boundRequested = [];\n            for (var i = 0, len = requested.length; i < len; ++i) {\n                boundRequested[i] = boundPath.concat(requested[i]);\n            }\n            results.requested = boundRequested;\n        }\n    }\n\n    if (results.hasValue) {\n        seed.json = json;\n    }\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getJSON.js","var arr = new Array(3);\nvar promote = require('../../../lru/promote');\nvar isExpired = require('../../isExpired');\nvar createHardlink = require('../../createHardlink');\nvar CircularReferenceError = require('../../../errors/CircularReferenceError');\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[f_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n    arr[2] = ref;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/getReferenceTarget.js","var clone = require('../../clone');\nvar onError = require('./onError');\n\nmodule.exports = onJSONValue;\n\nfunction onJSONValue(node, type, depth, seed, results,\n                     requestedPath, optimizedPath, optimizedLength,\n                     fromReference, boxValues, materialized,\n                     treatErrorsAsValues) {\n\n    if ($error === type && !treatErrorsAsValues) {\n        return onError(node, depth, results, requestedPath,\n                       fromReference, boxValues);\n    }\n\n    results.hasValue = true;\n\n    // boxValues always clones the node\n    return !boxValues ? node.value : clone(node);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onValue.js","var walkPathAndBuildOutput = require('./walkPath');\nvar BoundJSONGraphModelError = require('../../../errors/BoundJSONGraphModelError');\n\nmodule.exports = getJSONGraph;\n\nfunction getJSONGraph(model, paths, seed, progressive, expireImmediate) {\n\n    var node, cache,\n        boundPath = model._path,\n        modelRoot = model._root,\n        requestedPath, requestedLength,\n        optimizedPath, optimizedLength =\n            boundPath && boundPath.length || 0;\n\n    // If the model is bound, then get that cache position.\n    if (optimizedLength) {\n        // JSONGraph output cannot ever be bound or else it will\n        // throw an error.\n        return { error: new BoundJSONGraphModelError() };\n    } else {\n        optimizedPath = [];\n        cache = node = modelRoot.cache;\n    }\n\n    requestedPath = [];\n\n    var boxValues = model._boxed,\n        expired = modelRoot.expired,\n        materialized = model._materialized,\n        hasDataSource = Boolean(model._source),\n        treatErrorsAsValues = model._treatErrorsAsValues,\n\n        results = { data: seed },\n        pathsIndex = -1, pathsCount = paths.length;\n\n    while (++pathsIndex < pathsCount) {\n        var path = paths[pathsIndex];\n        requestedLength = path.length;\n        walkPathAndBuildOutput(cache, node, path,\n                            /* depth = */ 0, seed, results,\n                               requestedPath, requestedLength,\n                               optimizedPath, optimizedLength,\n              /* fromReference = */ false, modelRoot, expired, expireImmediate,\n                               boxValues, materialized, hasDataSource, treatErrorsAsValues);\n    }\n\n    results.args =\n    results.relative = results.requested;\n\n    return results;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getJSONGraph.js","var isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = require('../clone');\nvar FalcorJSON = require('./json/FalcorJSON');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMaterialize;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterialize(json, path, depth, length,\n                       branchSelector, boxValues, modelRoot) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (depth === length) {\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta;\n\n    var nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0;\n\n    keyset = path[depth];\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[f_meta_data])) {\n        json[f_meta_data] = f_meta = {};\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n    } else {\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = path.slice(0, depth);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            // insert the materialized branch\n            json[nextKey] = onMaterialize(\n                json[nextKey], path,\n                nextDepth, length,\n                branchSelector,\n                boxValues,\n                modelRoot\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMaterialize.js","var isArray = Array.isArray;\nvar isPathValue = require('../support/isPathValue');\nvar isJSONEnvelope = require('../support/isJSONEnvelope');\nvar isJSONGraphEnvelope = require('../support/isJSONGraphEnvelope');\n\nmodule.exports = groupCacheArguments;\n\nfunction groupCacheArguments(args) {\n\n    var groups = [];\n    var argIndex = -1;\n    var argCount = args.length;\n    var group, groupType, arg, argType;\n\n    while (++argIndex < argCount) {\n        arg = args[argIndex];\n        if (isArray(arg)) {\n            arg = { path: arg };\n            argType = 'PathValues';\n        } else if (isPathValue(arg)) {\n            argType = 'PathValues';\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = 'JSONGraphs';\n        } else if (isJSONEnvelope(arg)) {\n            argType = 'PathMaps';\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            groups.push(group = {\n                arguments: [],\n                inputType: argType\n            });\n        }\n\n        group.arguments.push(arg);\n    }\n\n    return groups;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/groupCacheArguments.js","module.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    node[f_key] = key;\n    node[f_parent] = parent;\n\n    if (version !== undefined) {\n        node[f_version] = version;\n    }\n    if (!node[f_abs_path]) {\n        node[f_abs_path] = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/insertNode.js","var arr = new Array(2);\nvar isExpired = require('../isExpired');\nvar expireNode = require('../expireNode');\nvar lruPromote = require('../../lru/promote');\nvar getSize = require('../../support/getSize');\nvar createHardlink = require('../createHardlink');\nvar getBoundCacheNode = require('../getBoundCacheNode');\nvar isInternalKey = require('../../support/isInternalKey');\nvar updateNodeAncestors = require('../updateNodeAncestors');\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = invalidatePathMaps;\n\nfunction invalidatePathMaps(model, pathMapEnvelopes, expireImmediate) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = modelRoot.version + 1;\n    var comparator = modelRoot._comparator;\n    var cache = modelRoot.cache;\n    var node = getBoundCacheNode(model);\n\n    if (!node) {\n        return false;\n    }\n\n    var pathMapIndex = -1;\n    var parent = node[f_parent] || cache;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, expireImmediate\n        );\n    }\n\n    arr[0] = undefined;\n    arr[1] = undefined;\n\n    if (cache[f_version] === version) {\n        modelRoot.version = version;\n        return true;\n    }\n\n    return false;\n}\n\nfunction invalidatePathMap(\n    pathMap, depth, root, parent, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (!pathMap || typeof pathMap !== 'object' || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (!isInternalKey(key)) {\n            var child = pathMap[key];\n            var branch = !(!child || typeof child !== 'object') && !child.$type;\n            arr = invalidateNode(\n                root, parent, node,\n                key, child, branch, false, version, expired,\n                lru, comparator, expireImmediate\n            );\n            var nextNode = arr[0];\n            var nextParent = arr[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, expireImmediate\n                    );\n                } else {\n                    updateNodeAncestors(nextNode, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(\n    value, root, node, version,\n    expired, lru, comparator, expireImmediate) {\n\n    if (isExpired(node, expireImmediate)) {\n        expireNode(node, expired, lru);\n        arr[0] = undefined;\n        arr[1] = root;\n        return arr;\n    }\n\n    lruPromote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[f_context];\n\n    if (node != null) {\n        parent = node[f_parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            arr = invalidateNode(\n                root, parent, node,\n                key, value, branch, true, version,\n                expired, lru, comparator, expireImmediate\n            );\n            node = arr[0];\n            if (!node && typeof node !== 'object') {\n                return arr;\n            }\n            parent = arr[1];\n        } while (index++ < count);\n\n        if (container[f_context] !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, value, branch, reference, version,\n    expired, lru, comparator, expireImmediate) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        arr = invalidateReference(\n            value, root, node, version, expired,\n            lru, comparator, expireImmediate\n        );\n\n        node = arr[0];\n\n        if (!node && typeof node !== 'object') {\n            return arr;\n        }\n\n        parent = arr[1];\n        type = node.$type;\n    }\n\n    if (type === undefined) {\n        if (key == null) {\n            if (branch) {\n                throw new Error('`null` is not allowed in branch key positions.');\n            } else if (node) {\n                key = node[f_key];\n            }\n        } else {\n            parent = node;\n            node = parent[key];\n        }\n    }\n\n    arr[0] = node;\n    arr[1] = parent;\n\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/invalidatePathMaps.js","var $now = require('../values/expires-now');\nvar getType = require('../support/getType');\nvar getSize = require('../support/getSize');\nvar getTimestamp = require('../support/getTimestamp');\n\nvar wrapNode = require('./wrapNode');\nvar isExpired = require('./isExpired');\nvar expireNode = require('./expireNode');\nvar insertNode = require('./insertNode');\nvar replaceNode = require('./replaceNode');\nvar reconstructPath = require('./reconstructPath');\nvar updateNodeAncestors = require('./updateNodeAncestors');\nvar removeNodeAndDescendants = require('./removeNodeAndDescendants');\n\nmodule.exports = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath, version,\n    expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var cType = getType(node, reference);\n\n    if (branch || reference) {\n        if (cType && isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge if it expires immediately\n             */\n            true)) {\n            expireNode(node, expired, lru);\n            cType = node.$expires === $now ? cType : 'expired';\n        }\n        if ((cType && cType !== $ref) || (!node || typeof node !== 'object')) {\n            node = replaceNode(node, {}, parent, key, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    } else {\n        var message = value;\n        var isDistinct = true;\n        var mType = getType(message);\n\n        // If both the cache and message are primitives,\n        // insert the message into the cache.\n        if (!cType && !mType) {\n            isDistinct = true;\n        }\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        else if (comparator) {\n            isDistinct = !(comparator.length < 3 ?\n                comparator(node, message) : comparator(node, message,\n                    optimizedPath.slice(0, optimizedPath.index))\n            );\n        } else {\n            // Comparing either Number or undefined to undefined always results in false.\n            isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n        }\n\n        if (isDistinct) {\n\n            if (errorSelector && mType === $error) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            var sizeOffset = getSize(node) - getSize(message =\n                wrapNode(message, mType, mType ? message.value : message));\n\n            node = replaceNode(node, message, parent, key, lru, version);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeValueOrInsertBranch.js","/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/reconstructPath.js","var transferBackReferences = require('./transferBackReferences');\nvar removeNodeAndDescendants = require('./removeNodeAndDescendants');\nvar updateBackReferenceVersions = require('./updateBackReferenceVersions');\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, version) {\n    if (node === replacement) {\n        return node;\n    } else if (!(!node || typeof node !== 'object')) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n        updateBackReferenceVersions(replacement, version);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/replaceNode.js","var isArray = Array.isArray;\nvar now = require('../support/now');\nvar clone = require('./../support/clone');\nvar getSize = require('./../support/getSize');\nvar getExpires = require('../support/getExpires');\nvar expiresNow = require('../values/expires-now');\n\nvar atomSize = 50;\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node[f_wrapped_value];\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        node[f_prev] = undefined;\n        node[f_next] = undefined;\n        node[f_wrapped_value] = modelCreated || false;\n    } else {\n        node = { $type: $atom, value: value };\n        node[f_prev] = undefined;\n        node[f_next] = undefined;\n        node[f_wrapped_value] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case 'object':\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case 'string':\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === 'number' && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/wrapNode.js","var createErrorClass = require('./createErrorClass');\n\nmodule.exports = createErrorClass('CircularReferenceError', function(referencePath) {\n    this.message = 'Encountered circular reference ' + JSON.stringify(referencePath);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/CircularReferenceError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'An exception was thrown when making a request';\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nmodule.exports = createErrorClass('InvalidSourceError', function(error) {\n    this.message = MESSAGE + ':\\n\\t' + error;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidSourceError.js","module.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    var prev = object[f_prev];\n    var next = object[f_next];\n    if (next) {\n        next[f_prev] = prev;\n    }\n    if (prev) {\n        prev[f_next] = next;\n    }\n    object[f_prev] = object[f_next] = undefined;\n\n    if (object === root[f_head]) {\n        root[f_head] = next;\n    }\n    if (object === root[f_tail]) {\n        root[f_tail] = prev;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/splice.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar $$observable = require('symbol-observable').default;\n\nmodule.exports = Source;\n\nfunction Source(subscribe) {\n    if (!subscribe) {\n        return;\n    }\n    switch (typeof subscribe) {\n        case 'object':\n            this.source = subscribe;\n            break;\n        case 'function':\n            this.source = { subscribe: subscribe };\n            break;\n    }\n}\n\nSource.prototype[$$observable] = function() {\n    return this;\n}\n\nSource.prototype.operator = function(destination) {\n    return this.subscribe(destination);\n}\n\n// Unused\n// Source.prototype.lift = function(operator, source) {\n//     source = new Source(source || this);\n//     source.operator = operator;\n//     source._promise = this._promise;\n//     return source;\n// }\n\nSource.prototype.subscribe = function(destination, x, y) {\n    return new Subscription([\n        this.operator.call(\n            this.source, !(destination instanceof Subscriber) ?\n                new Subscriber(destination, x, y) : destination)\n    ]);\n}\n\nSource.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var source = this;\n    if (!this._promise) {\n        this._promise = new global['Promise'](function(resolve, reject) {\n            var values = [], rejected = false;\n            source.subscribe({\n                next: function(value) { values[values.length] = value; },\n                error: function(errors) { (rejected = true) && reject(errors); },\n                complete: function() {\n                    !rejected &&\n                    resolve(values.length <= 1 ? values[0] : values);\n                }\n            });\n        });\n    }\n    return this._promise.then(onNext, onError);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Source.js","var empty = {\n    dispose: function() {},\n    unsubscribe: function() {}\n};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/ImmediateScheduler.js","var isObject = require('./../support/isObject');\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && ('json' in envelope);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONEnvelope.js","var isArray = Array.isArray;\nvar isObject = require('./../support/isObject');\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isJSONGraphEnvelope.js","module.exports = Date.now;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/now.js","module.exports = 1;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/values/expires-never.js","module.exports = require(\"@graphistry/falcor-path-utils/lib/collapse\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/collapse\"\n// module id = 55\n// module chunks = 0","var Model = require('./Model');\nvar FalcorJSON = require('./cache/get/json/FalcorJSON');\n\nfunction falcor(opts) {\n    if (!(this instanceof Model)) {\n        return new Model(opts);\n    }\n    Model.call(this, opts);\n}\n\nfalcor.prototype = Object.create(Model.prototype);\n\nfalcor['Model'] = Model;\nfalcor['FalcorJSON'] = FalcorJSON;\nfalcor['toProps'] = FalcorJSON.prototype.toProps;\n\nmodule.exports = falcor;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","var Call = require('./request/Call');\nvar ModelRoot = require('./ModelRoot');\nvar FalcorJSON = require('./cache/get/json/FalcorJSON');\nvar ModelDataSourceAdapter = require('./ModelDataSourceAdapter');\nvar TimeoutScheduler = require('./schedulers/TimeoutScheduler');\nvar ImmediateScheduler = require('./schedulers/ImmediateScheduler');\nvar collapse = require('@graphistry/falcor-path-utils/lib/collapse');\n\nvar getSize = require('./support/getSize');\nvar isObject = require('./support/isObject');\nvar isJSONEnvelope = require('./support/isJSONEnvelope');\nvar getCachePosition = require('./cache/getCachePosition');\nvar isJSONGraphEnvelope = require('./support/isJSONGraphEnvelope');\n\nvar setCache = require('./cache/set/setPathMaps');\nvar setJSONGraphs = require('./cache/set/setJSONGraphs');\n\nvar getJSON = require('./cache/get/json');\nvar getCache = require('./cache/getCache');\nvar getJSONGraph = require('./cache/get/jsonGraph');\n\nmodule.exports = Model;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(opts) {\n\n    var options = opts || {};\n\n    this._node = options._node;\n    this._path = options._path || [];\n    this._source = options.source || options._source;\n    this._root = options._root || new ModelRoot(options, this);\n    this._recycleJSON = options.recycleJSON === true || options._recycleJSON;\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n\n    if (options._seed) {\n        this._recycleJSON = true;\n        this._seed = options._seed;\n        this._treatErrorsAsValues = true;\n    } else if (this._recycleJSON) {\n        this._treatErrorsAsValues = true;\n        this._seed = {};\n        this._seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    this._boxed = options.boxed === true || options._boxed || false;\n    this._materialized = options.materialized === true || options._materialized || false;\n    this._treatErrorsAsValues = options.treatErrorsAsValues === true || options._treatErrorsAsValues || false;\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame === true || options._allowFromWhenceYouCame || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = function get(...args) {\n    var seed = this._seed;\n    if (!seed) {\n        seed = {};\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n    return new Call('get', this, args)._toJSON(seed, []);\n}\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set(...args) {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n    return new Call('set', this, args)._toJSON(seed, []);\n}\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload(...args) {\n    return new Call('get', this, args)._toJSON(null, []);\n}\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\n\nModel.prototype.call = function call(...args) {\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n    return new Call('call', this, args)._toJSON(seed, []);\n}\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate(...args) {\n    return new Call('invalidate', this, args)._toJSON(null, null).then();\n}\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.deref = require('./deref');\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = require('./deref/hasValidParentReference');\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.getValue = function getValue(path) {\n    return new Call('get', this, [path])\n        ._toJSON({}, [])\n        .lift(function(subscriber) {\n            return this.subscribe({\n                onNext: function(data) {\n                    var depth = -1;\n                    var x = data.json;\n                    var length = path.length;\n                    while (x && !x.$type && ++depth < length) {\n                        x = x[path[depth]];\n                    }\n                    subscriber.onNext(x);\n                },\n                onError: subscriber.onError.bind(subscriber),\n                onCompleted: subscriber.onCompleted.bind(subscriber)\n            })\n        });\n}\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource('/model.json') });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints 'Jim' to the console.\n */\nModel.prototype.setValue = function setValue(path, value) {\n    path = arguments.length === 1 ? path.path : path;\n    value = arguments.length === 1 ? path : {path:path,value:value};\n    return new Call('set', this, [value])\n        ._toJSON({}, [])\n        .lift(function(subscriber) {\n            return this.subscribe({\n                onNext: function(data) {\n                    var depth = -1;\n                    var x = data.json;\n                    var length = path.length;\n                    while (x && !x.$type && ++depth < length) {\n                        x = x[path[depth]];\n                    }\n                    subscriber.onNext(x);\n                },\n                onError: subscriber.onError.bind(subscriber),\n                onCompleted: subscriber.onCompleted.bind(subscriber)\n            })\n        });\n}\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n\n    var modelRoot = this._root;\n    var cache = modelRoot.cache;\n\n    if (cacheOrJSONGraphEnvelope !== cache) {\n\n        var options = {\n            _path: [],\n            _boxed: false,\n            _root: modelRoot,\n            _materialized: false,\n            _treatErrorsAsValues: false\n        };\n\n        modelRoot.cache = this._node = {};\n\n        if (typeof cache !== 'undefined') {\n            modelRoot.expired = [];\n            modelRoot[f_head] = undefined;\n            modelRoot[f_tail] = undefined;\n            if (this._recycleJSON) {\n                this._seed = {};\n                this._seed.__proto__ = FalcorJSON.prototype;\n            }\n        }\n\n        var results, rootOnChangeHandler;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setJSONGraphs(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [cacheOrJSONGraphEnvelope]);\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            results = setCache(options, [{ json: cacheOrJSONGraphEnvelope }]);\n        }\n\n        if (results) {\n            // performs promotion without producing output.\n            if (results[0].length) {\n                getJSON(options, results[0], null, false, false);\n            }\n            if (results[2] && (rootOnChangeHandler = modelRoot.onChange)) {\n                rootOnChangeHandler();\n            }\n        }\n    } else if (typeof cache === 'undefined') {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache('genreLists[0...10][0...10].boxshot')));\n */\nModel.prototype.getCache = function _getCache() {\n\n    var paths = Array.prototype.slice.call(arguments, 0);\n\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var seed = {};\n    seed.__proto__ = FalcorJSON.prototype;\n\n    var env = getJSONGraph({\n        _path: [],\n        _root: this._root,\n        _boxed: this._boxed,\n        _materialized: this._materialized,\n        _treatErrorsAsValues: this._treatErrorsAsValues\n    }, paths, seed).data;\n\n    env.paths = collapse(paths);\n\n    return env;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(path) {\n    path = path || [];\n    if (Array.isArray(path) === false) {\n        throw new Error('Model#getVersion must be called with an Array path.');\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    if (opts) {\n        for (var key in opts) {\n            var value = opts[key];\n            if (value === 'delete') {\n                delete clone[key];\n            } else if (key === '_path') {\n                clone[key] = value;\n                if (false === opts.hasOwnProperty('_node')) {\n                    delete clone['_node'];\n                }\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n    if (clone._path.length > 0) {\n        clone.setCache = void 0;\n    }\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n\n    var scheduler;\n\n    if (typeof schedulerOrDelay === 'number') {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay) {\n        scheduler = new TimeoutScheduler(1);\n    } else if (typeof schedulerOrDelay.schedule === 'function') {\n        scheduler = schedulerOrDelay;\n    } else if (typeof schedulerOrDelay === 'function') {\n        scheduler = { scheudle: schedulerOrDelay };\n    }\n\n    return this._clone({ _scheduler: scheduler });\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    return this._clone({ _scheduler: new ImmediateScheduler() });\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({ _treatErrorsAsValues: true });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: 'Steve',\n                surname: 'McGuire'\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints 'Steve'\nproxyModel.getValue('user.name').\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: 'delete'\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: 'delete'\n    });\n};\n\n/* implement inspect method for node's inspect utility */\nModel.prototype.inspect = function inspect() {\n    return '{ v: ' + this.getVersion() + ' p: [' + this._path.join(', ') + '] }';\n}\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: 'ref',\n        value: this.getPath()\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref(['usersById', 32])\n    ],\n    usersById: {\n      32: {\n        name: 'Steve',\n        surname: 'McGuire'\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// ['usersById', 32] - because userModel refers to target of reference at ['users', 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path.slice(0);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._optimizePath = function _optimizePath(path) {\n    var node = getCachePosition(this._root.cache, path);\n    var abs_path = node && node[f_abs_path] || [];\n    return abs_path.slice(0);\n};\n\nModel.prototype._getVersion = require('./cache/getVersion');\nModel.prototype._getPathValuesAsPathMap = getJSON;\nModel.prototype._getPathValuesAsJSONG = getJSONGraph;\n\nModel.prototype._setPathValues = require('./cache/set/setPathValues');\nModel.prototype._setPathMaps = require('./cache/set/setPathMaps');\nModel.prototype._setJSONGs = require('./cache/set/setJSONGraphs');\nModel.prototype._setCache = require('./cache/set/setPathMaps');\n\nModel.prototype._invalidatePathValues = require('./cache/invalidate/invalidatePathSets');\nModel.prototype._invalidatePathMaps = require('./cache/invalidate/invalidatePathMaps');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/Model.js","function ModelDataSourceAdapter(model) {\n    this._model = model\n        // .boxValues()\n        ._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    return this._model.call.apply(this._model, [\n        path, args, suffixes\n    ].concat(paths))._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelDataSourceAdapter.js","var functionTypeof = 'function';\nvar Requests = require('./request/Queue');\nvar getTimestamp = require('./support/getTimestamp');\n\nfunction ModelRoot(o, model) {\n\n    var options = o || {};\n\n    this.cache = {};\n    this.version = -1;\n    this.syncRefCount = 0;\n    this.maxRetryCount = 10;\n    this.topLevelModel = model;\n    this.requests = new Requests(this);\n    this.expired = options.expired || [];\n\n    this.collectRatio = 0.75;\n    this.maxSize = Math.pow(2, 53) - 1;\n\n    if (typeof options.collectRatio === 'number') {\n        this.collectRatio = options.collectRatio;\n    }\n\n    if (typeof options.maxSize === 'number') {\n        this.maxSize = options.maxSize;\n    }\n\n    if (typeof options.comparator === functionTypeof) {\n        this.comparator = options.comparator;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.errorSelector === functionTypeof) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (typeof options.branchSelector === functionTypeof) {\n        this.branchSelector = options.branchSelector;\n    }\n\n    if (typeof options.onChange === functionTypeof) {\n        this.onChange = options.onChange;\n    }\n\n    if (typeof options.onChangesCompleted === functionTypeof) {\n        this.onChangesCompleted = options.onChangesCompleted;\n    }\n}\n\nfunction defaultCompare(node, message) {\n    var cType = node && node.$type;\n    var mType = message && message.$type;\n    if (cType) {\n        // If the cache has a type, but the message is a primitive,\n        // the message might be the primitive response from the datasource.\n        // If so, return true, so we don't update the back-reference versions.\n        if (!mType) {\n            return node.value === message;\n        }\n        // If the message is older than the cache node, then isDistinct = false\n        else if (getTimestamp(message) < getTimestamp(node) === true) {\n            return true; // isDistinct = false\n        }\n        // Otherwise they are the same if all the following fields are the same.\n        return !(\n            cType !== mType ||\n            node.value !== message.value ||\n            node.$expires !== message.$expires\n        );\n    }\n    // If cache doesn't have a type but the message\n    // does, they must be different.\n    else if (mType) {\n        return false;\n    }\n    return node === message;\n}\n\nModelRoot.comparator = ModelRoot.prototype.comparator = defaultCompare;\n\nmodule.exports = ModelRoot;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ModelRoot.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\n\nmodule.exports = { json: json, jsonGraph: jsonGraph };\n\nfunction json(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue =  getJSON(model, thisPaths, data, progressive, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive) {\n    var hasValue = false;\n    if (!_args) {\n        return { missing: false, hasValue: false };\n    }\n    var args = [].concat(_args[1] || []);\n    var suffixes = [].concat(_args[2] || []);\n    var thisPaths = [].concat(_args[3] || []);\n    var path = (model._path || []).concat(_args[0] || []);\n    if (progressive && thisPaths && thisPaths.length) {\n        hasValue = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed,\n            _materialized: model._materialized,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, thisPaths, data, true, true).hasValue;\n    }\n    return {\n        data: data,\n        missing: true,\n        hasValue: hasValue,\n        fragments: [\n            path, args, suffixes, thisPaths\n        ]\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/call/index.js","module.exports = {\n    json: require('./json/getJSON'),\n    jsonGraph: require('./jsonGraph/getJSONGraph')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/index.js","var clone = require('../../clone');\n\nmodule.exports = onError;\n\nfunction onError(node, depth, results,\n                 requestedPath, fromReference, boxValues) {\n\n    var index = -1;\n    var length = depth + !!fromReference; // depth + 1 if fromReference === true\n    var errorPath = new Array(length);\n    var errorValue = !boxValues ? node.value : clone(node);\n\n    while (++index < length) {\n        errorPath[index] = requestedPath[index];\n    }\n\n    (results.errors || (results.errors = [])).push({\n        path: errorPath,\n        value: errorValue\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/onError.js","var arr = new Array(2);\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = require('./onValue');\nvar FalcorJSON = require('./FalcorJSON');\nvar isExpired = require('../../isExpired');\nvar onValueType = require('../onValueType');\nvar originalOnMissing = require('../onMissing');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar onMaterialize = require('../onMaterializeFlatBuffer');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar getHashCode = require('@graphistry/falcor-path-utils/lib/getHashCode');\nvar flatBufferToPaths = require('@graphistry/falcor-path-utils/lib/flatBufferToPaths');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path,\n                                depth, seed, results, requestedPath,\n                                optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === node ||\n        undefined !== (type = node.$type) ||\n        undefined === path) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json,\n                             path, depth, seed, results,\n                             requestedPath, depth,\n                             optimizedPath, optimizedLength,\n                             fromReference, modelRoot, expired, expireImmediate,\n                             branchSelector, boxValues, materialized, hasDataSource,\n                             treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta, f_old_keys, f_new_keys, f_code = '';\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        keys = path['$keys'],\n        nodeAbsPath, jsonAbsPath,\n        nextDepth = depth + 1, rangeEnd,\n        nextJSON, nextReferenceContainer,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[f_abs_path];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[f_meta_data]) {\n\n        nodeAbsPath = node[f_abs_path];\n        jsonAbsPath = f_meta[f_meta_abs_path];\n\n        if (!branchSelector && !(json instanceof FalcorJSON)) {\n            json.__proto__ = {};\n            json.__proto__[f_meta_data] = f_meta;\n            json.__proto__.__proto__ = FalcorJSON.prototype;\n        }\n\n        if (!arrayEqual(nodeAbsPath, jsonAbsPath)) {\n            f_meta['$code'] = '';\n            f_meta[f_meta_status] = 'pending';\n            f_meta[f_meta_abs_path] = nodeAbsPath;\n            f_meta[f_meta_version] = node[f_version];\n            refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n            refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n            if (f_old_keys = f_meta[f_meta_keys]) {\n                f_meta[f_meta_keys] = Object.create(null);\n                for (nextKey in f_old_keys) {\n                    if (f_old_keys[nextKey]) {\n                        delete json[nextKey];\n                    }\n                }\n            }\n            arr[0] = json;\n            arr[1] = true;\n            return arr;\n        } else if (!(\n            f_meta[f_meta_version]  !== node[f_version]  ||\n            f_meta['$code']         !== path['$code'])) {\n            results.hasValue = true;\n            arr[0] = json;\n            arr[1] = false;\n            return arr;\n        }\n\n        f_old_keys = f_meta[f_meta_keys];\n        f_meta[f_meta_abs_path] = nodeAbsPath;\n        f_meta[f_meta_version] = node[f_version];\n        refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n    }\n\n    f_new_keys = Object.create(null);\n\n    var keysIndex = -1;\n    var keysLength = keys.length;\n    var nextPath, nextPathKey,\n        hasMissingPath = false;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            f_code = '' + getHashCode('' + f_code + 'null');\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n            nextPathKey = nextKey;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n            nextPathKey = '[' + nextKey + '..' + rangeEnd + ']';\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextPath === undefined) {\n\n                arr = walkPathAndBuildOutput(\n                    root, next, nextJSON, nextPath, nextDepth, seed,\n                    results, requestedPath, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n            else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                    // If the reference is expired, it will be invalidated and\n                    // reported as missing in the next call to walkPath below.\n                    next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                arr = walkPathAndBuildOutput(\n                    root, next, nextJSON, nextPath, nextDepth, seed,\n                    results, requestedPath, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    if (json && json.hasOwnProperty(nextKey)) {\n                        delete json[nextKey];\n                    }\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[f_meta_version] = node[f_version];\n                f_meta[f_meta_abs_path] = node[f_abs_path];\n                refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n                json = {};\n                json[f_meta_data] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                // node creation to them.\n                if (branchSelector) {\n                    json = branchSelector(json);\n                } else {\n                    var tmp = json;\n                    json = {};\n                    json.__proto__ = tmp;\n                    tmp = undefined;\n                }\n            }\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && (nextKey in f_old_keys)) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        f_code = '' + getHashCode('' + f_code +\n                                 ( !hasMissingPath ? nextPathKey : '') +\n                                 (  nextPath ? nextPath['$code'] : ''));\n    }\n\n    if (f_meta) {\n        f_meta['$code'] = f_code;\n        f_meta[f_meta_keys] = f_new_keys;\n        f_meta[f_meta_status] = hasMissingPath && 'pending' || 'resolved';\n        if (f_old_keys) {\n            for (nextKey in f_old_keys) {\n                if (f_old_keys[nextKey]) {\n                    delete json[nextKey];\n                }\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, json, branchSelector,\n                   boxValues, onMaterialize, modelRoot) {\n\n    if (reportMaterialized) {\n        return onMaterialize(json, path, depth, depth, branchSelector,\n                             boxValues, modelRoot, results, requestedPath, optimizedPath,\n                             optimizedLength, fromReference, reportMissing, onMissing);\n    }\n\n    var paths = path ? flatBufferToPaths(path) : [[]];\n    var rPath = requestedPath.slice(0, requestedLength);\n\n    return paths.forEach(function(restPath) {\n        requestedLength = depth + restPath.length;\n        return originalOnMissing(rPath.concat(restPath), depth, results,\n                                 requestedPath, requestedLength, fromReference,\n                                 optimizedPath, optimizedLength, reportMissing,\n                                 false, json, branchSelector,\n                                 boxValues, onMaterialize, modelRoot);\n    });\n}\n\nfunction arrayEqual(xs, ys) {\n    if (xs === ys) {\n        return true;\n    }\n    var len = xs.length;\n    if (len !== ys.length) {\n        return false;\n    }\n    while (~--len) {\n        if (xs[len] !== ys[len]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkFlatBuffer.js","var arr = new Array(2);\nvar isArray = Array.isArray;\nvar typeofNumber = 'number';\nvar typeofObject = 'object';\nvar onValue = require('./onValue');\nvar onMissing = require('../onMissing');\nvar FalcorJSON = require('./FalcorJSON');\nvar onValueType = require('../onValueType');\nvar isExpired = require('../../isExpired');\nvar onMaterialize = require('../onMaterialize');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, json, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, referenceContainer,\n                                modelRoot, expired, expireImmediate,\n                                branchSelector, boxValues, materialized,\n                                hasDataSource, treatErrorsAsValues,\n                                allowFromWhenceYouCame) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        arr[1] = hasDataSource && node === undefined;\n        arr[0] = onValueType(node, type, json,\n                             path, depth, seed, results,\n                             requestedPath, requestedLength,\n                             optimizedPath, optimizedLength,\n                             fromReference, modelRoot, expired, expireImmediate,\n                             branchSelector, boxValues, materialized, hasDataSource,\n                             treatErrorsAsValues, onValue, onMissing, onMaterialize);\n        return arr;\n    }\n\n    var f_meta;\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        nextJSON, nextReferenceContainer,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1,\n        refContainerAbsPath, refContainerRefPath;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        arr[0] = json;\n        arr[1] = false;\n        return arr;\n    }\n\n    if (allowFromWhenceYouCame && referenceContainer) {\n        refContainerRefPath = referenceContainer.value;\n        refContainerAbsPath = referenceContainer[f_abs_path];\n    }\n\n    if (!json || typeofObject !== typeof json) {\n        json = undefined;\n    } else if (f_meta = json[f_meta_data]) {\n        f_meta[f_meta_version] = node[f_version];\n        f_meta[f_meta_abs_path] = node[f_abs_path];\n        refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n        refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n     var hasMissingPath = false;\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            keyset = keysOrRanges[keysetIndex];\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextJSON = json && json[nextKey];\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n            nextReferenceContainer = referenceContainer;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            if (nextDepth === requestedLength) {\n\n                arr = walkPathAndBuildOutput(\n                    root, next, nextJSON, path, nextDepth, seed,\n                    results, requestedPath, requestedLength, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined && !materialized) {\n                    continue;\n                }\n            }\n            else {\n                // If we encounter a ref, inline the reference target and continue\n                // evaluating the path.\n                if (next &&\n                    // If the reference is expired, it will be invalidated and\n                    // reported as missing in the next call to walkPath below.\n                    next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                    // Retrieve the reference target and next referenceContainer (if\n                    // this reference points to other references) and continue\n                    // following the path. If the reference resolves to a missing\n                    // path or leaf node, it will be handled in the next call to\n                    // walkPath.\n                    refTarget = getReferenceTarget(root, next, modelRoot, expireImmediate);\n\n                    next = refTarget[0];\n                    fromReference = true;\n                    nextOptimizedPath = refTarget[1];\n                    nextReferenceContainer = refTarget[2];\n                    nextOptimizedLength = nextOptimizedPath.length;\n                    refTarget[0] = refTarget[1] = refTarget[2] = undefined;\n                }\n\n                // Continue following the path\n\n                // Inspect the return value from the step and determine whether to\n                // create or write into the JSON branch at this level.\n                //\n                // 1. If the next node was a leaf value, nextJSON is the value.\n                // 2. If the next node was a missing path, nextJSON is undefined.\n                // 3. If the next node was a branch, then nextJSON will either be an\n                //    Object or undefined. If nextJSON is undefined, all paths under\n                //    this step resolved to missing paths. If it's an Object, then\n                //    at least one path resolved to a successful leaf value.\n                //\n                // This check defers creating branches until we see at least one\n                // cache hit. Otherwise, don't waste the cycles creating a branch\n                // if everything underneath is a cache miss.\n\n                arr = walkPathAndBuildOutput(\n                    root, next, nextJSON, path, nextDepth, seed,\n                    results, requestedPath, requestedLength, nextOptimizedPath,\n                    nextOptimizedLength, fromReference, nextReferenceContainer,\n                    modelRoot, expired, expireImmediate, branchSelector, boxValues,\n                    materialized, hasDataSource, treatErrorsAsValues, allowFromWhenceYouCame\n                );\n\n                if (arr[1] === true) {\n                    hasMissingPath = true;\n                }\n\n                if ((nextJSON = arr[0]) === undefined) {\n                    continue;\n                }\n            }\n\n            // The json value will initially be undefined. If we're here,\n            // then at least one leaf value was encountered, so create a\n            // branch to contain it.\n            if (f_meta === undefined) {\n                f_meta = {};\n                f_meta[f_meta_version] = node[f_version];\n                f_meta[f_meta_abs_path] = node[f_abs_path];\n                refContainerRefPath && (f_meta[f_meta_deref_to] = refContainerRefPath);\n                refContainerAbsPath && (f_meta[f_meta_deref_from] = refContainerAbsPath);\n                json = {};\n                json[f_meta_data] = f_meta;\n                json.__proto__ = FalcorJSON.prototype;\n                // Empower developers to instrument branch node creation by\n                // providing a custom function. If they do, delegate branch\n                if (branchSelector) {\n                    json = branchSelector(json);\n                }\n            }\n\n            // Set the reported branch or leaf into this branch.\n            json[nextKey] = nextJSON;\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    if (f_meta) {\n        f_meta[f_meta_status] = hasMissingPath && 'pending' || 'resolved';\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    arr[0] = json;\n    arr[1] = hasMissingPath;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/json/walkPath.js","var arr = new Array(2);\nvar clone = require('../../clone');\nvar inlineValue = require('./inlineValue');\nvar promote = require('../../../lru/promote');\nvar isExpired = require('../../isExpired');\nvar createHardlink = require('../../createHardlink');\nvar CircularReferenceError = require('../../../errors/CircularReferenceError');\n\nmodule.exports = getReferenceTarget;\n\n/* eslint-disable no-undef */\n/* eslint-disable no-console */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction getReferenceTarget(root, ref, modelRoot, seed, expireImmediate) {\n\n    promote(modelRoot, ref);\n\n    var context,\n        key, type, depth = 0,\n        node = root, path = ref.value,\n        copy = path, length = path.length;\n\n    do {\n        if (depth === 0 && undefined !== (context = ref[f_context])) {\n            node = context;\n            depth = length;\n        } else {\n            key = path[depth++];\n            if (undefined === (node = node[key])) {\n                break;\n            }\n        }\n\n        if (depth === length) {\n            type = node.$type;\n            // If the reference points to an expired\n            // value node, don't create a hard-link.\n            if (undefined !== type && isExpired(node, expireImmediate)) {\n                break;\n            }\n            // If a reference points to itself, throw an error.\n            else if (node === ref) {\n                throw new CircularReferenceError(path);\n            }\n            // If the node we land on isn't the existing ref context,\n            // create a hard-link between the reference and the node\n            // it points to.\n            else if (node !== context) {\n                createHardlink(ref, node);\n            }\n\n            // If the reference points to another ref, follow the new ref\n            // by resetting the relevant state and continuing from the top.\n            if (type === $ref) {\n\n                promote(modelRoot, node);\n\n                seed && inlineValue(clone(node), path, length, seed);\n\n                depth = 0;\n                ref = node;\n                node = root;\n                path = copy = ref.value;\n                length = path.length;\n\n                continue;\n            }\n            break;\n        } else if (undefined !== node.$type) {\n            break;\n        }\n    } while (true);\n\n    if (depth < length && undefined !== node) {\n        length = depth;\n    }\n\n    depth = -1;\n    path = new Array(length);\n    while (++depth < length) {\n        path[depth] = copy[depth];\n    }\n\n    arr[0] = node;\n    arr[1] = path;\n\n    return arr;\n}\n/* eslint-enable */\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/getReferenceTarget.js","var typeofObject = 'object';\nvar clone = require('../../clone');\nvar inlineValue = require('./inlineValue');\n\nmodule.exports = onJSONGraphValue;\n\nfunction onJSONGraphValue(node, type, depth, seed, results,\n                          requestedPath, optimizedPath, optimizedLength,\n                          fromReference, boxValues, materialized) {\n\n    var value = node.value;\n\n    // boxValues always clones the node\n    if (boxValues || !(\n        /**\n         * JSON Graph should always clone:\n         * - refs\n         * - errors\n         * - atoms we didn't create\n         * - atoms we created to wrap Objects\n         **/\n        $ref !== type &&\n        $error !== type &&\n        node[f_wrapped_value] &&\n        typeofObject !== typeof value)) {\n        value = clone(node);\n    }\n\n    results.hasValue = true;\n    inlineValue(value, optimizedPath, optimizedLength, seed);\n    (seed.paths || (seed.paths = [])).push(\n        requestedPath.slice(0, depth + !!fromReference) // depth + 1 if fromReference === true\n    );\n\n    return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/onValue.js","var isArray = Array.isArray;\nvar clone = require('../../clone');\nvar onValue = require('./onValue');\nvar inlineValue = require('./inlineValue');\nvar isExpired = require('../../isExpired');\nvar onValueType = require('../onValueType');\nvar onMaterialize = require('../onMaterialize');\nvar originalOnMissing = require('../onMissing');\nvar getReferenceTarget = require('./getReferenceTarget');\nvar NullInPathError = require('../../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = walkPathAndBuildOutput;\n\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction walkPathAndBuildOutput(root, node, path,\n                                depth, seed, results,\n                                requestedPath, requestedLength,\n                                optimizedPath, optimizedLength,\n                                fromReference, modelRoot, expired, expireImmediate,\n                                boxValues, materialized, hasDataSource, treatErrorsAsValues) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (node === undefined || (\n        type = node.$type) || (\n        depth === requestedLength)) {\n        return onValueType(node, type, seed,\n                           path, depth, seed, results,\n                           requestedPath, requestedLength,\n                           optimizedPath, optimizedLength,\n                           fromReference, modelRoot, expired, expireImmediate,\n                           undefined, boxValues, materialized, hasDataSource,\n                           treatErrorsAsValues, onValue, onMissing, onMaterialize);\n    }\n\n    var next, nextKey,\n        keyset, keyIsRange,\n        nextDepth = depth + 1,\n        rangeEnd, keysOrRanges,\n        keysetIndex = -1, keysetLength = 0,\n        nextOptimizedLength, nextOptimizedPath,\n        optimizedLengthNext = optimizedLength + 1;\n\n    keyset = path[depth];\n\n    // If `null` appears before the end of the path, throw an error.\n    // If `null` is at the end of the path, but the reference doesn't\n    // point to a sentinel value, throw an error.\n    //\n    // Inserting `null` at the end of the path indicates the target of a ref\n    // should be returned, rather than the ref itself. When `null` is the last\n    // key, the path is lengthened by one, ensuring that if a ref is encountered\n    // just before the `null` key, the reference is followed before terminating.\n    if (null === keyset) {\n        if (nextDepth < requestedLength) {\n            throw new NullInPathError();\n        }\n        return undefined;\n    }\n\n    // Iterate over every key in the keyset. This loop is perhaps a bit clever,\n    // but we do it this way because this is a performance-sensitive code path.\n    // This loop simulates a recursive function if we encounter a Keyset that\n    // contains Keys or Ranges. This is accomplished by a nifty dance between an\n    // outer loop and an inner loop.\n    //\n    // The outer loop is responsible for identifying if the value at this depth\n    // is a Key, Range, or Keyset. If it encounters a Keyset, the `keysetIndex`,\n    // `keysetLength`, and `keysOrRanges` variables are assigned and the outer\n    // loop restarts. If it encounters a Key or Range, `nextKey`, `keyIsRange`,\n    // and `rangeEnd` are assigned values which signal whether the inner loop\n    // should iterate a Range or exit after the first run.\n    //\n    // The inner loop steps `nextKey` one level down in the cache. If a Range\n    // was encountered in the outer loop, the inner loop will iterate until the\n    // Range has been exhausted. If a Key was encountered, the inner loop exits\n    // after the first execution.\n    //\n    // After the inner loop exits, the outer loop iterates the `keysetIndex`\n    // until the Keyset is exhausted. `keysetIndex` and `keysetLength` are\n    // initialized to -1 and 0 respectively, so if a Keyset wasn't encountered\n    // at this depth in the path, then the outer loop exits after one execution.\n\n    iteratingKeyset: do {\n\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        if ('object' !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If we encounter a Keyset, either iterate through the Keys and Ranges,\n        // or throw an error if we're already iterating a Keyset. Keysets cannot\n        // contain other Keysets.\n        else if (isArray(keyset)) {\n            // If we've already encountered an Array keyset, throw an error.\n            if (keysOrRanges !== undefined) {\n                throw new InvalidKeySetError(path, keysOrRanges);\n            }\n            keysetIndex = 0;\n            keysOrRanges = keyset;\n            keysetLength = keyset.length;\n            // If an Array of keys or ranges is empty, terminate the graph walk\n            // and return the json constructed so far. An example of an empty\n            // Keyset is: ['lolomo', [], 'summary']. This should short circuit\n            // without building missing paths.\n            if (0 === keysetLength) {\n                break iteratingKeyset;\n            }\n            keyset = keysOrRanges[keysetIndex];\n            // Assign `keyset` to the first value in the Keyset. Re-entering the\n            // outer loop mimics a singly-recursive function call.\n            continue iteratingKeyset;\n        }\n        // If the Keyset isn't a primitive or Array, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if ('number' !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n            fromReference = false;\n            nextOptimizedPath = optimizedPath;\n            nextOptimizedLength = optimizedLengthNext;\n\n            next = node[nextKey];\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            // If we encounter a ref, inline the reference target and continue\n            // evaluating the path.\n            if (next &&\n                nextDepth < requestedLength &&\n                // If the reference is expired, it will be invalidated and\n                // reported as missing in the next call to walkPath below.\n                next.$type === $ref && !isExpired(next, expireImmediate)) {\n\n                // Write the cloned ref value into the jsonGraph at the\n                // optimized path. JSONGraph must always clone references.\n                seed && inlineValue(clone(next), optimizedPath, nextOptimizedLength, seed);\n\n                // Retrieve the reference target and next referenceContainer (if\n                // this reference points to other references) and continue\n                // following the path. If the reference resolves to a missing\n                // path or leaf node, it will be handled in the next call to\n                // walkPath.\n                refTarget = getReferenceTarget(root, next, modelRoot, seed, expireImmediate);\n\n                next = refTarget[0];\n                fromReference = true;\n                nextOptimizedPath = refTarget[1];\n                nextOptimizedLength = nextOptimizedPath.length;\n                refTarget[0] = refTarget[1] = undefined;\n            }\n\n            walkPathAndBuildOutput(\n                root, next, path, nextDepth, seed,\n                results, requestedPath, requestedLength, nextOptimizedPath,\n                nextOptimizedLength, fromReference, modelRoot, expired, expireImmediate,\n                boxValues, materialized, hasDataSource, treatErrorsAsValues\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n\n        // If we've exhausted the Keyset (or never encountered one at all),\n        // exit the outer loop.\n        if (++keysetIndex === keysetLength) {\n            break iteratingKeyset;\n        }\n\n        // Otherwise get the next Key or Range from the Keyset and re-enter the\n        // outer loop from the top.\n        keyset = keysOrRanges[keysetIndex];\n    } while (true);\n\n    return undefined;\n}\n/* eslint-enable */\n\nfunction onMissing(path, depth, results,\n                   requestedPath, requestedLength, fromReference,\n                   optimizedPath, optimizedLength, reportMissing,\n                   reportMaterialized, seed, branchSelector,\n                   boxValues, onMaterialize, modelRoot) {\n\n    var json, isLeaf;\n\n    if (seed && reportMaterialized) {\n\n        (seed.paths || (seed.paths = [])).push(\n            (isLeaf = 0 === requestedLength - depth) &&\n                                 // depth + 1 if fromReference === true\n                requestedPath.slice(0, depth + !!fromReference) ||\n                requestedPath.slice(0, depth).concat(path\n                    .slice(depth, requestedLength + !!fromReference))\n        );\n\n        json = inlineValue(isLeaf && clone(materializedAtom) || undefined,\n                           optimizedPath, optimizedLength, seed, !isLeaf);\n    }\n\n    return originalOnMissing(path, depth, results,\n                             requestedPath, requestedLength, fromReference,\n                             optimizedPath, optimizedLength, reportMissing,\n                             !isLeaf && reportMaterialized, json,\n                             branchSelector, true, onMaterialize, modelRoot);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/jsonGraph/walkPath.js","var typeofNumber = 'number';\nvar typeofObject = 'object';\nvar clone = require('../clone');\nvar onValueType = require('./onValueType');\nvar FalcorJSON = require('./json/FalcorJSON');\nvar NullInPathError = require('../../errors/NullInPathError');\nvar InvalidKeySetError = require('../../errors/InvalidKeySetError');\nvar materializedAtom = require('@graphistry/falcor-path-utils/lib/support/materializedAtom');\n\nmodule.exports = onMaterializeFlatBuffer;\n\n/* eslint-disable camelcase */\n/* eslint-disable no-cond-assign */\n/* eslint-disable no-constant-condition */\nfunction onMaterializeFlatBuffer(json, path, depth, length,\n                                 branchSelector, boxValues, modelRoot, results,\n                                 requestedPath, optimizedPath, optimizedLength,\n                                 fromReference, reportMissing, onMissing) {\n\n    var type, refTarget;\n\n    // ============ Check for base cases ================\n\n    // If there's nowhere to go, we've reached a terminal node, or hit\n    // the end of the path, stop now. Either build missing paths or report the value.\n    if (undefined === path) {\n        onValueType(undefined, undefined, json,\n                    path, depth, undefined, results,\n                    requestedPath, depth, optimizedPath,\n                    optimizedLength, fromReference, modelRoot, undefined,\n                    false, branchSelector, boxValues, false, reportMissing,\n                    false, undefined, onMissing, undefined);\n        return boxValues ? clone(materializedAtom) : undefined;\n    }\n\n    var f_meta, f_old_keys, f_new_keys;\n\n    var nextKey,\n        keyset, keyIsRange,\n        keys = path['$keys'],\n        nextDepth = depth + 1, rangeEnd,\n        nextOptimizedLength = optimizedLength + 1;\n\n    if (!json || typeofObject !== typeof json) {\n        json = {};\n        json.__proto__ = FalcorJSON.prototype;\n        json[f_meta_data] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n        if (branchSelector) {\n            json = branchSelector(json);\n        }\n    } else if (!(f_meta = json[f_meta_data])) {\n        json[f_meta_data] = f_meta = {};\n        f_meta['$code'] = '';\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n    } else {\n        f_old_keys = f_meta[f_meta_keys];\n        f_meta['$code'] = '';\n        f_meta[f_meta_status] = 'resolved';\n        f_meta[f_meta_version] = modelRoot.version;\n        f_meta[f_meta_abs_path] = optimizedPath.slice(\n            0, optimizedLength\n        );\n    }\n\n    f_new_keys = Object.create(null);\n\n    var nextPath;\n    var keysIndex = -1;\n    var keysLength = keys.length;\n\n    iteratingKeyset:\n    while (++keysIndex < keysLength) {\n\n        keyset = keys[keysIndex];\n        nextPath = path[keysIndex];\n\n        // If `null` appears before the end of the path, throw an error.\n        // If `null` is at the end of the path, but the reference doesn't\n        // point to a sentinel value, throw an error.\n        //\n        // Inserting `null` at the end of the path indicates the target of a ref\n        // should be returned, rather than the ref itself. When `null` is the last\n        // key, the path is lengthened by one, ensuring that if a ref is encountered\n        // just before the `null` key, the reference is followed before terminating.\n        if (null === keyset) {\n            if (nextPath !== undefined) {\n                throw new NullInPathError();\n            }\n            continue;\n        }\n        // If the keyset is a primitive value, we've found our `nextKey`.\n        else if (typeofObject !== typeof keyset) {\n            nextKey = keyset;\n            rangeEnd = undefined;\n            keyIsRange = false;\n        }\n        // If the Keyset isn't null or primitive, then it must be a Range.\n        else {\n            rangeEnd = keyset.to;\n            nextKey = keyset.from || 0;\n            if (typeofNumber !== typeof rangeEnd) {\n                rangeEnd = nextKey + (keyset.length || 0) - 1;\n            }\n            if ((rangeEnd - nextKey) < 0) {\n                break iteratingKeyset;\n            }\n            keyIsRange = true;\n        }\n\n        // Now that we have the next key, step down one level in the cache.\n        do {\n\n            requestedPath[depth] = nextKey;\n            optimizedPath[optimizedLength] = nextKey;\n\n            f_new_keys[nextKey] = true;\n            if (f_old_keys && (nextKey in f_old_keys)) {\n                f_old_keys[nextKey] = false;\n            }\n\n            // insert the materialized branch\n            json[nextKey] = onMaterializeFlatBuffer(\n                json[nextKey], nextPath, nextDepth,\n                nextDepth, branchSelector, boxValues, modelRoot, results,\n                requestedPath, optimizedPath, nextOptimizedLength,\n                fromReference, reportMissing, onMissing\n            );\n        }\n        // Re-enter the inner loop and continue iterating the Range, or exit\n        // here if we encountered a Key.\n        while (keyIsRange && ++nextKey <= rangeEnd);\n    }\n\n    f_meta[f_meta_keys] = f_new_keys;\n    if (f_old_keys) {\n        for (nextKey in f_old_keys) {\n            if (f_old_keys[nextKey]) {\n                delete json[nextKey];\n            }\n        }\n    }\n\n    // `json` will be a branch if any cache hits, or undefined if all cache misses\n    return json;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/get/onMaterializeFlatBuffer.js","var isInternalKey = require('../support/isInternalKey');\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (key === '$type' || !isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    // only copy objects\n    if (!node || typeof node !== 'object') {\n        return;\n    }\n\n    Object.\n        keys(node).\n        filter(function(key) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return (key === '$type' || !isInternalKey(key)) && node[key] !== undefined;\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === 'object';\n                var isUserCreatedcacheNext = !cacheNext[f_wrapped_value];\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext, key);\n        });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getCache.js","var getBoundCacheNode = require('./getBoundCacheNode');\n\nmodule.exports = function _getVersion(model, path) {\n    var node = getBoundCacheNode(model, path);\n    var version = node && node[f_version];\n    return (version == null) ? -1 : version;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/getVersion.js","var groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: invalidate,\n    jsonGraph: invalidate,\n    invalidatePathMaps: require('./invalidatePathMaps'),\n    invalidatePathValues: require('./invalidatePathSets')\n};\n\nfunction invalidate(model, args, seed, progressive, expireImmediate) {\n    if (invalidateArgumentGroups(model, groupCacheArguments(args), expireImmediate)) {\n        var rootChangeHandler = model._root.onChange;\n        rootChangeHandler && rootChangeHandler();\n    }\n    return {};\n}\n\nfunction invalidateArgumentGroups(model, xs, expireImmediate) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            if (inputType === 'PathValues') {\n                groupedArgs = groupedArgs.map(pluckPaths);\n            }\n            var operation = module.exports['invalidate' + inputType];\n            if (operation(model, groupedArgs, expireImmediate)) {\n                changed = true;\n            }\n        }\n    }\n    return changed;\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/invalidate/index.js","var wrapNode = require('./wrapNode');\nvar isExpired = require('./isExpired');\nvar insertNode = require('./insertNode');\nvar expireNode = require('./expireNode');\nvar replaceNode = require('./replaceNode');\nvar getSize = require('../support/getSize');\nvar reconstructPath = require('./reconstructPath');\nvar getTimestamp = require('../support/getTimestamp');\nvar updateNodeAncestors = require('./updateNodeAncestors');\n\nmodule.exports = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, expireImmediate) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // The message and cache are both undefined, return undefined.\n        if (message === undefined) {\n            return message;\n        }\n        // There should not be undefined values. Those should always be\n        // wrapped in an $atom\n        else if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n        // Is the cache node a branch? If so, return the cache branch.\n        else if ((\n            cIsObject = !(!node || typeof node !== 'object')) && (\n            cType = node.$type) === undefined) {\n            // Has the branch been introduced to the cache yet? If not,\n            // give it a parent, key, and absolute path.\n            if (node[f_parent] === undefined) {\n                insertNode(node, parent, key, version, optimizedPath);\n            }\n            return node;\n        }\n    } else if (cIsObject = !(!node || typeof node !== 'object')) {\n        cType = node.$type;\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty,\n        // leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node, expireImmediate)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = !(!message || typeof message !== 'object');\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node[f_parent] != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node, expireImmediate) &&\n                        !isExpired(message, expireImmediate) &&\n                        mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch,\n    // merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(\n                node, message, parent, key, lru, version),\n            parent, key, undefined, optimizedPath\n        );\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n\n        if (mType === $error && errorSelector) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n        }\n\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n        if (mType && node === message) {\n            if (!node[f_parent]) {\n                node = wrapNode(node, cType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If both the cache and message are primitives, we branch-merged\n            // one of the message's ancestors. Insert the value into the cache.\n            if (!cType && !mType) {\n                isDistinct = true;\n            }\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            else if (!cIsObject || !isExpired(node, expireImmediate)) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                if (comparator) {\n                    isDistinct = !(comparator.length < 3 ?\n                        comparator(node, message) : comparator(node, message,\n                            optimizedPath.slice(0, optimizedPath.index))\n                    );\n                } else {\n                    // Comparing either Number or undefined to undefined always results in false.\n                    isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                }\n            }\n            if (isDistinct) {\n                sizeOffset = getSize(node) - getSize(message =\n                    wrapNode(message, mType, mType ? message.value : message));\n                node = replaceNode(node, message, parent, key, lru, version);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node,\n            /* expireImmediate:\n             * force true so the node is marked as\n             * expired but keep using it for the merge.\n             */\n            true)) {\n            expireNode(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode(message, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/mergeJSONGraphNode.js","var getJSON = require('../get/json');\nvar getJSONGraph = require('../get/jsonGraph');\nvar groupCacheArguments = require('../groupCacheArguments');\n\nmodule.exports = {\n    json: json,\n    jsonGraph: jsonGraph,\n    setPathMaps: require('./setPathMaps'),\n    setPathValues: require('./setPathValues'),\n    setJSONGraphs: require('./setJSONGraphs')\n};\n\nfunction json(model, _args, data, progressive, expireImmediate) {\n\n    var set, get, jsong,\n        changed, relative, optimized,\n        missing, fragments, requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length) {\n\n        if (!(changed = set.changed) || progressive) {\n            get = getJSON(model, relative, data, progressive, expireImmediate);\n        }\n\n        if (changed) {\n\n            jsong = getJSONGraph({\n                _root: model._root,\n                _boxed: model._boxed, _materialized: true,\n                _treatErrorsAsValues: model._treatErrorsAsValues\n            }, set.optimized, {}, progressive, expireImmediate);\n\n            fragments = jsong.data;\n            missing = fragments.paths;\n            requested = jsong.requested;\n\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler();\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: get && get.error,\n        errors: get && get.errors,\n        hasValue: get && get.hasValue\n    };\n}\n\nfunction jsonGraph(model, _args, data, progressive, expireImmediate) {\n\n    var set, jsong,\n        changed, relative, optimized,\n        missing, fragments, requested,\n        args = groupCacheArguments(_args);\n\n    set = setGroupsIntoCache(model, args, expireImmediate);\n\n    if ((relative = set.requested).length && (\n         progressive || (changed = set.changed))) {\n\n        jsong = getJSONGraph({\n            _root: model._root,\n            _boxed: model._boxed, _materialized: true,\n            _treatErrorsAsValues: model._treatErrorsAsValues\n        }, set.optimized, data, progressive, expireImmediate);\n\n        fragments = jsong.data;\n        missing = fragments.paths;\n        requested = jsong.requested;\n\n        if (changed) {\n            var rootChangeHandler = model._root.onChange;\n            rootChangeHandler && rootChangeHandler();\n        }\n    }\n\n    return {\n        args: args,\n        data: data,\n        missing: missing,\n        relative: relative,\n        fragments: fragments,\n        requested: requested,\n        error: jsong && jsong.error,\n        hasValue: jsong && jsong.hasValue\n    };\n}\n\nfunction setGroupsIntoCache(model, xs, expireImmediate) {\n\n    var changed = false;\n    var groupIndex = -1;\n    var groupCount = xs.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n\n    expireImmediate = expireImmediate && !Boolean(model._source);\n    var comparator = Boolean(model._source) ? null : modelRoot.comparator;\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = xs[groupIndex];\n        var inputType = group.inputType;\n        var groupedArgs = group.arguments;\n\n        if (groupedArgs.length > 0) {\n            var operation = module.exports['set' + inputType];\n            var results = operation(model, groupedArgs, errorSelector, comparator, expireImmediate);\n            changed = changed || results[2];\n            optimizedPaths.push.apply(optimizedPaths, results[1]);\n            if (inputType === 'PathValues') {\n                requestedPaths.push.apply(requestedPaths, groupedArgs.map(pluckPaths));\n            } else if (inputType === 'JSONGraphs') {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(groupedArgs, pluckPaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, results[0]);\n            }\n        }\n    }\n\n    return {\n        changed: changed,\n        requested: requestedPaths,\n        optimized: optimizedPaths\n    };\n}\n\nfunction pluckPaths(x) {\n    return x.path || x.paths;\n}\n\nfunction arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/set/index.js","module.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[f_refs_length] || 0,\n        destNodeRefsLength = destNode[f_refs_length] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[f_ref + i];\n        if (ref !== undefined) {\n            ref[f_context] = destNode;\n            destNode[f_ref + (destNodeRefsLength + i)] = ref;\n            fromNode[f_ref + i] = undefined;\n        }\n    }\n    destNode[f_refs_length] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[f_refs_length] = undefined;\n    return destNode;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/transferBackReferences.js","module.exports = function unlinkBackReferences(node) {\n    var i = -1, n = node[f_refs_length] || 0;\n    while (++i < n) {\n        var ref = node[f_ref + i];\n        if (ref != null) {\n            ref[f_context] = ref[f_ref_index] = node[f_ref + i] = void 0;\n        }\n    }\n    node[f_refs_length] = void 0;\n    return node;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkBackReferences.js","module.exports = function unlinkForwardReference(reference) {\n    var destination = reference[f_context];\n    if (destination) {\n        var i = (reference[f_ref_index] || 0) - 1,\n            n = (destination[f_refs_length] || 0) - 1;\n        while (++i <= n) {\n            destination[f_ref + i] = destination[f_ref + (i + 1)];\n        }\n        destination[f_refs_length] = n;\n        reference[f_ref_index] = reference[f_context] = destination = void 0;\n    }\n    return reference;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cache/unlinkForwardReference.js","module.exports = hasValidParentReference;\n\nfunction hasValidParentReference() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    if (reference && reference[f_parent] === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    if (reference && reference[f_invalidated]) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/hasValidParentReference.js","var CONTAINER_DOES_NOT_EXIST = 'e';\nvar FalcorJSON = require('../cache/get/json/FalcorJSON');\nvar getCachePosition = require('../cache/getCachePosition');\nvar InvalidDerefInputError = require('../errors/InvalidDerefInputError');\n\nmodule.exports = function deref(json) {\n\n    var seed, f_meta;\n\n    if (!json || 'object' !== typeof json || !(\n        f_meta = json[f_meta_data]) || 'object' !== typeof f_meta) {\n        return null;\n    }\n\n    var cacheRoot = this._root.cache;\n    var recycleJSON = this._recycleJSON;\n    var absolutePath = f_meta[f_meta_abs_path];\n    var referenceContainer, currentRefPath, i, len;\n\n    if (!absolutePath) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: undefined,\n            _seed: seed\n        });\n    } else if (absolutePath.length === 0) {\n        if (recycleJSON) {\n            seed = { json: json };\n            seed.__proto__ = FalcorJSON.prototype;\n        }\n        return this._clone({\n            _node: cacheRoot,\n            _path: absolutePath,\n            _referenceContainer: true,\n            _seed: seed\n        });\n    }\n\n    var originalRefPath = f_meta[f_meta_deref_to];\n    var originalAbsPath = f_meta[f_meta_deref_from];\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    var cacheNode = getCachePosition(cacheRoot, absolutePath);\n    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n    if (originalAbsPath) {\n\n        validContainer = false;\n\n        i = -1;\n        len = originalAbsPath.length;\n        referenceContainer = cacheRoot;\n        while (++i < len) {\n            referenceContainer = referenceContainer[originalAbsPath[i]];\n            if (!referenceContainer || referenceContainer.$type) {\n                break;\n            }\n        }\n\n        // If the reference container is still a sentinel value then compare\n        // the reference value with refPath.  If they are the same, then the\n        // model is still valid.\n        if (originalRefPath && referenceContainer && referenceContainer.$type === $ref) {\n            validContainer = true;\n            len = originalRefPath.length;\n            currentRefPath = referenceContainer.value;\n            for (i = 0; i < len; ++i) {\n                if (currentRefPath[i] !== originalRefPath[i]) {\n                    cacheNode = undefined;\n                    validContainer = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Signal to the deref'd model that it has been disconnected from the\n    // graph or there is no _fromWhenceYouCame\n    if (!validContainer) {\n        referenceContainer = false;\n    }\n\n    // The container did not exist, therefore there is no reference\n    // container and fromWhenceYouCame should always return true.\n    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n        referenceContainer = true;\n    }\n\n    if (recycleJSON) {\n        seed = { json: json };\n        seed.__proto__ = FalcorJSON.prototype;\n    }\n\n    return this._clone({\n        _seed: seed,\n        _node: cacheNode,\n        _path: absolutePath,\n        _referenceContainer: referenceContainer\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/deref/index.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'It is not legal to use the JSON Graph ' +\n    'format from a bound Model. JSON Graph format' +\n    ' can only be used from a root model.';\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nmodule.exports = createErrorClass('BoundJSONGraphModelError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/BoundJSONGraphModelError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'Deref can only be used with a non-primitive object from get, set, or call.';\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidDerefInputError', function() {\n    this.message = MESSAGE;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidDerefInputError.js","var createErrorClass = require('./createErrorClass');\nvar MESSAGE = 'The boundPath of the model is not valid since a value or error was found before the path end.';\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nmodule.exports = createErrorClass('InvalidModelError', function(boundPath, shortedPath) {\n    this.message = MESSAGE;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/InvalidModelError.js","var createErrorClass = require('./createErrorClass');\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nmodule.exports = createErrorClass('MaxRetryExceededError', function(maxRetryCount, absolute, relative, optimized) {\n    this.message = '' +\n        'Exceeded the max retry count (' + maxRetryCount + ') for these paths: \\n' +\n        (absolute &&\n        'absolute: [\\n\\t' + printPaths(absolute) + '\\n]\\n' || '') +\n        (relative &&\n        'relative: [\\n\\t' + printPaths(relative) + '\\n]\\n' || '') +\n        (optimized &&\n        'optimized: [\\n\\t' + printPaths(optimized) + '\\n]\\n' || '');\n});\n\nfunction printPaths(paths) {\n    return paths.map(function(path) {\n        return JSON.stringify(path);\n    }).join(',\\n\\t');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/MaxRetryExceededError.js","module.exports = String.fromCharCode(30) + 'ƒ_';\n\n\n\n// WEBPACK FOOTER //\n// ./lib/internal/f_.js","var updateNodeAncestors = require('../cache/updateNodeAncestors');\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== 'number') {\n        ratio = 0.75;\n    }\n\n    var node, size, targetSize = max * ratio;\n\n    while (node = expired.pop()) {\n        total -= (size = node.$size || 0);\n        updateNodeAncestors(node, size, lru, version);\n    }\n\n    if (total >= max) {\n        var prev = lru[f_tail];\n        while ((total >= targetSize) && (node = prev)) {\n            prev = prev[f_prev];\n            total -= (size = node.$size || 0);\n            updateNodeAncestors(node, size, lru, version);\n        }\n\n        lru[f_tail] = node;\n        if (node == null) {\n            lru[f_head] = undefined;\n        } else {\n            node[f_next] = undefined;\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lru/collect.js","var Source = require('./Source');\nvar Subscriber = require('./Subscriber');\nvar lruCollect = require('../lru/collect');\nvar FalcorJSON = require('../cache/get/json/FalcorJSON');\nvar collapse = require('@graphistry/falcor-path-utils/lib/collapse');\nvar InvalidSourceError = require('../errors/InvalidSourceError');\nvar MaxRetryExceededError = require('../errors/MaxRetryExceededError');\n\nmodule.exports = Call;\n\nfunction Call(type, model, _args) {\n    Source.call(this, type);\n    if (model && _args) {\n        this.type = type;\n        this.source = this;\n        this.model = model;\n        this._args = _args;\n    }\n}\n\nCall.prototype = Object.create(Source.prototype);\n\nCall.prototype.lift = function(operator, source) {\n    source = new Call(source || this);\n    source.type = this.type;\n    source.model = this.model;\n    source._args = this._args;\n    source.operator = operator;\n    operator.data = operator.data || this.operator.data;\n    operator.errors = operator.errors || this.operator.errors;\n    operator.operation = operator.operation || this.operator.operation;\n    operator.progressive = operator.progressive || this.operator.progressive;\n    operator.maxRetryCount = operator.maxRetryCount || this.operator.maxRetryCount;\n    return source;\n}\n\nCall.prototype.operator = function(subscriber) {\n    return this._subscribe(subscriber);\n}\n\nCall.prototype._subscribe = function(subscriber) {\n    subscriber.onNext({\n        type: this.type,\n        args: this._args,\n        model: this.model,\n        version: this.model._root.version\n    });\n    subscriber.onCompleted();\n    return subscriber;\n}\n\nCall.prototype._toJSON = function(data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(\n        data, errors || this.operator.errors, 'json',\n        this.operator.progressive, this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype._toJSONG = function(data, errors) {\n    if (data === undefined) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n    return this.lift(new CallOperator(\n        data, errors || this.operator.errors, 'jsonGraph',\n        this.operator.progressive, this.operator.maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.retry = function(maxRetryCount) {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        this.operator.progresive,\n        maxRetryCount\n    ), this.source);\n}\n\nCall.prototype.progressively = function() {\n    return this.lift(new CallOperator(\n        this.operator.data,\n        this.operator.errors,\n        this.operator.operation,\n        true,\n        this.operator.maxRetryCount\n    ), this.source);\n}\n\nfunction CallOperator(data, errors, operation, progressive, maxRetryCount) {\n    this.data = data;\n    this.errors = errors;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallOperator.prototype.call = function(source, destination) {\n    return source.subscribe(new CallSubscriber(\n        destination, this.data, this.errors, this.operation, this.progressive\n    ));\n}\n\nfunction CallSubscriber(destination, data, errors, operation, progressive, maxRetryCount) {\n    Subscriber.call(this, destination);\n    this.data = data;\n    this.retryCount = -1;\n    this.errors = errors;\n    this.hasValue = false;\n    this.completed = false;\n    this.operation = operation;\n    this.progressive = progressive;\n    this.maxRetryCount = maxRetryCount;\n}\n\nCallSubscriber.prototype = Object.create(Subscriber.prototype);\nCallSubscriber.prototype.operations = {\n    get: require('../cache/get'),\n    set: require('../cache/set'),\n    call: require('../cache/call'),\n    invalidate: require('../cache/invalidate')\n};\n\nCallSubscriber.prototype.next =\nCallSubscriber.prototype.onNext = function(seed) {\n\n    if (!this.started) {\n        this.args = seed.args;\n        this.type = seed.type;\n        this.model = seed.model;\n        this.version = seed.version;\n        this.maxRetryCount = this.maxRetryCount || this.model._root.maxRetryCount;\n        return;\n    } else if (!this.destination) {\n        return;\n    }\n\n    var missing, fragments;\n    var type = seed.type;\n    var args = seed.args || seed.paths;\n\n    var data = this.data;\n    var model = this.model;\n    var errors = this.errors;\n    var results = this.results;\n    var version = this.version;\n    var hasValue = this.hasValue;\n    var operation = this.operation;\n    var progressive = this.progressive;\n    var seedIsImmutable = progressive && data;\n\n    if (model._recycleJSON && this.type === 'get') {\n        seedIsImmutable = false;\n    }\n\n    // If we request paths as JSON in progressive mode, ensure each progressive\n    // valueNode is immutable. If not in progressive mode, we can write into the\n    // same JSON tree until the request is completed.\n    if (seedIsImmutable) {\n        data = {};\n        data.__proto__ = FalcorJSON.prototype;\n    }\n\n    if (args && args.length) {\n\n        results = this.operations[type]\n            [operation](model, args, data,\n                        progressive || !model._source,\n                        this.retryCount === -1);\n\n        // We must communicate critical errors from get, such as bound path is\n        // broken or this is a JSONGraph request with a bound path.\n        if (results.error) {\n            return tryOnError(this, results.error);\n        }\n\n        errors && results.errors &&\n            errors.push.apply(errors, results.errors);\n\n        if (fragments = results.fragments) {\n            args = results.args;\n            this.fragments = fragments;\n        }\n\n        this.relative = results.relative;\n        this.requested = results.requested;\n        this.missing = missing = results.missing;\n        this.hasValue = hasValue || (hasValue = results.hasValue);\n    }\n\n    // We are done when there are no missing paths or\n    // the model does not have a dataSource to fetch from.\n    this.completed = !missing || !model._source;\n\n    if (type !== 'set') {\n        this.args = args;\n        if (seedIsImmutable) {\n            this.data = mergeInto(data, this.data);\n        }\n    }\n\n    if (progressive && hasValue && data && (data.json || data.jsonGraph)) {\n        tryOnNext(data, operation, model._root, this.destination);\n    }\n}\n\nCallSubscriber.prototype.error =\nCallSubscriber.prototype.onError = function(error) {\n    if (error instanceof InvalidSourceError) {\n        return Subscriber.prototype.onError.call(this, error);\n    }\n    this.errored = true;\n    this.onCompleted(error);\n}\n\nCallSubscriber.prototype.complete =\nCallSubscriber.prototype.onCompleted = function(error) {\n\n    if (!this.destination) {\n        return;\n    }\n\n    var data, type, errors, errored;\n\n    if (!this.started && (this.started = true)) {\n        this.onNext(this);\n    } else if (errored = this.errored) {\n        this.onNext({ type: 'get', paths: this.relative });\n    }\n\n    if (errored || this.completed) {\n        if (!this.progressive && this.hasValue && (\n            (data = this.data) && data.json || data.jsonGraph)) {\n            tryOnNext(data, this.operation, this.model._root, this.destination);\n        }\n        errors = this.errors;\n        if (errored || error || errors && errors.length) {\n            return tryOnError(this, errors.length && errors || error);\n        }\n\n        return Subscriber.prototype.onCompleted.call(this);\n    }\n\n    if (++this.retryCount >= this.maxRetryCount) {\n        return tryOnError(this, new MaxRetryExceededError(\n            this.retryCount,\n            this.requested,\n            this.relative,\n            this.missing\n        ));\n    }\n\n    this.request = this.model._root.requests[this.type](\n        this.model, this.missing, this.relative, this.fragments\n    ).subscribe(this);\n}\n\nCallSubscriber.prototype.dispose =\nCallSubscriber.prototype.unsubscribe = function() {\n\n    var model = this.model;\n    var version = this.version;\n    var request = this.request;\n\n    this.args = null;\n    this.data = null;\n    this.model = null;\n    this.errors = null;\n    this.errored = false;\n    this.started = false;\n    this.hasValue = false;\n    this.completed = false;\n\n    Subscriber.prototype.dispose.call(this);\n\n    if (request) {\n        this.request = null;\n        request.dispose();\n    }\n\n    if (model) {\n\n        var modelRoot = model._root;\n        var cache = modelRoot.cache;\n        var shouldCollectCache = modelRoot.syncRefCount <= 0 &&\n                                 version !== modelRoot.version;\n\n        // Prune the cache via the LRU if this is the last request.\n        if (shouldCollectCache) {\n\n            if (cache) {\n                lruCollect(modelRoot,\n                           modelRoot.expired,\n                           cache.$size || 0,\n                           modelRoot.maxSize,\n                           modelRoot.collectRatio,\n                           modelRoot.version);\n            }\n\n            var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;\n\n            if (rootOnChangesCompletedHandler) {\n                rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);\n            }\n        }\n    }\n}\n\nfunction tryOnNext(data, operation, modelRoot, destination) {\n    if (operation === 'jsonGraph' && data.paths) {\n        data.paths = collapse(data.paths);\n    }\n    try {\n        ++modelRoot.syncRefCount;\n        destination.onNext(data);\n    } catch(e) {\n        throw e;\n    } finally {\n        --modelRoot.syncRefCount;\n    }\n}\n\nfunction tryOnError(self, error) {\n    try {\n        throw error;\n    } catch (err) {\n        Subscriber.prototype.onError.call(self, err);\n    }\n}\n\nfunction mergeInto(dest, node) {\n\n    var destValue, nodeValue,\n        key, keys = Object.keys(node),\n        index = -1, length = keys.length;\n\n    while (++index < length) {\n\n        key = keys[index];\n\n        if (key === f_meta_data) {\n            dest[f_meta_data] = node[f_meta_data];\n        } else {\n\n            nodeValue = node[key];\n            destValue = dest[key];\n\n            if (destValue !== nodeValue) {\n                if (!nodeValue || typeof nodeValue !== 'object') {\n                    if (destValue === undefined) {\n                        dest[key] = nodeValue;\n                    }\n                } else if (destValue === undefined) {\n                    dest[key] = nodeValue;\n                } else {\n                    mergeInto(destValue, nodeValue);\n                }\n            }\n        }\n    }\n\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Call.js","var Source = require('./Source');\nvar Request = require('./Request');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar ImmediateScheduler = require('../schedulers/ImmediateScheduler');\n\nmodule.exports = Queue;\n\nfunction Queue(modelRoot) {\n    Subscription.call(this, []);\n    this.modelRoot = modelRoot;\n}\n\nQueue.prototype = Object.create(Subscription.prototype);\n\nQueue.prototype.set = isolateSet;\nQueue.prototype.call = isolateCall;\nQueue.prototype.get = batchAndDedupeGet;\n\nfunction isolateSet(model, optimized, requested, env) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('set', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = env.jsonGraph;\n        request.requested.push(requested);\n        request.optimized.push(optimized);\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction isolateCall(model, optimized, requested, callArgs) {\n    var queue = this;\n    return new Source(function(destination) {\n\n        var request = new Request('call', queue, model._source, new ImmediateScheduler());\n        var subscriber = request.subscribe(new Subscriber(destination, request));\n\n        queue.add(request);\n        request.data = callArgs;\n        request.boundPath = model._path;\n\n        request.connect();\n\n        return subscriber;\n    });\n}\n\nfunction batchAndDedupeGet(model, optimized, requested) {\n    return new Dedupe(\n        this, model._source, model._scheduler, requested, optimized\n    );\n}\n\nfunction Dedupe(queue, source, scheduler, requested, optimized) {\n    this.queue = queue;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n    this.requested = requested;\n    this.optimized = optimized;\n}\n\nDedupe.prototype.subscribe = function(destination) {\n\n    var queue = this.queue;\n    var source = this.dataSource;\n    var requested = this.requested;\n    var optimized = this.optimized;\n    var scheduler = this.scheduler;\n\n    var requestsIndex = -1;\n    var requests  = queue.subscriptions;\n    var requestsCount = requests.length;\n    var subscription = new Subscription([], destination);\n\n    while (++requestsIndex < requestsCount) {\n\n        var request = requests[requestsIndex];\n\n        if (request.type !== 'get') {\n            continue;\n        }\n\n        if (request = request.batch(requested, optimized, requested = [], optimized = [])) {\n            subscription.add(request.subscribe(new Subscriber(destination, request)));\n        }\n\n        if (!optimized.length) {\n            break;\n        }\n    }\n\n    if (optimized.length) {\n        request = requests[requestsIndex] =\n            new Request('get', queue, source, scheduler).batch(requested, optimized);\n        subscription.add(request.subscribe(new Subscriber(destination, request)));\n        request.connect();\n    }\n\n    return subscription;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Queue.js","var isArray = Array.isArray;\nvar Subject = require('./Subject');\nvar Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\nvar InvalidSourceError = require('../errors/InvalidSourceError');\n\nvar setJSONGraphs = require('../cache/set/setJSONGraphs');\nvar setPathValues = require('../cache/set/setPathValues');\nvar invalidatePaths = require('../cache/invalidate/invalidatePathSets');\n\nvar toPaths = require('@graphistry/falcor-path-utils/lib/toPaths');\nvar toCollapseMap = require('@graphistry/falcor-path-utils/lib/toCollapseMap');\nvar toCollapseTrees = require('@graphistry/falcor-path-utils/lib/toCollapseTrees');\nvar hasIntersection = require('@graphistry/falcor-path-utils/lib/hasIntersection');\n\nmodule.exports = Request;\n\nfunction Request(type, queue, source, scheduler) {\n    Subject.call(this, [], queue);\n    this.tree = {};\n    this.paths = [];\n    this.type = type;\n    this.data = null;\n    this.active = false;\n    this.responded = false;\n    this.requested = [];\n    this.optimized = [];\n    this.disposable = null;\n    this.dataSource = source;\n    this.scheduler = scheduler;\n}\n\nRequest.prototype = Object.create(Subject.prototype);\n\nRequest.prototype.next =\nRequest.prototype.onNext = function(env) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    var changed = false;\n    var jsonGraph = env.jsonGraph;\n    var boundPath = this.boundPath;\n    var modelRoot = queue.modelRoot;\n    var invalidated = env.invalidated;\n    var paths = env.paths || this.paths;\n    var requested = this.requested.slice(0);\n    var rootChangeHandler = modelRoot.onChange;\n\n    // Run invalidations first.\n    if (invalidated && invalidated.length) {\n        changed = invalidatePaths({ _root: modelRoot, _path: [] }, invalidated, false);\n    }\n\n    if (paths && paths.length && !(!jsonGraph || typeof jsonGraph !== 'object')) {\n        var results = setJSONGraphs(\n            { _root: modelRoot },\n            [{ paths: paths, jsonGraph: jsonGraph }],\n            modelRoot.errorSelector, modelRoot.comparator, false\n        );\n        paths = results[0];\n        changed = changed || results[2];\n    }\n\n    if (changed && rootChangeHandler) {\n        rootChangeHandler();\n    }\n\n    this.observers.slice(0).forEach(function(observer, index) {\n        observer.onNext({\n            type: 'get', paths: requested[index] ||\n                filterPathsBoundTo(boundPath, paths)\n        });\n    });\n}\n\nRequest.prototype.error =\nRequest.prototype.onError = function(error) {\n\n    var queue = this.parent;\n\n    if (!queue) {\n        return;\n    }\n\n    if (this.responded === false) {\n        this.responded = true;\n        // Remove this request from the request queue as soon as we get\n        // at least one response back. This ensures we won't be the target\n        // of in-flight batch requests.\n        queue.remove(this);\n    }\n\n    error = error || {};\n\n    // Converts errors to object we can insert into the cache.\n    error = !(error instanceof Error) ?\n        // if it's $type error, use it raw\n        error.$type === $error && error ||\n        // Otherwise make it an error\n        { $type: $error, value: error } :\n        // If it's instanceof Error, pluck error.message\n        { $type: $error, value: { message: error.message }};\n\n    var modelRoot = queue.modelRoot;\n\n    var errorPathValues = toPaths(toCollapseTrees(\n        this.requested.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ))\n    .map(function(path) { return { path: path, value: error }; });\n\n    if (errorPathValues.length) {\n        setPathValues(\n            { _root: modelRoot, _path: [] },\n            errorPathValues,\n            modelRoot.errorSelector,\n            modelRoot.comparator,\n            false\n        );\n    }\n\n    Subject.prototype.onError.call(this, error);\n}\n\nRequest.prototype.complete =\nRequest.prototype.onCompleted = function() {\n    if (this.responded === false) {\n        this.onNext({});\n    }\n    Subject.prototype.onCompleted.call(this);\n}\n\nRequest.prototype.remove = function(subscription) {\n    var index = this.subscriptions.indexOf(subscription);\n    if (~index) {\n        this.requested.splice(index, 1);\n        this.optimized.splice(index, 1);\n        this.observers.splice(index, 1);\n        this.subscriptions.splice(index, 1);\n    }\n    if (this.subscriptions.length === 0) {\n        this.dispose();\n    }\n    return this;\n}\n\nRequest.prototype.dispose =\nRequest.prototype.unsubscribe = function () {\n    this.tree = {};\n    this.data = null;\n    this.paths = null;\n    this.active = false;\n    this.boundPath = null;\n    this.requested = [];\n    this.optimized = [];\n    var queue = this.parent;\n    if (queue) {\n        this.parent = null;\n        queue.remove(this);\n    }\n    var disposable = this.disposable;\n    if (disposable) {\n        this.disposable = null;\n        if (disposable.dispose) {\n            disposable.dispose();\n        } else if (disposable.unsubscribe) {\n            disposable.unsubscribe();\n        }\n    }\n    Subject.prototype.dispose.call(this);\n}\n\nRequest.prototype.connect = function() {\n    if (!this.active && !this.disposable) {\n        var scheduledDisposable = this.scheduler.schedule(flush.bind(this));\n        if (!this.disposable) {\n            this.disposable = scheduledDisposable;\n        }\n    }\n    return this;\n}\n\nRequest.prototype.batch = function(requested, optimized,\n                                   requestedComplements,\n                                   optimizedComplements) {\n    if (this.active) {\n        var requestedIntersection = [];\n        var optimizedIntersection = [];\n        if (findIntersections(this.tree,\n                              requested, optimized,\n                              requestedComplements,\n                              optimizedComplements,\n                              requestedIntersection,\n                              optimizedIntersection)) {\n            this.requested.push(requestedIntersection);\n            this.optimized.push(optimizedIntersection);\n            return this;\n        }\n        return null;\n    }\n    this.requested.push(requested);\n    this.optimized.push(optimized);\n    return this;\n}\n\nfunction flush() {\n\n    this.active = true;\n\n    var obs, paths = this.paths = toPaths(this.tree = toCollapseTrees(\n        this.optimized.reduce(function(collapseMap, paths) {\n            return toCollapseMap(paths, collapseMap);\n        }, {})\n    ));\n\n    try {\n        switch (this.type) {\n            case 'get':\n                obs = this.dataSource.get(paths);\n                break;\n            case 'set':\n                obs = this.dataSource.set({ paths: paths, jsonGraph: this.data });\n                break;\n            case 'call':\n                obs = this.dataSource.call.apply(this.dataSource, this.data);\n                break;\n        }\n        this.disposable = obs.subscribe(this);\n    } catch (e) {\n        this.disposable = {};\n        Subject.prototype.onError.call(this, new InvalidSourceError(e));\n    }\n}\n\nfunction findIntersections(tree,\n                           requested, optimized,\n                           requestedComplements,\n                           optimizedComplements,\n                           requestedIntersection,\n                           optimizedIntersection) {\n\n    var index = -1;\n    var complementIndex = -1;\n    var intersectionIndex = -1;\n    var optTotal = optimized.length;\n    var reqTotal = requested.length - 1;\n\n    while (++index < optTotal) {\n        var path = optimized[index];\n        var pathLen = path.length;\n        var subTree = tree[pathLen];\n        if (subTree && hasIntersection(subTree, path, 0, pathLen)) {\n            optimizedIntersection[++intersectionIndex] = path;\n            requestedIntersection[intersectionIndex] = requested[\n                index < reqTotal ? index : reqTotal\n            ];\n        } else {\n            optimizedComplements[++complementIndex] = path;\n            requestedComplements[complementIndex] = requested[\n                index < reqTotal ? index : reqTotal\n            ];\n        }\n    }\n\n    return ~intersectionIndex;\n}\n\nfunction filterPathsBoundTo(boundPath, paths) {\n\n    var boundLength;\n\n    if (!boundPath || (boundLength = boundPath.length) === 0) {\n        return paths;\n    }\n\n    var filtered = [], filteredIndex = -1, keyIndex;\n    var path, pathsIndex = -1, pathsCount = paths.length;\n\n    outer: while (++pathsIndex < pathsCount) {\n        path = paths[pathsIndex];\n        if (path.length > boundLength) {\n            keyIndex = 0;\n            do {\n                if (path[keyIndex] !== boundPath[keyIndex]) {\n                    continue outer;\n                }\n            } while (++keyIndex < boundLength);\n            filtered[++filteredIndex] = path.slice(boundLength);\n        }\n    }\n\n    return filtered;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Request.js","var Subscriber = require('./Subscriber');\nvar Subscription = require('./Subscription');\n\nmodule.exports = Subject;\n\nfunction Subject(observers, parent) {\n    Subscriber.call(this, null, parent);\n    this.observers = observers || [];\n}\n\nSubject.prototype = Object.create(Subscriber.prototype);\n\n// Unused\n// Subject.prototype.onNext = function(value) {\n//     this.observers.slice(0).forEach(function(observer) {\n//         observer.onNext(value);\n//     });\n// }\n\nSubject.prototype.onError = function(error) {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onError(error);\n    });\n}\n\nSubject.prototype.onCompleted = function() {\n    var observers = this.observers.slice(0);\n    this.dispose();\n    observers.forEach(function(observer) {\n        observer.onCompleted();\n    });\n}\n\nSubject.prototype.subscribe = function(subscriber) {\n    this.observers.push(subscriber);\n    this.subscriptions.push(subscriber = new Subscription([subscriber], this));\n    return subscriber;\n}\n\nSubject.prototype.dispose =\nSubject.prototype.unsubscribe = function () {\n    this.observers = [];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/request/Subject.js","function TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    return new TimerDisposable(setTimeout(action, this.delay));\n};\n\nTimerDisposable.prototype.dispose =\nTimerDisposable.prototype.unsubscribe = function() {\n    if (!this.disposed) {\n        clearTimeout(this.id);\n        this.id = null;\n        this.disposed = true;\n    }\n};\n\nmodule.exports = TimeoutScheduler;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/schedulers/TimeoutScheduler.js","var isArray = Array.isArray;\nvar isInternal = require('../internal/isInternal');\n\nmodule.exports = clone;\n\nfunction clone(source) {\n    var dest = source;\n    if (!(!dest || typeof dest !== 'object')) {\n        dest = isArray(source) ? [] : {};\n        for (var key in source) {\n            if (isInternal(key)) {\n                continue;\n            }\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/clone.js","var isObject = require('./isObject');\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getExpires.js","var isObject = require('./../support/isObject');\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return 'branch';\n    }\n    return type;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/getType.js","var isArray = Array.isArray;\nvar isObject = require('./../support/isObject');\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === 'string'\n        ));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/support/isPathValue.js","module.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/index.js\n// module id = 94\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/index.js\n// module id = 95\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/ponyfill.js\n// module id = 96\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 97\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/computeFlatBufferHash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/computeFlatBufferHash\"\n// module id = 98\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/flatBufferToPaths\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/flatBufferToPaths\"\n// module id = 99\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/getHashCode\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/getHashCode\"\n// module id = 100\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/hasIntersection\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/hasIntersection\"\n// module id = 101\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/toCollapseMap\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/toCollapseMap\"\n// module id = 102\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/toCollapseTrees\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/toCollapseTrees\"\n// module id = 103\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/toFlatBuffer\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/toFlatBuffer\"\n// module id = 104\n// module chunks = 0","module.exports = require(\"@graphistry/falcor-path-utils/lib/toPaths\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@graphistry/falcor-path-utils/lib/toPaths\"\n// module id = 105\n// module chunks = 0"],"sourceRoot":""}